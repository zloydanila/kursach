=== kursach/src/CMakeFiles/3.28.3/CompilerIdCXX/CMakeCXXCompilerId.cpp ===
/* This source file must have a .cpp extension so that all C++ compilers
   recognize the extension without flags.  Borland does not know .cxx for
   example.  */
#ifndef __cplusplus
# error "A C compiler has been selected for C++."
#endif

#if !defined(__has_include)
/* If the compiler does not have __has_include, pretend the answer is
   always no.  */
#  define __has_include(x) 0
#endif


/* Version number components: V=Version, R=Revision, P=Patch
   Version date components:   YYYY=Year, MM=Month,   DD=Day  */

#if defined(__COMO__)
# define COMPILER_ID "Comeau"
  /* __COMO_VERSION__ = VRR */
# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)
# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)

#elif defined(__INTEL_COMPILER) || defined(__ICC)
# define COMPILER_ID "Intel"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# if defined(__GNUC__)
#  define SIMULATE_ID "GNU"
# endif
  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
     except that a few beta releases use the old format with V=2021.  */
# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
#  if defined(__INTEL_COMPILER_UPDATE)
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
#  else
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
#  endif
# else
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)
   /* The third version component from --version is an update index,
      but no macro is provided for it.  */
#  define COMPILER_VERSION_PATCH DEC(0)
# endif
# if defined(__INTEL_COMPILER_BUILD_DATE)
   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
# endif
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# if defined(__GNUC__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
# elif defined(__GNUG__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)
# define COMPILER_ID "IntelLLVM"
#if defined(_MSC_VER)
# define SIMULATE_ID "MSVC"
#endif
#if defined(__GNUC__)
# define SIMULATE_ID "GNU"
#endif
/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and
 * later.  Look for 6 digit vs. 8 digit version number to decide encoding.
 * VVVV is no smaller than the current year when a version is released.
 */
#if __INTEL_LLVM_COMPILER < 1000000L
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)
#else
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)
#endif
#if defined(_MSC_VER)
  /* _MSC_VER = VVRR */
# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
#endif
#if defined(__GNUC__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#elif defined(__GNUG__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
#endif
#if defined(__GNUC_MINOR__)
# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
#endif
#if defined(__GNUC_PATCHLEVEL__)
# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
#endif

#elif defined(__PATHCC__)
# define COMPILER_ID "PathScale"
# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)
# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)
# if defined(__PATHCC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)
# endif

#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)
# define COMPILER_ID "Embarcadero"
# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)
# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)
# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)

#elif defined(__BORLANDC__)
# define COMPILER_ID "Borland"
  /* __BORLANDC__ = 0xVRR */
# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)
# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)

#elif defined(__WATCOMC__) && __WATCOMC__ < 1200
# define COMPILER_ID "Watcom"
   /* __WATCOMC__ = VVRR */
# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__WATCOMC__)
# define COMPILER_ID "OpenWatcom"
   /* __WATCOMC__ = VVRP + 1100 */
# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__SUNPRO_CC)
# define COMPILER_ID "SunPro"
# if __SUNPRO_CC >= 0x5100
   /* __SUNPRO_CC = 0xVRRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
# else
   /* __SUNPRO_CC = 0xVRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)
# endif

#elif defined(__HP_aCC)
# define COMPILER_ID "HP"
  /* __HP_aCC = VVRRPP */
# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)
# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)

#elif defined(__DECCXX)
# define COMPILER_ID "Compaq"
  /* __DECCXX_VER = VVRRTPPPP */
# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)
# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)
# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)

#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)
# define COMPILER_ID "zOS"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__open_xl__) && defined(__clang__)
# define COMPILER_ID "IBMClang"
# define COMPILER_VERSION_MAJOR DEC(__open_xl_version__)
# define COMPILER_VERSION_MINOR DEC(__open_xl_release__)
# define COMPILER_VERSION_PATCH DEC(__open_xl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__open_xl_ptf_fix_level__)


#elif defined(__ibmxl__) && defined(__clang__)
# define COMPILER_ID "XLClang"
# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)
# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)
# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)


#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800
# define COMPILER_ID "XL"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ < 800
# define COMPILER_ID "VisualAge"
  /* __IBMCPP__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)

#elif defined(__NVCOMPILER)
# define COMPILER_ID "NVHPC"
# define COMPILER_VERSION_MAJOR DEC(__NVCOMPILER_MAJOR__)
# define COMPILER_VERSION_MINOR DEC(__NVCOMPILER_MINOR__)
# if defined(__NVCOMPILER_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__NVCOMPILER_PATCHLEVEL__)
# endif

#elif defined(__PGI)
# define COMPILER_ID "PGI"
# define COMPILER_VERSION_MAJOR DEC(__PGIC__)
# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)
# if defined(__PGIC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)
# endif

#elif defined(__clang__) && defined(__cray__)
# define COMPILER_ID "CrayClang"
# define COMPILER_VERSION_MAJOR DEC(__cray_major__)
# define COMPILER_VERSION_MINOR DEC(__cray_minor__)
# define COMPILER_VERSION_PATCH DEC(__cray_patchlevel__)
# define COMPILER_VERSION_INTERNAL_STR __clang_version__


#elif defined(_CRAYC)
# define COMPILER_ID "Cray"
# define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)
# define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)

#elif defined(__TI_COMPILER_VERSION__)
# define COMPILER_ID "TI"
  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
# define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)
# define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)
# define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)

#elif defined(__CLANG_FUJITSU)
# define COMPILER_ID "FujitsuClang"
# define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
# define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
# define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
# define COMPILER_VERSION_INTERNAL_STR __clang_version__


#elif defined(__FUJITSU)
# define COMPILER_ID "Fujitsu"
# if defined(__FCC_version__)
#   define COMPILER_VERSION __FCC_version__
# elif defined(__FCC_major__)
#   define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
#   define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
#   define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
# endif
# if defined(__fcc_version)
#   define COMPILER_VERSION_INTERNAL DEC(__fcc_version)
# elif defined(__FCC_VERSION)
#   define COMPILER_VERSION_INTERNAL DEC(__FCC_VERSION)
# endif


#elif defined(__ghs__)
# define COMPILER_ID "GHS"
/* __GHS_VERSION_NUMBER = VVVVRP */
# ifdef __GHS_VERSION_NUMBER
# define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100)
# define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10)
# define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER      % 10)
# endif

#elif defined(__TASKING__)
# define COMPILER_ID "Tasking"
  # define COMPILER_VERSION_MAJOR DEC(__VERSION__/1000)
  # define COMPILER_VERSION_MINOR DEC(__VERSION__ % 100)
# define COMPILER_VERSION_INTERNAL DEC(__VERSION__)

#elif defined(__ORANGEC__)
# define COMPILER_ID "OrangeC"
# define COMPILER_VERSION_MAJOR DEC(__ORANGEC_MAJOR__)
# define COMPILER_VERSION_MINOR DEC(__ORANGEC_MINOR__)
# define COMPILER_VERSION_PATCH DEC(__ORANGEC_PATCHLEVEL__)

#elif defined(__SCO_VERSION__)
# define COMPILER_ID "SCO"

#elif defined(__ARMCC_VERSION) && !defined(__clang__)
# define COMPILER_ID "ARMCC"
#if __ARMCC_VERSION >= 1000000
  /* __ARMCC_VERSION = VRRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)
#else
  /* __ARMCC_VERSION = VRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)
#endif


#elif defined(__clang__) && defined(__apple_build_version__)
# define COMPILER_ID "AppleClang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)

#elif defined(__clang__) && defined(__ARMCOMPILER_VERSION)
# define COMPILER_ID "ARMClang"
  # define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION/100   % 100)
# define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION)

#elif defined(__clang__)
# define COMPILER_ID "Clang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif

#elif defined(__LCC__) && (defined(__GNUC__) || defined(__GNUG__) || defined(__MCST__))
# define COMPILER_ID "LCC"
# define COMPILER_VERSION_MAJOR DEC(__LCC__ / 100)
# define COMPILER_VERSION_MINOR DEC(__LCC__ % 100)
# if defined(__LCC_MINOR__)
#  define COMPILER_VERSION_PATCH DEC(__LCC_MINOR__)
# endif
# if defined(__GNUC__) && defined(__GNUC_MINOR__)
#  define SIMULATE_ID "GNU"
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
#  if defined(__GNUC_PATCHLEVEL__)
#   define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
#  endif
# endif

#elif defined(__GNUC__) || defined(__GNUG__)
# define COMPILER_ID "GNU"
# if defined(__GNUC__)
#  define COMPILER_VERSION_MAJOR DEC(__GNUC__)
# else
#  define COMPILER_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif defined(_MSC_VER)
# define COMPILER_ID "MSVC"
  /* _MSC_VER = VVRR */
# define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
# define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
# if defined(_MSC_FULL_VER)
#  if _MSC_VER >= 1400
    /* _MSC_FULL_VER = VVRRPPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
#  else
    /* _MSC_FULL_VER = VVRRPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
#  endif
# endif
# if defined(_MSC_BUILD)
#  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)
# endif

#elif defined(_ADI_COMPILER)
# define COMPILER_ID "ADSP"
#if defined(__VERSIONNUM__)
  /* __VERSIONNUM__ = 0xVVRRPPTT */
#  define COMPILER_VERSION_MAJOR DEC(__VERSIONNUM__ >> 24 & 0xFF)
#  define COMPILER_VERSION_MINOR DEC(__VERSIONNUM__ >> 16 & 0xFF)
#  define COMPILER_VERSION_PATCH DEC(__VERSIONNUM__ >> 8 & 0xFF)
#  define COMPILER_VERSION_TWEAK DEC(__VERSIONNUM__ & 0xFF)
#endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# define COMPILER_ID "IAR"
# if defined(__VER__) && defined(__ICCARM__)
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000)
#  define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000)
#  define COMPILER_VERSION_PATCH DEC((__VER__) % 1000)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)
#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))
#  define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# endif


/* These compilers are either not known or too old to define an
  identification macro.  Try to identify the platform and guess that
  it is the native compiler.  */
#elif defined(__hpux) || defined(__hpua)
# define COMPILER_ID "HP"

#else /* unknown compiler */
# define COMPILER_ID ""
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";
#ifdef SIMULATE_ID
char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";
#endif

#ifdef __QNXNTO__
char const* qnxnto = "INFO" ":" "qnxnto[]";
#endif

#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
char const *info_cray = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";
#endif

#define STRINGIFY_HELPER(X) #X
#define STRINGIFY(X) STRINGIFY_HELPER(X)

/* Identify known platforms by name.  */
#if defined(__linux) || defined(__linux__) || defined(linux)
# define PLATFORM_ID "Linux"

#elif defined(__MSYS__)
# define PLATFORM_ID "MSYS"

#elif defined(__CYGWIN__)
# define PLATFORM_ID "Cygwin"

#elif defined(__MINGW32__)
# define PLATFORM_ID "MinGW"

#elif defined(__APPLE__)
# define PLATFORM_ID "Darwin"

#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
# define PLATFORM_ID "Windows"

#elif defined(__FreeBSD__) || defined(__FreeBSD)
# define PLATFORM_ID "FreeBSD"

#elif defined(__NetBSD__) || defined(__NetBSD)
# define PLATFORM_ID "NetBSD"

#elif defined(__OpenBSD__) || defined(__OPENBSD)
# define PLATFORM_ID "OpenBSD"

#elif defined(__sun) || defined(sun)
# define PLATFORM_ID "SunOS"

#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)
# define PLATFORM_ID "AIX"

#elif defined(__hpux) || defined(__hpux__)
# define PLATFORM_ID "HP-UX"

#elif defined(__HAIKU__)
# define PLATFORM_ID "Haiku"

#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)
# define PLATFORM_ID "BeOS"

#elif defined(__QNX__) || defined(__QNXNTO__)
# define PLATFORM_ID "QNX"

#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)
# define PLATFORM_ID "Tru64"

#elif defined(__riscos) || defined(__riscos__)
# define PLATFORM_ID "RISCos"

#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)
# define PLATFORM_ID "SINIX"

#elif defined(__UNIX_SV__)
# define PLATFORM_ID "UNIX_SV"

#elif defined(__bsdos__)
# define PLATFORM_ID "BSDOS"

#elif defined(_MPRAS) || defined(MPRAS)
# define PLATFORM_ID "MP-RAS"

#elif defined(__osf) || defined(__osf__)
# define PLATFORM_ID "OSF1"

#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)
# define PLATFORM_ID "SCO_SV"

#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)
# define PLATFORM_ID "ULTRIX"

#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)
# define PLATFORM_ID "Xenix"

#elif defined(__WATCOMC__)
# if defined(__LINUX__)
#  define PLATFORM_ID "Linux"

# elif defined(__DOS__)
#  define PLATFORM_ID "DOS"

# elif defined(__OS2__)
#  define PLATFORM_ID "OS2"

# elif defined(__WINDOWS__)
#  define PLATFORM_ID "Windows3x"

# elif defined(__VXWORKS__)
#  define PLATFORM_ID "VxWorks"

# else /* unknown platform */
#  define PLATFORM_ID
# endif

#elif defined(__INTEGRITY)
# if defined(INT_178B)
#  define PLATFORM_ID "Integrity178"

# else /* regular Integrity */
#  define PLATFORM_ID "Integrity"
# endif

# elif defined(_ADI_COMPILER)
#  define PLATFORM_ID "ADSP"

#else /* unknown platform */
# define PLATFORM_ID

#endif

/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is because
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
*/
#if defined(_WIN32) && defined(_MSC_VER)
# if defined(_M_IA64)
#  define ARCHITECTURE_ID "IA64"

# elif defined(_M_ARM64EC)
#  define ARCHITECTURE_ID "ARM64EC"

# elif defined(_M_X64) || defined(_M_AMD64)
#  define ARCHITECTURE_ID "x64"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# elif defined(_M_ARM64)
#  define ARCHITECTURE_ID "ARM64"

# elif defined(_M_ARM)
#  if _M_ARM == 4
#   define ARCHITECTURE_ID "ARMV4I"
#  elif _M_ARM == 5
#   define ARCHITECTURE_ID "ARMV5I"
#  else
#   define ARCHITECTURE_ID "ARMV" STRINGIFY(_M_ARM)
#  endif

# elif defined(_M_MIPS)
#  define ARCHITECTURE_ID "MIPS"

# elif defined(_M_SH)
#  define ARCHITECTURE_ID "SHx"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__WATCOMC__)
# if defined(_M_I86)
#  define ARCHITECTURE_ID "I86"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# if defined(__ICCARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__ICCRX__)
#  define ARCHITECTURE_ID "RX"

# elif defined(__ICCRH850__)
#  define ARCHITECTURE_ID "RH850"

# elif defined(__ICCRL78__)
#  define ARCHITECTURE_ID "RL78"

# elif defined(__ICCRISCV__)
#  define ARCHITECTURE_ID "RISCV"

# elif defined(__ICCAVR__)
#  define ARCHITECTURE_ID "AVR"

# elif defined(__ICC430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__ICCV850__)
#  define ARCHITECTURE_ID "V850"

# elif defined(__ICC8051__)
#  define ARCHITECTURE_ID "8051"

# elif defined(__ICCSTM8__)
#  define ARCHITECTURE_ID "STM8"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__ghs__)
# if defined(__PPC64__)
#  define ARCHITECTURE_ID "PPC64"

# elif defined(__ppc__)
#  define ARCHITECTURE_ID "PPC"

# elif defined(__ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__x86_64__)
#  define ARCHITECTURE_ID "x64"

# elif defined(__i386__)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__TI_COMPILER_VERSION__)
# if defined(__TI_ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__MSP430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__TMS320C28XX__)
#  define ARCHITECTURE_ID "TMS320C28x"

# elif defined(__TMS320C6X__) || defined(_TMS320C6X)
#  define ARCHITECTURE_ID "TMS320C6x"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

# elif defined(__ADSPSHARC__)
#  define ARCHITECTURE_ID "SHARC"

# elif defined(__ADSPBLACKFIN__)
#  define ARCHITECTURE_ID "Blackfin"

#elif defined(__TASKING__)

# if defined(__CTC__) || defined(__CPTC__)
#  define ARCHITECTURE_ID "TriCore"

# elif defined(__CMCS__)
#  define ARCHITECTURE_ID "MCS"

# elif defined(__CARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__CARC__)
#  define ARCHITECTURE_ID "ARC"

# elif defined(__C51__)
#  define ARCHITECTURE_ID "8051"

# elif defined(__CPCP__)
#  define ARCHITECTURE_ID "PCP"

# else
#  define ARCHITECTURE_ID ""
# endif

#else
#  define ARCHITECTURE_ID
#endif

/* Convert integer to decimal digit literals.  */
#define DEC(n)                   \
  ('0' + (((n) / 10000000)%10)), \
  ('0' + (((n) / 1000000)%10)),  \
  ('0' + (((n) / 100000)%10)),   \
  ('0' + (((n) / 10000)%10)),    \
  ('0' + (((n) / 1000)%10)),     \
  ('0' + (((n) / 100)%10)),      \
  ('0' + (((n) / 10)%10)),       \
  ('0' +  ((n) % 10))

/* Convert integer to hex digit literals.  */
#define HEX(n)             \
  ('0' + ((n)>>28 & 0xF)), \
  ('0' + ((n)>>24 & 0xF)), \
  ('0' + ((n)>>20 & 0xF)), \
  ('0' + ((n)>>16 & 0xF)), \
  ('0' + ((n)>>12 & 0xF)), \
  ('0' + ((n)>>8  & 0xF)), \
  ('0' + ((n)>>4  & 0xF)), \
  ('0' + ((n)     & 0xF))

/* Construct a string literal encoding the version number. */
#ifdef COMPILER_VERSION
char const* info_version = "INFO" ":" "compiler_version[" COMPILER_VERSION "]";

/* Construct a string literal encoding the version number components. */
#elif defined(COMPILER_VERSION_MAJOR)
char const info_version[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',
  COMPILER_VERSION_MAJOR,
# ifdef COMPILER_VERSION_MINOR
  '.', COMPILER_VERSION_MINOR,
#  ifdef COMPILER_VERSION_PATCH
   '.', COMPILER_VERSION_PATCH,
#   ifdef COMPILER_VERSION_TWEAK
    '.', COMPILER_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct a string literal encoding the internal version number. */
#ifdef COMPILER_VERSION_INTERNAL
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
#elif defined(COMPILER_VERSION_INTERNAL_STR)
char const* info_version_internal = "INFO" ":" "compiler_version_internal[" COMPILER_VERSION_INTERNAL_STR "]";
#endif

/* Construct a string literal encoding the version number components. */
#ifdef SIMULATE_VERSION_MAJOR
char const info_simulate_version[] = {
  'I', 'N', 'F', 'O', ':',
  's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',
  SIMULATE_VERSION_MAJOR,
# ifdef SIMULATE_VERSION_MINOR
  '.', SIMULATE_VERSION_MINOR,
#  ifdef SIMULATE_VERSION_PATCH
   '.', SIMULATE_VERSION_PATCH,
#   ifdef SIMULATE_VERSION_TWEAK
    '.', SIMULATE_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";
char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";



#if defined(__INTEL_COMPILER) && defined(_MSVC_LANG) && _MSVC_LANG < 201403L
#  if defined(__INTEL_CXX11_MODE__)
#    if defined(__cpp_aggregate_nsdmi)
#      define CXX_STD 201402L
#    else
#      define CXX_STD 201103L
#    endif
#  else
#    define CXX_STD 199711L
#  endif
#elif defined(_MSC_VER) && defined(_MSVC_LANG)
#  define CXX_STD _MSVC_LANG
#else
#  define CXX_STD __cplusplus
#endif

const char* info_language_standard_default = "INFO" ":" "standard_default["
#if CXX_STD > 202002L
  "23"
#elif CXX_STD > 201703L
  "20"
#elif CXX_STD >= 201703L
  "17"
#elif CXX_STD >= 201402L
  "14"
#elif CXX_STD >= 201103L
  "11"
#else
  "98"
#endif
"]";

const char* info_language_extensions_default = "INFO" ":" "extensions_default["
#if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) ||           \
     defined(__TI_COMPILER_VERSION__)) &&                                     \
  !defined(__STRICT_ANSI__)
  "ON"
#else
  "OFF"
#endif
"]";

/*--------------------------------------------------------------------------*/

int main(int argc, char* argv[])
{
  int require = 0;
  require += info_compiler[argc];
  require += info_platform[argc];
  require += info_arch[argc];
#ifdef COMPILER_VERSION_MAJOR
  require += info_version[argc];
#endif
#ifdef COMPILER_VERSION_INTERNAL
  require += info_version_internal[argc];
#endif
#ifdef SIMULATE_ID
  require += info_simulate[argc];
#endif
#ifdef SIMULATE_VERSION_MAJOR
  require += info_simulate_version[argc];
#endif
#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
  require += info_cray[argc];
#endif
  require += info_language_standard_default[argc];
  require += info_language_extensions_default[argc];
  (void)argv;
  return require;
}


=== kursach/src/utils/ImageUtils.cpp ===
#include "ImageUtils.h"
#include <QPainter>
#include <QPainterPath>
#include <QGraphicsBlurEffect>
#include <QGraphicsScene>
#include <QGraphicsPixmapItem>

QPixmap ImageUtils::loadImage(const QString& path, int width, int height)
{
    QPixmap pixmap(path);
    
    if (pixmap.isNull()) {
        return QPixmap();
    }
    
    if (width > 0 && height > 0) {
        return pixmap.scaled(width, height, Qt::KeepAspectRatio, Qt::SmoothTransformation);
    } else if (width > 0) {
        return pixmap.scaledToWidth(width, Qt::SmoothTransformation);
    } else if (height > 0) {
        return pixmap.scaledToHeight(height, Qt::SmoothTransformation);
    }
    
    return pixmap;
}

QPixmap ImageUtils::createCircularImage(const QPixmap& source)
{
    int size = qMin(source.width(), source.height());
    QPixmap result(size, size);
    result.fill(Qt::transparent);
    
    QPainter painter(&result);
    painter.setRenderHint(QPainter::Antialiasing);
    
    QPainterPath path;
    path.addEllipse(0, 0, size, size);
    painter.setClipPath(path);
    
    QPixmap scaled = source.scaled(size, size, Qt::KeepAspectRatioByExpanding, Qt::SmoothTransformation);
    painter.drawPixmap(0, 0, scaled);
    
    return result;
}

QPixmap ImageUtils::createRoundedImage(const QPixmap& source, int radius)
{
    QPixmap result(source.size());
    result.fill(Qt::transparent);
    
    QPainter painter(&result);
    painter.setRenderHint(QPainter::Antialiasing);
    
    QPainterPath path;
    path.addRoundedRect(0, 0, source.width(), source.height(), radius, radius);
    painter.setClipPath(path);
    
    painter.drawPixmap(0, 0, source);
    
    return result;
}

QPixmap ImageUtils::applyBlur(const QPixmap& source, int radius)
{
    QGraphicsScene scene;
    QGraphicsPixmapItem item;
    item.setPixmap(source);
    
    QGraphicsBlurEffect* blur = new QGraphicsBlurEffect;
    blur->setBlurRadius(radius);
    item.setGraphicsEffect(blur);
    
    scene.addItem(&item);
    
    QPixmap result(source.size());
    result.fill(Qt::transparent);
    
    QPainter painter(&result);
    scene.render(&painter);
    
    return result;
}

QPixmap ImageUtils::createThumbnail(const QPixmap& source, int size)
{
    return source.scaled(size, size, Qt::KeepAspectRatio, Qt::SmoothTransformation);
}

bool ImageUtils::saveImage(const QPixmap& pixmap, const QString& path, const QString& format)
{
    return pixmap.save(path, format.toUtf8().constData());
}

QPixmap ImageUtils::resizeImage(const QPixmap& source, int width, int height, Qt::AspectRatioMode mode)
{
    return source.scaled(width, height, mode, Qt::SmoothTransformation);
}

QPixmap ImageUtils::createGradientBackground(int width, int height, const QColor& color1, const QColor& color2)
{
    QPixmap pixmap(width, height);
    
    QPainter painter(&pixmap);
    QLinearGradient gradient(0, 0, 0, height);
    gradient.setColorAt(0, color1);
    gradient.setColorAt(1, color2);
    
    painter.fillRect(0, 0, width, height, gradient);
    
    return pixmap;
}

QPixmap ImageUtils::overlayImages(const QPixmap& background, const QPixmap& foreground, int x, int y)
{
    QPixmap result = background.copy();
    
    QPainter painter(&result);
    painter.drawPixmap(x, y, foreground);
    
    return result;
}

QString ImageUtils::extractDominantColor(const QPixmap& pixmap)
{
    QImage image = pixmap.toImage().scaled(50, 50, Qt::IgnoreAspectRatio, Qt::FastTransformation);
    
    int r = 0, g = 0, b = 0;
    int pixelCount = 0;
    
    for (int y = 0; y < image.height(); ++y) {
        for (int x = 0; x < image.width(); ++x) {
            QRgb pixel = image.pixel(x, y);
            r += qRed(pixel);
            g += qGreen(pixel);
            b += qBlue(pixel);
            pixelCount++;
        }
    }
    
    r /= pixelCount;
    g /= pixelCount;
    b /= pixelCount;
    
    return QString("#%1%2%3")
        .arg(r, 2, 16, QChar('0'))
        .arg(g, 2, 16, QChar('0'))
        .arg(b, 2, 16, QChar('0'));
}

QImage ImageUtils::convertToGrayscale(const QImage& image)
{
    QImage result = image.convertToFormat(QImage::Format_Grayscale8);
    return result;
}


=== kursach/src/utils/ImageUtils.h ===
#ifndef IMAGEUTILS_H
#define IMAGEUTILS_H

#include <QPixmap>
#include <QImage>
#include <QString>

class ImageUtils
{
public:
    static QPixmap loadImage(const QString& path, int width = 0, int height = 0);
    static QPixmap createCircularImage(const QPixmap& source);
    static QPixmap createRoundedImage(const QPixmap& source, int radius);
    static QPixmap applyBlur(const QPixmap& source, int radius);
    static QPixmap createThumbnail(const QPixmap& source, int size);
    
    static bool saveImage(const QPixmap& pixmap, const QString& path, const QString& format = "PNG");
    static QPixmap resizeImage(const QPixmap& source, int width, int height, Qt::AspectRatioMode mode = Qt::KeepAspectRatio);
    
    static QPixmap createGradientBackground(int width, int height, const QColor& color1, const QColor& color2);
    static QPixmap overlayImages(const QPixmap& background, const QPixmap& foreground, int x, int y);
    
    static QString extractDominantColor(const QPixmap& pixmap);
    static QImage convertToGrayscale(const QImage& image);
};

#endif


=== kursach/src/utils/Config.h ===
#ifndef CONFIG_H
#define CONFIG_H

#include <QString>
#include <QSettings>

class Config
{
public:
    static Config& instance();

    QString getDatabaseHost() const;
    int getDatabasePort() const;
    QString getDatabaseName() const;
    QString getDatabaseUser() const;
    QString getDatabasePassword() const;

    QString getWebSocketUrl() const;

    QString getLastFmApiKey() const;
    QString getLastFmSharedSecret() const;
    QString getLastFmSessionKey() const;
    void setLastFmSessionKey(const QString& key);

    QString getYandexClientId() const;
    QString getYandexClientSecret() const;
    QString getYandexRedirectUri() const;
    QString getYandexAccessToken() const;
    void setYandexAccessToken(const QString& token);

    int getMaxCacheSize() const;
    QString getCachePath() const;
    QString getAvatarsPath() const;

    bool getAutoLogin() const;
    void setAutoLogin(bool enabled);

    QString getLastUsername() const;
    void setLastUsername(const QString& username);

    int getDefaultVolume() const;
    void setDefaultVolume(int volume);

private:
    Config();
    ~Config();
    Config(const Config&) = delete;
    Config& operator=(const Config&) = delete;

    QSettings* m_settings;
};

#endif


=== kursach/src/utils/Config.cpp ===
#include "Config.h"
#include <QDir>

Config& Config::instance()
{
    static Config instance;
    return instance;
}

Config::Config()
{
    QString configPath = QDir::homePath() + "/.chorus";
    QDir().mkpath(configPath);
    m_settings = new QSettings(configPath + "/config.ini", QSettings::IniFormat);
}

Config::~Config()
{
    delete m_settings;
}

QString Config::getDatabaseHost() const
{
    return m_settings->value("database/host", "turntable.proxy.rlwy.net").toString();
}

int Config::getDatabasePort() const
{
    return m_settings->value("database/port", 26533).toInt();
}

QString Config::getDatabaseName() const
{
    return m_settings->value("database/name", "railway").toString();
}

QString Config::getDatabaseUser() const
{
    return m_settings->value("database/user", "postgres").toString();
}

QString Config::getDatabasePassword() const
{
    return m_settings->value("database/password",
                             "__REMOVED__").toString();
}

QString Config::getWebSocketUrl() const
{
    return m_settings->value("network/websocket", "ws://localhost:8080").toString();
}

QString Config::getLastFmApiKey() const
{
    return m_settings->value("api/lastfm_key",
                             "__REMOVED__").toString();
}

QString Config::getLastFmSharedSecret() const
{
    return m_settings->value("api/lastfm_secret",
                             "__REMOVED__").toString();
}

QString Config::getLastFmSessionKey() const
{
    return m_settings->value("api/lastfm_session_key", "").toString();
}

void Config::setLastFmSessionKey(const QString& key)
{
    m_settings->setValue("api/lastfm_session_key", key);
    m_settings->sync();
}

QString Config::getYandexClientId() const
{
    return m_settings->value("api/yandex_client_id",
                             "__REMOVED__").toString();
}

QString Config::getYandexClientSecret() const
{
    return m_settings->value("api/yandex_client_secret",
                             "__REMOVED__").toString();
}

QString Config::getYandexRedirectUri() const
{
    return m_settings->value("api/yandex_redirect_uri",
                             "http://localhost:8080/callback").toString();
}

QString Config::getYandexAccessToken() const
{
    return m_settings->value("api/yandex_access_token", "").toString();
}

void Config::setYandexAccessToken(const QString& token)
{
    m_settings->setValue("api/yandex_access_token", token);
    m_settings->sync();
}

int Config::getMaxCacheSize() const
{
    return m_settings->value("cache/max_size", 1024).toInt();
}

QString Config::getCachePath() const
{
    QString path = m_settings->value("cache/path",
                                     QDir::homePath() + "/.chorus/cache").toString();
    QDir().mkpath(path);
    return path;
}

QString Config::getAvatarsPath() const
{
    QString path = m_settings->value("avatars/path",
                                     QDir::homePath() + "/.chorus/avatars").toString();
    QDir().mkpath(path);
    return path;
}

bool Config::getAutoLogin() const
{
    return m_settings->value("auth/auto_login", false).toBool();
}

void Config::setAutoLogin(bool enabled)
{
    m_settings->setValue("auth/auto_login", enabled);
    m_settings->sync();
}

QString Config::getLastUsername() const
{
    return m_settings->value("auth/last_username", "").toString();
}

void Config::setLastUsername(const QString& username)
{
    m_settings->setValue("auth/last_username", username);
    m_settings->sync();
}

int Config::getDefaultVolume() const
{
    return m_settings->value("audio/volume", 70).toInt();
}

void Config::setDefaultVolume(int volume)
{
    m_settings->setValue("audio/volume", volume);
    m_settings->sync();
}


=== kursach/src/utils/FileUtils.cpp ===
#include "FileUtils.h"
#include <QFile>
#include <QFileInfo>
#include <QDir>
#include <QDateTime>
#include <QTextStream>
#include <QDirIterator>

bool FileUtils::fileExists(const QString& path)
{
    return QFile::exists(path);
}

qint64 FileUtils::fileSize(const QString& path)
{
    QFileInfo info(path);
    return info.size();
}

QString FileUtils::fileExtension(const QString& path)
{
    QFileInfo info(path);
    return info.suffix();
}

QString FileUtils::fileName(const QString& path)
{
    QFileInfo info(path);
    return info.fileName();
}

QString FileUtils::fileBaseName(const QString& path)
{
    QFileInfo info(path);
    return info.baseName();
}

bool FileUtils::createDirectory(const QString& path)
{
    QDir dir;
    return dir.mkpath(path);
}

bool FileUtils::deleteFile(const QString& path)
{
    return QFile::remove(path);
}

bool FileUtils::copyFile(const QString& source, const QString& destination)
{
    if (fileExists(destination)) {
        QFile::remove(destination);
    }
    return QFile::copy(source, destination);
}

bool FileUtils::moveFile(const QString& source, const QString& destination)
{
    if (copyFile(source, destination)) {
        return deleteFile(source);
    }
    return false;
}

QStringList FileUtils::listFiles(const QString& directory, const QStringList& filters)
{
    QStringList files;
    QDir dir(directory);
    
    if (!dir.exists()) {
        return files;
    }
    
    QFileInfoList fileList;
    if (filters.isEmpty()) {
        fileList = dir.entryInfoList(QDir::Files | QDir::NoDotAndDotDot);
    } else {
        fileList = dir.entryInfoList(filters, QDir::Files | QDir::NoDotAndDotDot);
    }
    
    for (const QFileInfo& info : fileList) {
        files.append(info.absoluteFilePath());
    }
    
    return files;
}

QString FileUtils::readTextFile(const QString& path)
{
    QFile file(path);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        return QString();
    }
    
    QTextStream in(&file);
    QString content = in.readAll();
    file.close();
    
    return content;
}

bool FileUtils::writeTextFile(const QString& path, const QString& content)
{
    QFile file(path);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        return false;
    }
    
    QTextStream out(&file);
    out << content;
    file.close();
    
    return true;
}

QString FileUtils::generateUniqueFileName(const QString& baseName, const QString& extension)
{
    QString timestamp = QString::number(QDateTime::currentMSecsSinceEpoch());
    return QString("%1_%2.%3").arg(baseName, timestamp, extension);
}

QString FileUtils::sanitizeFileName(const QString& name)
{
    QString sanitized = name;
    sanitized.replace(QRegExp("[<>:\"/\\|?*]"), "_");
    return sanitized;
}

qint64 FileUtils::directorySize(const QString& path)
{
    qint64 totalSize = 0;
    QDirIterator it(path, QDir::Files, QDirIterator::Subdirectories);
    
    while (it.hasNext()) {
        it.next();
        totalSize += it.fileInfo().size();
    }
    
    return totalSize;
}

bool FileUtils::cleanDirectory(const QString& path)
{
    QDir dir(path);
    
    if (!dir.exists()) {
        return false;
    }
    
    bool success = true;
    QFileInfoList files = dir.entryInfoList(QDir::Files | QDir::NoDotAndDotDot);
    
    for (const QFileInfo& file : files) {
        if (!QFile::remove(file.absoluteFilePath())) {
            success = false;
        }
    }
    
    return success;
}


=== kursach/src/utils/FileUtils.h ===
#ifndef FILEUTILS_H
#define FILEUTILS_H

#include <QString>
#include <QStringList>

class FileUtils
{
public:
    static bool fileExists(const QString& path);
    static qint64 fileSize(const QString& path);
    static QString fileExtension(const QString& path);
    static QString fileName(const QString& path);
    static QString fileBaseName(const QString& path);
    
    static bool createDirectory(const QString& path);
    static bool deleteFile(const QString& path);
    static bool copyFile(const QString& source, const QString& destination);
    static bool moveFile(const QString& source, const QString& destination);
    
    static QStringList listFiles(const QString& directory, const QStringList& filters = QStringList());
    static QString readTextFile(const QString& path);
    static bool writeTextFile(const QString& path, const QString& content);
    
    static QString generateUniqueFileName(const QString& baseName, const QString& extension);
    static QString sanitizeFileName(const QString& name);
    
    static qint64 directorySize(const QString& path);
    static bool cleanDirectory(const QString& path);
};

#endif


=== kursach/src/core/models/Track.h ===
#ifndef TRACK_H
#define TRACK_H

#include <QString>
#include <QPixmap>
#include <QDateTime>

struct TrackData
{
    int id = -1;

    QString filePath;
    QString fileHash;

    QString title;
    QString artist;
    QString album;
    int duration = 0;
    int playCount = 0;
    QString addedAt;
    QString genre;
    int year = 0;
    int bitrate = 0;
    int sampleRate = 0;
    int position = 0;

    QString yandexId;
    QString streamUrl;
    QString previewUrl;

    QString lastFmUrl;
    QString mbid;

    QPixmap cover;
    QString lyrics;

    bool isFromCloud = false;
    QString source;
};

Q_DECLARE_METATYPE(TrackData)

#endif


=== kursach/src/core/models/Message.h ===
#ifndef MESSAGE_H
#define MESSAGE_H

#include <QString>
#include <QDateTime>

enum class MessageType {
    Text = 0,
    Image = 1,
    Audio = 2,
    TrackShare = 3
};

struct Message {
    int id;
    int senderId;
    int receiverId;
    QString senderUsername;
    QString senderAvatarPath;
    QString content;
    MessageType type;
    QDateTime timestamp;
    bool isRead;
    int sharedTrackId;
    QString trackTitle;
    QString trackArtist;
};

struct ChatPreview {
    int userId;
    QString username;
    QString avatarPath;
    QString lastMessage;
    QDateTime lastMessageTime;
    int unreadCount;
    bool isOnline;
};

#endif


=== kursach/src/core/models/Room.h ===
#ifndef ROOM_H
#define ROOM_H

#include <QString>
#include <QDateTime>
#include <QVector>

struct RoomMember {
    int userId;
    QString username;
    QString avatarPath;
    bool isHost;
    QDateTime joinedAt;
};

struct Room {
    int id;
    QString name;
    QString description;
    QString genre;
    int hostId;
    int currentTrackId;
    QString currentTrackTitle;
    QString currentTrackArtist;
    qint64 currentPosition;
    bool isPlaying;
    int maxMembers;
    QVector<RoomMember> members;
    QDateTime createdAt;
    bool isPrivate;
    QString password;
};

#endif


=== kursach/src/core/models/User.h ===
#ifndef USER_H
#define USER_H

#include <QString>
#include <QDateTime>

enum class UserStatus {
    Online = 0,
    Away = 1,
    DoNotDisturb = 2,
    Invisible = 3,
    Offline = 4
};

struct User {
    int id;
    QString username;
    QString email;
    QString avatarPath;
    UserStatus status;
    QDateTime lastSeen;
    QString bio;
    QDateTime createdAt;
    bool isFriend;
    bool friendRequestSent;
    bool friendRequestReceived;
};

#endif


=== kursach/src/core/models/Playlist.h ===
#ifndef PLAYLIST_H
#define PLAYLIST_H

#include <QString>

struct Playlist {
    int id = -1;
    int userId = -1;
    QString name;
    QString createdAt;
};

#endif


=== kursach/src/core/managers/TrackManager.cpp ===
#include "TrackManager.h"
#include "database/DatabaseManager.h"

TrackManager::TrackManager(int userId, QObject *parent)
    : QObject(parent), m_userId(userId)
{
}

QVector<TrackData> TrackManager::getUserTracks()
{
    QList<TrackData> list = DatabaseManager::instance().getUserTracks(m_userId);
    return QVector<TrackData>(list.begin(), list.end());
}

TrackData TrackManager::getTrack(int trackId)
{
    TrackData track;
    track.id = trackId;
    return track;
}

bool TrackManager::deleteTrack(int trackId)
{
    return DatabaseManager::instance().deleteTrack(trackId);
}


=== kursach/src/core/managers/PlaylistManager.cpp ===
#include "PlaylistManager.h"
#include "database/DatabaseManager.h"

PlaylistManager::PlaylistManager(int userId, QObject *parent)
    : QObject(parent), m_userId(userId)
{
}

QVector<Playlist> PlaylistManager::getUserPlaylists()
{
    return QVector<Playlist>();
}

Playlist PlaylistManager::getPlaylist(int playlistId)
{
    Playlist playlist;
    playlist.id = playlistId;
    return playlist;
}

int PlaylistManager::createPlaylist(const QString& name, const QString& description)
{
    Q_UNUSED(description);
    Q_UNUSED(name);
    return -1;
}

QVector<TrackData> PlaylistManager::getPlaylistTracks(int playlistId)
{
    Q_UNUSED(playlistId);
    return QVector<TrackData>();
}

bool PlaylistManager::removeTrackFromPlaylist(int playlistId, int trackId)
{
    Q_UNUSED(playlistId);
    Q_UNUSED(trackId);
    return false;
}


=== kursach/src/core/managers/UserManager.h ===
#ifndef USERMANAGER_H
#define USERMANAGER_H

#include <QObject>
#include "core/models/User.h"

class UserManager : public QObject
{
    Q_OBJECT

public:
    explicit UserManager(QObject *parent = nullptr);
    
    bool updateStatus(int userId, UserStatus status);
    bool updateBio(int userId, const QString& bio);
    bool updateAvatar(int userId, const QString& avatarPath);
    bool updateEmail(int userId, const QString& email);
    
    User getUser(int userId);
    UserStatus getUserStatus(int userId);
    QString getUserAvatar(int userId);

signals:
    void userUpdated(int userId);
    void statusChanged(int userId, UserStatus status);

private:
};

#endif


=== kursach/src/core/managers/PlaylistManager.h ===
#ifndef PLAYLISTMANAGER_H
#define PLAYLISTMANAGER_H

#include <QObject>
#include <QVector>
#include "core/models/Playlist.h"
#include "core/models/Track.h"

class PlaylistManager : public QObject
{
    Q_OBJECT

public:
    explicit PlaylistManager(int userId, QObject *parent = nullptr);
    
    int createPlaylist(const QString& name, const QString& description = QString());
    bool deletePlaylist(int playlistId);
    bool renamePlaylist(int playlistId, const QString& newName);
    bool addTrackToPlaylist(int playlistId, int trackId);
    bool removeTrackFromPlaylist(int playlistId, int trackId);
    bool reorderTracks(int playlistId, const QVector<int>& trackIds);
    
    QVector<Playlist> getUserPlaylists();
    QVector<TrackData> getPlaylistTracks(int playlistId);
    Playlist getPlaylist(int playlistId);

signals:
    void playlistCreated(int playlistId);
    void playlistDeleted(int playlistId);
    void playlistUpdated(int playlistId);
    void trackAdded(int playlistId, int trackId);
    void trackRemoved(int playlistId, int trackId);

private:
    int m_userId;
};

#endif


=== kursach/src/core/managers/TrackManager.h ===
#ifndef TRACKMANAGER_H
#define TRACKMANAGER_H

#include <QObject>
#include <QVector>
#include "core/models/Track.h"

class TrackManager : public QObject
{
    Q_OBJECT

public:
    explicit TrackManager(int userId, QObject *parent = nullptr);
    
    bool addTrack(const TrackData& track);
    bool deleteTrack(int trackId);
    bool updateTrack(int trackId, const TrackData& track);
    bool incrementPlayCount(int trackId);
    
    QVector<TrackData> getUserTracks();
    TrackData getTrack(int trackId);
    QVector<TrackData> searchTracks(const QString& query);
    QVector<TrackData> getRecentTracks(int limit = 20);
    QVector<TrackData> getMostPlayedTracks(int limit = 20);

signals:
    void trackAdded(int trackId);
    void trackDeleted(int trackId);
    void trackUpdated(int trackId);

private:
    int m_userId;
};

#endif


=== kursach/src/core/managers/UserManager.cpp ===
#include "UserManager.h"

UserManager::UserManager(QObject *parent)
    : QObject(parent)
{
}

User UserManager::getUser(int userId)
{
    User user;
    user.id = userId;
    user.username = "User";
    user.status = UserStatus::Offline;
    return user;
}

bool UserManager::updateAvatar(int userId, const QString& avatarPath)
{
    Q_UNUSED(userId);
    Q_UNUSED(avatarPath);
    return true;
}

bool UserManager::updateEmail(int userId, const QString& email)
{
    Q_UNUSED(userId);
    Q_UNUSED(email);
    return true;
}

bool UserManager::updateBio(int userId, const QString& bio)
{
    Q_UNUSED(userId);
    Q_UNUSED(bio);
    return true;
}


=== kursach/src/gui/widgets/Sidebar.h ===
#ifndef SIDEBAR_H
#define SIDEBAR_H

#include <QWidget>
#include <QPushButton>
#include <QVBoxLayout>
#include <QLabel>

class Sidebar : public QWidget
{
    Q_OBJECT

public:
    explicit Sidebar(const QString& username, QWidget *parent = nullptr);
    
    void setActivePage(int index);

signals:
    void pageChanged(int index);
    void logoutRequested();

private:
    void setupUI();
    void createNavButton(const QString& icon, const QString& text, int index);
    
    QString m_username;
    QVBoxLayout* m_navLayout;
    QVector<QPushButton*> m_navButtons;
    int m_currentPage;
};

#endif


=== kursach/src/gui/widgets/UserAvatar.h ===
#ifndef USERAVATAR_H
#define USERAVATAR_H

#include <QWidget>
#include <QPixmap>
#include "core/models/User.h"

class UserAvatar : public QWidget
{
    Q_OBJECT

public:
    explicit UserAvatar(int size = 40, QWidget *parent = nullptr);
    
    void setUser(const User& user);
    void setAvatar(const QString& avatarPath);
    void setStatus(UserStatus status);
    void setInitials(const QString& initials);

protected:
    void paintEvent(QPaintEvent *event) override;

private:
    int m_size;
    QPixmap m_avatar;
    QString m_initials;
    UserStatus m_status;
    bool m_hasAvatar;
};

#endif


=== kursach/src/gui/widgets/Sidebar.cpp ===
#include "Sidebar.h"
#include <QLabel>

Sidebar::Sidebar(const QString& username, QWidget *parent)
    : QWidget(parent)
    , m_username(username)
    , m_currentPage(0)
{
    setupUI();
}

void Sidebar::setupUI()
{
    setFixedWidth(250);
    setStyleSheet(R"(
        QWidget {
            background: rgba(0, 0, 0, 0.4);
            border-right: 1px solid rgba(255, 255, 255, 0.05);
        }
    )");
    
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);
    
    QWidget* headerWidget = new QWidget();
    headerWidget->setFixedHeight(80);
    QVBoxLayout* headerLayout = new QVBoxLayout(headerWidget);
    headerLayout->setContentsMargins(20, 20, 20, 20);
    
    QLabel* logoLabel = new QLabel("SoundSpace");
    logoLabel->setStyleSheet("color: #8A2BE2; font-size: 24px; font-weight: 800;");
    
    QLabel* usernameLabel = new QLabel(m_username);
    usernameLabel->setStyleSheet("color: rgba(255, 255, 255, 0.7); font-size: 13px;");
    
    headerLayout->addWidget(logoLabel);
    headerLayout->addWidget(usernameLabel);
    
    mainLayout->addWidget(headerWidget);
    
    QWidget* navWidget = new QWidget();
    m_navLayout = new QVBoxLayout(navWidget);
    m_navLayout->setContentsMargins(15, 20, 15, 20);
    m_navLayout->setSpacing(8);
    
    createNavButton("", "", 0);
    createNavButton("", " ", 1);
    createNavButton("", " ", 2);
    createNavButton("", "", 3);
    createNavButton("", "", 4);
    createNavButton("", "", 5);
    createNavButton("", "", 6);
    createNavButton("", "", 7);
    
    mainLayout->addWidget(navWidget);
    mainLayout->addStretch();
    
    QWidget* footerWidget = new QWidget();
    QVBoxLayout* footerLayout = new QVBoxLayout(footerWidget);
    footerLayout->setContentsMargins(15, 20, 15, 20);
    
    QPushButton* logoutBtn = new QPushButton(" ");
    logoutBtn->setStyleSheet(R"(
        QPushButton {
            background: rgba(255, 68, 68, 0.1);
            border: 1px solid rgba(255, 68, 68, 0.3);
            color: #FF4444;
            padding: 12px;
            border-radius: 10px;
            text-align: left;
            font-size: 14px;
            font-weight: 500;
        }
        QPushButton:hover {
            background: rgba(255, 68, 68, 0.2);
        }
    )");
    
    connect(logoutBtn, &QPushButton::clicked, this, &Sidebar::logoutRequested);
    
    footerLayout->addWidget(logoutBtn);
    mainLayout->addWidget(footerWidget);
    
    if (!m_navButtons.isEmpty()) {
        m_navButtons[0]->setChecked(true);
    }
}

void Sidebar::createNavButton(const QString& icon, const QString& text, int index)
{
    QPushButton* btn = new QPushButton(QString("%1  %2").arg(icon, text));
    btn->setCheckable(true);
    btn->setFixedHeight(50);
    btn->setStyleSheet(R"(
        QPushButton {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            text-align: left;
            font-size: 14px;
            font-weight: 500;
        }
        QPushButton:hover {
            background: rgba(255, 255, 255, 0.05);
            color: white;
        }
        QPushButton:checked {
            background: rgba(138, 43, 226, 0.2);
            color: #8A2BE2;
            font-weight: 600;
        }
    )");
    
    connect(btn, &QPushButton::clicked, [this, index]() {
        for (QPushButton* button : m_navButtons) {
            button->setChecked(false);
        }
        m_navButtons[index]->setChecked(true);
        m_currentPage = index;
        emit pageChanged(index);
    });
    
    m_navButtons.append(btn);
    m_navLayout->addWidget(btn);
}

void Sidebar::setActivePage(int index)
{
    if (index >= 0 && index < m_navButtons.size()) {
        for (QPushButton* button : m_navButtons) {
            button->setChecked(false);
        }
        m_navButtons[index]->setChecked(true);
        m_currentPage = index;
    }
}


=== kursach/src/gui/widgets/RoomCard.h ===
#ifndef ROOMCARD_H
#define ROOMCARD_H

#include <QWidget>
#include <QLabel>
#include <QPushButton>
#include "core/models/Room.h"

class RoomCard : public QWidget
{
    Q_OBJECT

public:
    explicit RoomCard(const Room& room, QWidget *parent = nullptr);

signals:
    void joinClicked(int roomId);

private:
    void setupUI(const Room& room);
    
    int m_roomId;
    QLabel* m_nameLabel;
    QLabel* m_genreLabel;
    QLabel* m_trackLabel;
    QLabel* m_membersLabel;
    QPushButton* m_joinButton;
};

#endif


=== kursach/src/gui/widgets/MessageBubble.cpp ===
#include "MessageBubble.h"
#include <QVBoxLayout>
#include <QHBoxLayout>

MessageBubble::MessageBubble(const Message& message, bool isOwn, QWidget *parent)
    : QWidget(parent)
{
    setupUI(message, isOwn);
}

void MessageBubble::setupUI(const Message& message, bool isOwn)
{
    QHBoxLayout* mainLayout = new QHBoxLayout(this);
    mainLayout->setContentsMargins(10, 5, 10, 5);
    
    if (isOwn) {
        mainLayout->addStretch();
    }
    
    QWidget* bubbleWidget = new QWidget();
    bubbleWidget->setMaximumWidth(400);
    
    QString bubbleStyle;
    if (isOwn) {
        bubbleStyle = "QWidget { background: #8A2BE2; border-radius: 15px; padding: 10px 15px; }";
    } else {
        bubbleStyle = "QWidget { background: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 10px 15px; }";
    }
    bubbleWidget->setStyleSheet(bubbleStyle);
    
    QVBoxLayout* bubbleLayout = new QVBoxLayout(bubbleWidget);
    bubbleLayout->setContentsMargins(5, 5, 5, 5);
    bubbleLayout->setSpacing(5);
    
    if (!isOwn) {
        QLabel* senderLabel = new QLabel(message.senderUsername);
        senderLabel->setStyleSheet("color: #8A2BE2; font-size: 12px; font-weight: 600;");
        bubbleLayout->addWidget(senderLabel);
    }
    
    QLabel* contentLabel = new QLabel(message.content);
    contentLabel->setWordWrap(true);
    contentLabel->setStyleSheet("color: white; font-size: 14px;");
    bubbleLayout->addWidget(contentLabel);
    
    QLabel* timeLabel = new QLabel(message.timestamp.toString("hh:mm"));
    timeLabel->setStyleSheet("color: rgba(255, 255, 255, 0.5); font-size: 11px;");
    timeLabel->setAlignment(isOwn ? Qt::AlignRight : Qt::AlignLeft);
    bubbleLayout->addWidget(timeLabel);
    
    mainLayout->addWidget(bubbleWidget);
    
    if (!isOwn) {
        mainLayout->addStretch();
    }
}


=== kursach/src/gui/widgets/TrackListItem.h ===
#ifndef TRACKLISTITEM_H
#define TRACKLISTITEM_H

#include <QWidget>
#include <QLabel>
#include <QPushButton>
#include "core/models/Track.h"

class TrackListItem : public QWidget
{
    Q_OBJECT

public:
    explicit TrackListItem(const TrackData& track, bool showAlbum = false, QWidget *parent = nullptr);
    
    int trackId() const { return m_trackId; }
    const TrackData& track() const { return m_track; }

signals:
    void playClicked(int trackId);
    void moreClicked(int trackId, const QPoint& pos);

private:
    void setupUI(bool showAlbum);
    QString formatDuration(int seconds);
    
    int m_trackId;
    TrackData m_track;
    
    QLabel* m_numberLabel;
    QLabel* m_titleLabel;
    QLabel* m_artistLabel;
    QLabel* m_albumLabel;
    QLabel* m_durationLabel;
    QPushButton* m_playButton;
    QPushButton* m_moreButton;
};

#endif


=== kursach/src/gui/widgets/FriendCard.cpp ===
#include "FriendCard.h"
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QFileInfo>
#include <QPainter>
#include <QPainterPath>

static QPixmap makeCircularPixmap(const QPixmap& src, int size)
{
    if (src.isNull()) return QPixmap();

    QPixmap scaled = src.scaled(size, size, Qt::KeepAspectRatioByExpanding, Qt::SmoothTransformation);
    QPixmap out(size, size);
    out.fill(Qt::transparent);

    QPainter p(&out);
    p.setRenderHint(QPainter::Antialiasing, true);
    p.setRenderHint(QPainter::SmoothPixmapTransform, true);

    QPainterPath path;
    path.addEllipse(0, 0, size, size);
    p.setClipPath(path);

    int x = (size - scaled.width()) / 2;
    int y = (size - scaled.height()) / 2;
    p.drawPixmap(x, y, scaled);

    return out;
}

FriendCard::FriendCard(const User& user, bool isRequest, bool isSearchResult, QWidget *parent)
    : QWidget(parent)
{
    setupUI(user, isRequest, isSearchResult);
}

void FriendCard::setupUI(const User& user, bool isRequest, bool isSearchResult)
{
    QHBoxLayout* mainLayout = new QHBoxLayout(this);
    mainLayout->setContentsMargins(15, 15, 15, 15);
    mainLayout->setSpacing(15);

    // Avatar
    m_avatarLabel = new QLabel();
    m_avatarLabel->setFixedSize(60, 60);
    m_avatarLabel->setAlignment(Qt::AlignCenter);

    bool avatarSet = false;
    const QString path = user.avatarPath.trimmed();
    if (!path.isEmpty() && QFileInfo::exists(path)) {
        QPixmap px(path);
        if (!px.isNull()) {
            m_avatarLabel->setPixmap(makeCircularPixmap(px, 60));
            avatarSet = true;
        }
    }

    if (!avatarSet) {
        // fallback: circle with first letter
        m_avatarLabel->setText(user.username.left(1).toUpper());
        m_avatarLabel->setStyleSheet(
            "background: #8A2BE2;"
            "color: white;"
            "font-size: 24px;"
            "font-weight: bold;"
            "border-radius: 30px;"
        );
    } else {
        // no background when pixmap is set
        m_avatarLabel->setStyleSheet("background: transparent;");
    }

    // Info
    QWidget* infoWidget = new QWidget();
    infoWidget->setStyleSheet("background: transparent;");
    QVBoxLayout* infoLayout = new QVBoxLayout(infoWidget);
    infoLayout->setContentsMargins(0, 0, 0, 0);
    infoLayout->setSpacing(4);

    m_usernameLabel = new QLabel(user.username);
    m_usernameLabel->setStyleSheet("color: white; font-size: 16px; font-weight: 600; background: transparent;");

    // If status enum exists in your model, keep it; otherwise just show empty
    m_statusLabel = new QLabel();
    m_statusLabel->setStyleSheet("color: rgba(255,255,255,0.6); font-size: 13px; background: transparent;");
    if (!getStatusText(user.status).isEmpty()) {
        m_statusLabel->setText(getStatusText(user.status));
        m_statusLabel->setStyleSheet(QString("color: %1; font-size: 13px; background: transparent;").arg(getStatusColor(user.status)));
    }

    infoLayout->addWidget(m_usernameLabel);
    infoLayout->addWidget(m_statusLabel);

    mainLayout->addWidget(m_avatarLabel);
    mainLayout->addWidget(infoWidget, 1);

    // Buttons
    if (isRequest) {
        QPushButton* acceptBtn = new QPushButton("");
        acceptBtn->setStyleSheet("QPushButton { background: #4CAF50; color: white; border: none; border-radius: 8px; padding: 8px 20px; font-weight: 600; } QPushButton:hover { background: #45a049; }");
        connect(acceptBtn, &QPushButton::clicked, this, &FriendCard::acceptClicked);

        QPushButton* rejectBtn = new QPushButton("");
        rejectBtn->setStyleSheet("QPushButton { background: #f44336; color: white; border: none; border-radius: 8px; padding: 8px 20px; font-weight: 600; } QPushButton:hover { background: #da190b; }");
        connect(rejectBtn, &QPushButton::clicked, this, &FriendCard::rejectClicked);

        mainLayout->addWidget(acceptBtn);
        mainLayout->addWidget(rejectBtn);
    } else if (isSearchResult) {
        QPushButton* addBtn = new QPushButton("");
        addBtn->setStyleSheet("QPushButton { background: #8A2BE2; color: white; border: none; border-radius: 8px; padding: 8px 20px; font-weight: 600; } QPushButton:hover { background: #9B4BFF; }");
        connect(addBtn, &QPushButton::clicked, this, &FriendCard::addFriendClicked);
        mainLayout->addWidget(addBtn);
    } else {
        QPushButton* messageBtn = new QPushButton("");
        messageBtn->setStyleSheet("QPushButton { background: #8A2BE2; color: white; border: none; border-radius: 8px; padding: 8px 20px; font-weight: 600; } QPushButton:hover { background: #9B4BFF; }");
        connect(messageBtn, &QPushButton::clicked, this, &FriendCard::messageClicked);

        QPushButton* removeBtn = new QPushButton("");
        removeBtn->setStyleSheet("QPushButton { background: rgba(244, 67, 54, 0.2); color: #f44336; border: 1px solid #f44336; border-radius: 8px; padding: 8px 20px; font-weight: 600; } QPushButton:hover { background: rgba(244, 67, 54, 0.3); }");
        connect(removeBtn, &QPushButton::clicked, this, &FriendCard::removeClicked);

        mainLayout->addWidget(messageBtn);
        mainLayout->addWidget(removeBtn);
    }
}

QString FriendCard::getStatusColor(UserStatus status)
{
    switch (status) {
        case UserStatus::Online: return "#4CAF50";
        case UserStatus::Away: return "#FFC107";
        case UserStatus::DoNotDisturb: return "#F44336";
        case UserStatus::Invisible:
        case UserStatus::Offline: return "#9E9E9E";
        default: return "rgba(255,255,255,0.6)";
    }
}

QString FriendCard::getStatusText(UserStatus status)
{
    switch (status) {
        case UserStatus::Online: return "";
        case UserStatus::Away: return "  ";
        case UserStatus::DoNotDisturb: return " ";
        case UserStatus::Invisible: return "";
        case UserStatus::Offline: return "  ";
        default: return "";
    }
}


=== kursach/src/gui/widgets/ChatWidget.cpp ===
#include "ChatWidget.h"
#include "MessageBubble.h"
#include "network/ChatManager.h"
#include <QScrollBar>
#include <QMessageBox>

ChatWidget::ChatWidget(int userId, int friendId, const QString& friendName, QWidget *parent)
    : QWidget(parent)
    , m_userId(userId)
    , m_friendId(friendId)
    , m_friendName(friendName)
    , m_chatManager(new ChatManager(userId, this))
{
    setupUI();
    loadMessages();
}

void ChatWidget::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);
    
    QWidget* headerWidget = new QWidget();
    headerWidget->setFixedHeight(70);
    headerWidget->setStyleSheet(R"(
        QWidget {
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
    )");
    
    QHBoxLayout* headerLayout = new QHBoxLayout(headerWidget);
    headerLayout->setContentsMargins(20, 0, 20, 0);
    
    QPushButton* backBtn = new QPushButton(" ");
    backBtn->setStyleSheet(R"(
        QPushButton {
            background: transparent;
            color: #8A2BE2;
            border: none;
            font-size: 14px;
            font-weight: 600;
            padding: 10px;
        }
        QPushButton:hover {
            color: #9B4BFF;
        }
    )");
    
    QLabel* nameLabel = new QLabel(m_friendName);
    nameLabel->setStyleSheet(R"(
        color: white;
        font-size: 18px;
        font-weight: 600;
    )");
    
    headerLayout->addWidget(backBtn);
    headerLayout->addWidget(nameLabel);
    headerLayout->addStretch();
    
    m_messagesArea = new QScrollArea();
    m_messagesArea->setWidgetResizable(true);
    m_messagesArea->setStyleSheet(R"(
        QScrollArea {
            background: transparent;
            border: none;
        }
    )");
    
    QWidget* messagesContent = new QWidget();
    m_messagesLayout = new QVBoxLayout(messagesContent);
    m_messagesLayout->setContentsMargins(20, 20, 20, 20);
    m_messagesLayout->setSpacing(10);
    m_messagesLayout->addStretch();
    m_messagesArea->setWidget(messagesContent);
    
    QWidget* inputWidget = new QWidget();
    inputWidget->setFixedHeight(80);
    inputWidget->setStyleSheet(R"(
        QWidget {
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
    )");
    
    QHBoxLayout* inputLayout = new QHBoxLayout(inputWidget);
    inputLayout->setContentsMargins(20, 15, 20, 15);
    inputLayout->setSpacing(15);
    
    m_messageInput = new QLineEdit();
    m_messageInput->setPlaceholderText(" ...");
    m_messageInput->setStyleSheet(R"(
        QLineEdit {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 0 20px;
            color: white;
            font-size: 14px;
        }
        QLineEdit:focus {
            border: 2px solid #8A2BE2;
        }
    )");
    
    QPushButton* sendBtn = new QPushButton("");
    sendBtn->setFixedWidth(120);
    sendBtn->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            padding: 12px;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");
    
    inputLayout->addWidget(m_messageInput);
    inputLayout->addWidget(sendBtn);
    
    mainLayout->addWidget(headerWidget);
    mainLayout->addWidget(m_messagesArea, 1);
    mainLayout->addWidget(inputWidget);
    
    connect(backBtn, &QPushButton::clicked, this, &ChatWidget::backClicked);
    connect(sendBtn, &QPushButton::clicked, this, &ChatWidget::onSendMessage);
    connect(m_messageInput, &QLineEdit::returnPressed, this, &ChatWidget::onSendMessage);
}

void ChatWidget::loadMessages()
{
    while (m_messagesLayout->count() > 1) {
        QLayoutItem* item = m_messagesLayout->takeAt(0);
        if (item->widget()) {
            item->widget()->deleteLater();
        }
        delete item;
    }
    
    QVector<Message> messages = m_chatManager->getMessages(m_friendId, 50);
    
    for (int i = messages.size() - 1; i >= 0; --i) {
        const Message& msg = messages[i];
        bool isOwn = (msg.senderId == m_userId);
        
        MessageBubble* bubble = new MessageBubble(msg, isOwn);
        m_messagesLayout->insertWidget(m_messagesLayout->count() - 1, bubble);
        
        if (!isOwn && !msg.isRead) {
            m_chatManager->markAsRead(msg.id);
        }
    }
    
    QTimer::singleShot(100, this, [this]() {
        m_messagesArea->verticalScrollBar()->setValue(
            m_messagesArea->verticalScrollBar()->maximum()
        );
    });
}

void ChatWidget::onSendMessage()
{
    QString text = m_messageInput->text().trimmed();
    
    if (text.isEmpty()) {
        return;
    }
    
    if (m_chatManager->sendMessage(m_friendId, text)) {
        m_messageInput->clear();
        loadMessages();
    } else {
        QMessageBox::warning(this, "", "   ");
    }
}


=== kursach/src/gui/widgets/ChatWidget.h ===
#ifndef CHATWIDGET_H
#define CHATWIDGET_H

#include <QWidget>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QScrollArea>
#include <QLineEdit>
#include <QPushButton>
#include <QLabel>
#include <QTimer>
#include "network/ChatManager.h"

class ChatWidget : public QWidget
{
    Q_OBJECT

public:
    explicit ChatWidget(int userId, int friendId, const QString& friendName, QWidget *parent = nullptr);

signals:
    void backClicked();

private slots:
    void onSendMessage();

private:
    void setupUI();
    void loadMessages();
    
    int m_userId;
    int m_friendId;
    QString m_friendName;
    ChatManager* m_chatManager;
    
    QScrollArea* m_messagesArea;
    QVBoxLayout* m_messagesLayout;
    QLineEdit* m_messageInput;
};

#endif


=== kursach/src/gui/widgets/FriendCard.h ===
#ifndef FRIENDCARD_H
#define FRIENDCARD_H

#include <QWidget>
#include <QLabel>
#include <QPushButton>
#include "core/models/User.h"

class FriendCard : public QWidget
{
    Q_OBJECT

public:
    explicit FriendCard(const User& user, bool isRequest, bool isSearchResult, QWidget *parent = nullptr);

signals:
    void acceptClicked();
    void rejectClicked();
    void removeClicked();
    void messageClicked();
    void addFriendClicked();

private:
    void setupUI(const User& user, bool isRequest, bool isSearchResult);
    QString getStatusColor(UserStatus status);
    QString getStatusText(UserStatus status);
    
    QLabel* m_avatarLabel;
    QLabel* m_usernameLabel;
    QLabel* m_statusLabel;
};

#endif



=== kursach/src/gui/widgets/TrackListItem.cpp ===
#include "TrackListItem.h"
#include <QHBoxLayout>
#include <QVBoxLayout>

TrackListItem::TrackListItem(const TrackData& track, bool showAlbum, QWidget *parent)
    : QWidget(parent)
    , m_trackId(track.id)
    , m_track(track)
{
    setupUI(showAlbum);
}

void TrackListItem::setupUI(bool showAlbum)
{
    setFixedHeight(65);
    setCursor(Qt::PointingHandCursor);
    
    QHBoxLayout* mainLayout = new QHBoxLayout(this);
    mainLayout->setContentsMargins(15, 8, 15, 8);
    mainLayout->setSpacing(15);
    
    m_numberLabel = new QLabel(QString::number(m_track.position + 1));
    m_numberLabel->setFixedWidth(40);
    m_numberLabel->setAlignment(Qt::AlignCenter);
    m_numberLabel->setStyleSheet("color: rgba(255, 255, 255, 0.5); font-size: 14px;");
    
    m_playButton = new QPushButton("");
    m_playButton->setFixedSize(35, 35);
    m_playButton->setStyleSheet(R"(
        QPushButton {
            background: rgba(138, 43, 226, 0.2);
            border: 1px solid #8A2BE2;
            color: #8A2BE2;
            border-radius: 17px;
            font-size: 12px;
        }
        QPushButton:hover {
            background: #8A2BE2;
            color: white;
        }
    )");
    m_playButton->hide();
    
    QWidget* infoWidget = new QWidget();
    QVBoxLayout* infoLayout = new QVBoxLayout(infoWidget);
    infoLayout->setContentsMargins(0, 0, 0, 0);
    infoLayout->setSpacing(3);
    
    m_titleLabel = new QLabel(m_track.title);
    m_titleLabel->setStyleSheet("color: white; font-size: 15px; font-weight: 600;");
    
    m_artistLabel = new QLabel(m_track.artist);
    m_artistLabel->setStyleSheet("color: rgba(255, 255, 255, 0.6); font-size: 13px;");
    
    infoLayout->addWidget(m_titleLabel);
    infoLayout->addWidget(m_artistLabel);
    
    if (showAlbum) {
        m_albumLabel = new QLabel(m_track.album);
        m_albumLabel->setStyleSheet("color: rgba(255, 255, 255, 0.5); font-size: 13px;");
        m_albumLabel->setFixedWidth(200);
    }
    
    m_durationLabel = new QLabel(formatDuration(m_track.duration));
    m_durationLabel->setStyleSheet("color: rgba(255, 255, 255, 0.5); font-size: 14px;");
    m_durationLabel->setFixedWidth(60);
    
    m_moreButton = new QPushButton("");
    m_moreButton->setFixedSize(30, 30);
    m_moreButton->setStyleSheet(R"(
        QPushButton {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            font-size: 18px;
            border-radius: 15px;
        }
        QPushButton:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
    )");
    
    mainLayout->addWidget(m_numberLabel);
    mainLayout->addWidget(m_playButton);
    mainLayout->addWidget(infoWidget, 1);
    
    if (showAlbum && m_albumLabel) {
        mainLayout->addWidget(m_albumLabel);
    }
    
    mainLayout->addWidget(m_durationLabel);
    mainLayout->addWidget(m_moreButton);
    
    connect(m_playButton, &QPushButton::clicked, [this]() {
        emit playClicked(m_trackId);
    });
    
    connect(m_moreButton, &QPushButton::clicked, [this]() {
        emit moreClicked(m_trackId, m_moreButton->mapToGlobal(m_moreButton->rect().bottomLeft()));
    });
    
    setStyleSheet(R"(
        TrackListItem {
            background: transparent;
            border-radius: 8px;
        }
        TrackListItem:hover {
            background: rgba(255, 255, 255, 0.05);
        }
    )");
}

QString TrackListItem::formatDuration(int seconds)
{
    int minutes = seconds / 60;
    int secs = seconds % 60;
    return QString("%1:%2").arg(minutes).arg(secs, 2, 10, QChar('0'));
}


=== kursach/src/gui/widgets/RoomCard.cpp ===
#include "RoomCard.h"
#include <QVBoxLayout>
#include <QHBoxLayout>

RoomCard::RoomCard(const Room& room, QWidget *parent)
    : QWidget(parent), m_roomId(room.id)
{
    setupUI(room);
}

void RoomCard::setupUI(const Room& room)
{
    setFixedHeight(180);
    setStyleSheet(R"(
        QWidget {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 12px;
        }
        QWidget:hover {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(138, 43, 226, 0.3);
        }
    )");
    
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(20, 15, 20, 15);
    mainLayout->setSpacing(12);
    
    QWidget* topRow = new QWidget();
    QHBoxLayout* topLayout = new QHBoxLayout(topRow);
    topLayout->setContentsMargins(0, 0, 0, 0);
    
    QLabel* iconLabel = new QLabel("");
    iconLabel->setStyleSheet("color: #8A2BE2; font-size: 18px;");
    
    m_nameLabel = new QLabel(room.name);
    m_nameLabel->setStyleSheet("color: white; font-size: 16px; font-weight: 600;");
    m_nameLabel->setWordWrap(true);
    
    m_membersLabel = new QLabel(QString("%1/%2").arg(room.members.size()).arg(room.maxMembers));
    m_membersLabel->setStyleSheet(R"(
        color: rgba(255, 255, 255, 0.7);
        font-size: 13px;
        background: rgba(255, 255, 255, 0.05);
        padding: 4px 10px;
        border-radius: 10px;
    )");
    
    topLayout->addWidget(iconLabel);
    topLayout->addWidget(m_nameLabel, 1);
    topLayout->addWidget(m_membersLabel);
    
    m_genreLabel = new QLabel(room.genre);
    m_genreLabel->setStyleSheet("color: #8A2BE2; font-size: 14px; font-weight: 500;");
    
    m_trackLabel = new QLabel(room.currentTrackTitle.isEmpty() ? 
        "  " : 
        QString("%1 - %2").arg(room.currentTrackArtist, room.currentTrackTitle));
    m_trackLabel->setStyleSheet("color: rgba(255, 255, 255, 0.7); font-size: 13px; font-style: italic;");
    m_trackLabel->setWordWrap(true);
    
    m_joinButton = new QPushButton("");
    m_joinButton->setFixedHeight(38);
    m_joinButton->setStyleSheet(R"(
        QPushButton {
            background: rgba(138, 43, 226, 0.2);
            border: 1px solid #8A2BE2;
            color: #8A2BE2;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: rgba(138, 43, 226, 0.3);
        }
    )");
    
    connect(m_joinButton, &QPushButton::clicked, [this]() {
        emit joinClicked(m_roomId);
    });
    
    mainLayout->addWidget(topRow);
    mainLayout->addWidget(m_genreLabel);
    mainLayout->addWidget(m_trackLabel, 1);
    mainLayout->addWidget(m_joinButton);
}


=== kursach/src/gui/widgets/UserAvatar.cpp ===
#include "UserAvatar.h"
#include <QPainter>
#include <QPainterPath>

UserAvatar::UserAvatar(int size, QWidget *parent)
    : QWidget(parent)
    , m_size(size)
    , m_status(UserStatus::Offline)
    , m_hasAvatar(false)
{
    setFixedSize(size, size);
}

void UserAvatar::setUser(const User& user)
{
    m_status = user.status;
    
    if (!user.avatarPath.isEmpty()) {
        setAvatar(user.avatarPath);
    } else {
        m_initials = user.username.left(1).toUpper();
        m_hasAvatar = false;
    }
    
    update();
}

void UserAvatar::setAvatar(const QString& avatarPath)
{
    QPixmap pixmap(avatarPath);
    if (!pixmap.isNull()) {
        m_avatar = pixmap.scaled(m_size, m_size, Qt::KeepAspectRatioByExpanding, Qt::SmoothTransformation);
        m_hasAvatar = true;
    } else {
        m_hasAvatar = false;
    }
    update();
}

void UserAvatar::setStatus(UserStatus status)
{
    m_status = status;
    update();
}

void UserAvatar::setInitials(const QString& initials)
{
    m_initials = initials;
    m_hasAvatar = false;
    update();
}

void UserAvatar::paintEvent(QPaintEvent *event)
{
    Q_UNUSED(event);
    
    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing);
    
    QPainterPath circlePath;
    circlePath.addEllipse(0, 0, m_size, m_size);
    painter.setClipPath(circlePath);
    
    if (m_hasAvatar) {
        painter.drawPixmap(0, 0, m_avatar);
    } else {
        QLinearGradient gradient(0, 0, m_size, m_size);
        gradient.setColorAt(0, QColor(138, 43, 226));
        gradient.setColorAt(1, QColor(155, 75, 255));
        painter.fillPath(circlePath, gradient);
        
        painter.setPen(Qt::white);
        QFont font = painter.font();
        font.setPointSize(m_size / 2.5);
        font.setBold(true);
        painter.setFont(font);
        painter.drawText(rect(), Qt::AlignCenter, m_initials);
    }
    
    painter.setClipping(false);
    
    if (m_status != UserStatus::Offline) {
        QColor statusColor;
        switch (m_status) {
            case UserStatus::Online: statusColor = QColor(76, 175, 80); break;
            case UserStatus::Away: statusColor = QColor(255, 193, 7); break;
            case UserStatus::DoNotDisturb: statusColor = QColor(244, 67, 54); break;
            default: statusColor = QColor(158, 158, 158); break;
        }
        
        int statusSize = m_size / 4;
        int statusX = m_size - statusSize - 2;
        int statusY = m_size - statusSize - 2;
        
        painter.setBrush(statusColor);
        painter.setPen(QPen(QColor(15, 15, 20), 2));
        painter.drawEllipse(statusX, statusY, statusSize, statusSize);
    }
}


=== kursach/src/gui/widgets/MessageBubble.h ===

#ifndef MESSAGEBUBBLE_H
#define MESSAGEBUBBLE_H

#include <QWidget>
#include <QLabel>
#include "core/models/Message.h"

class MessageBubble : public QWidget
{
    Q_OBJECT

public:
    explicit MessageBubble(const Message& message, bool isOwn, QWidget *parent = nullptr);

private:
    void setupUI(const Message& message, bool isOwn);
};

#endif


=== kursach/src/gui/MainWindow/pages/MessagesPage.cpp ===
#include "MessagesPage.h"
#include <QLabel>
#include <QPushButton>
#include <QScrollArea>

MessagesPage::MessagesPage(int userId, QWidget *parent)
    : QWidget(parent)
    , m_userId(userId)
    , m_chatManager(new ChatManager(userId, this))
    , m_currentChatWidget(nullptr)
{
    setupUI();
    loadChats();
}

void MessagesPage::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);
    
    m_stackedWidget = new QStackedWidget();
    
    m_chatListWidget = new QWidget();
    QVBoxLayout* listLayout = new QVBoxLayout(m_chatListWidget);
    listLayout->setContentsMargins(40, 40, 40, 40);
    listLayout->setSpacing(20);
    
    QLabel* titleLabel = new QLabel(" ");
    titleLabel->setStyleSheet(R"(
        color: white;
        font-size: 32px;
        font-weight: bold;
    )");
    
    m_chatList = new QListWidget();
    m_chatList->setStyleSheet(R"(
        QListWidget {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            color: white;
            font-size: 14px;
            outline: none;
            padding: 10px;
        }
        QListWidget::item {
            background: transparent;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin: 2px;
        }
        QListWidget::item:selected {
            background: rgba(138, 43, 226, 0.15);
            border: 1px solid rgba(138, 43, 226, 0.3);
        }
        QListWidget::item:hover {
            background: rgba(255, 255, 255, 0.05);
        }
    )");
    
    listLayout->addWidget(titleLabel);
    listLayout->addWidget(m_chatList);
    
    m_stackedWidget->addWidget(m_chatListWidget);
    
    mainLayout->addWidget(m_stackedWidget);
    
    connect(m_chatList, &QListWidget::itemClicked, this, &MessagesPage::onChatSelected);
}

void MessagesPage::loadChats()
{
    m_chatList->clear();
    
    QVector<ChatPreview> chats = m_chatManager->getChatList();
    
    if (chats.isEmpty()) {
        QListWidgetItem* item = new QListWidgetItem("  ");
        item->setFlags(item->flags() & ~Qt::ItemIsSelectable);
        m_chatList->addItem(item);
    } else {
        for (const ChatPreview& chat : chats) {
            QString itemText = QString("%1\n%2")
                .arg(chat.username)
                .arg(chat.lastMessage.left(50));
                
            QListWidgetItem* item = new QListWidgetItem(itemText);
            item->setData(Qt::UserRole, chat.userId);
            item->setData(Qt::UserRole + 1, chat.username);
            
            if (chat.unreadCount > 0) {
                QFont font = item->font();
                font.setBold(true);
                item->setFont(font);
                itemText += QString(" (%1)").arg(chat.unreadCount);
                item->setText(itemText);
            }
            
            m_chatList->addItem(item);
        }
    }
}

void MessagesPage::onChatSelected(QListWidgetItem* item)
{
    if (!item) return;
    
    int friendId = item->data(Qt::UserRole).toInt();
    QString friendName = item->data(Qt::UserRole + 1).toString();
    
    openChat(friendId, friendName);
}

void MessagesPage::openChat(int friendId, const QString& friendName)
{
    if (m_currentChatWidget) {
        m_stackedWidget->removeWidget(m_currentChatWidget);
        m_currentChatWidget->deleteLater();
    }
    
    m_currentChatWidget = new ChatWidget(m_userId, friendId, friendName);
    m_stackedWidget->addWidget(m_currentChatWidget);
    m_stackedWidget->setCurrentWidget(m_currentChatWidget);
    
    connect(m_currentChatWidget, &ChatWidget::backClicked, this, &MessagesPage::onBackToList);
}

void MessagesPage::onBackToList()
{
    m_stackedWidget->setCurrentWidget(m_chatListWidget);
    loadChats();
}

void MessagesPage::refreshChats()
{
    if (m_stackedWidget->currentWidget() == m_chatListWidget) {
        loadChats();
    }
}


=== kursach/src/gui/MainWindow/pages/FriendsPage.cpp ===
#include "FriendsPage.h"
#include "gui/widgets/FriendCard.h"
#include <QMessageBox>
#include <QScrollArea>
#include <QLabel>
#include <QDebug>

FriendsPage::FriendsPage(int userId, QWidget *parent)
    : QWidget(parent)
    , m_userId(userId)
    , m_friendManager(new FriendManager(userId, this))
{
    setupUI();
    loadFriends();
}

void FriendsPage::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(40, 40, 40, 40);
    mainLayout->setSpacing(25);
    
    QLabel* titleLabel = new QLabel(" ");
    titleLabel->setStyleSheet(R"(
        color: white;
        font-size: 32px;
        font-weight: bold;
    )");
    
    QWidget* searchWidget = new QWidget();
    searchWidget->setStyleSheet("background: transparent;");
    QHBoxLayout* searchLayout = new QHBoxLayout(searchWidget);
    searchLayout->setContentsMargins(0, 0, 0, 0);
    searchLayout->setSpacing(15);
    
    m_searchInput = new QLineEdit();
    m_searchInput->setPlaceholderText(" ...");
    m_searchInput->setMinimumHeight(50);
    m_searchInput->setStyleSheet(R"(
        QLineEdit {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 0 20px;
            color: white;
            font-size: 14px;
        }
        QLineEdit:focus {
            border: 2px solid #8A2BE2;
        }
    )");
    
    QPushButton* searchBtn = new QPushButton(" ");
    searchBtn->setMinimumHeight(50);
    searchBtn->setFixedWidth(120);
    searchBtn->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");
    
    searchLayout->addWidget(m_searchInput, 1);
    searchLayout->addWidget(searchBtn);
    
    QWidget* tabsWidget = new QWidget();
    tabsWidget->setStyleSheet("background: transparent;");
    QHBoxLayout* tabsLayout = new QHBoxLayout(tabsWidget);
    tabsLayout->setContentsMargins(0, 0, 0, 0);
    tabsLayout->setSpacing(10);
    
    m_friendsBtn = new QPushButton(" ");
    m_requestsBtn = new QPushButton("");
    
    QString tabStyle = R"(
        QPushButton {
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.7);
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        QPushButton:checked {
            background: #8A2BE2;
            color: white;
        }
    )";
    
    m_friendsBtn->setCheckable(true);
    m_friendsBtn->setChecked(true);
    m_friendsBtn->setStyleSheet(tabStyle);
    
    m_requestsBtn->setCheckable(true);
    m_requestsBtn->setStyleSheet(tabStyle);
    
    tabsLayout->addWidget(m_friendsBtn);
    tabsLayout->addWidget(m_requestsBtn);
    tabsLayout->addStretch();
    
    m_stackedWidget = new QStackedWidget();
    m_stackedWidget->setStyleSheet("background: transparent;");
    
    QWidget* friendsScroll = new QWidget();
    friendsScroll->setStyleSheet("background: transparent;");
    m_friendsLayout = new QVBoxLayout(friendsScroll);
    m_friendsLayout->setContentsMargins(0, 0, 0, 0);
    m_friendsLayout->setSpacing(15);
    
    QWidget* requestsScroll = new QWidget();
    requestsScroll->setStyleSheet("background: transparent;");
    m_requestsLayout = new QVBoxLayout(requestsScroll);
    m_requestsLayout->setContentsMargins(0, 0, 0, 0);
    m_requestsLayout->setSpacing(15);
    
    QWidget* searchScroll = new QWidget();
    searchScroll->setStyleSheet("background: transparent;");
    m_searchLayout = new QVBoxLayout(searchScroll);
    m_searchLayout->setContentsMargins(0, 0, 0, 0);
    m_searchLayout->setSpacing(15);
    
    m_friendsWidget = new QScrollArea();
    m_friendsWidget->setWidgetResizable(true);
    m_friendsWidget->setWidget(friendsScroll);
    m_friendsWidget->setStyleSheet("QScrollArea { background: transparent; border: none; } QWidget { background: transparent; }");
    
    m_requestsWidget = new QScrollArea();
    m_requestsWidget->setWidgetResizable(true);
    m_requestsWidget->setWidget(requestsScroll);
    m_requestsWidget->setStyleSheet("QScrollArea { background: transparent; border: none; } QWidget { background: transparent; }");
    
    m_searchWidget = new QScrollArea();
    m_searchWidget->setWidgetResizable(true);
    m_searchWidget->setWidget(searchScroll);
    m_searchWidget->setStyleSheet("QScrollArea { background: transparent; border: none; } QWidget { background: transparent; }");
    
    m_stackedWidget->addWidget(m_friendsWidget);
    m_stackedWidget->addWidget(m_requestsWidget);
    m_stackedWidget->addWidget(m_searchWidget);
    
    mainLayout->addWidget(titleLabel);
    mainLayout->addWidget(searchWidget);
    mainLayout->addWidget(tabsWidget);
    mainLayout->addWidget(m_stackedWidget, 1);
    
    connect(searchBtn, &QPushButton::clicked, this, &FriendsPage::onSearchClicked);
    connect(m_searchInput, &QLineEdit::returnPressed, this, &FriendsPage::onSearchClicked);
    connect(m_friendsBtn, &QPushButton::clicked, this, &FriendsPage::onShowFriends);
    connect(m_requestsBtn, &QPushButton::clicked, this, &FriendsPage::onShowRequests);
}

void FriendsPage::loadFriends()
{
    qDebug() << "=== Loading friends ===";
    
    while (m_friendsLayout->count() > 0) {
        QLayoutItem* item = m_friendsLayout->takeAt(0);
        if (item->widget()) {
            item->widget()->deleteLater();
        }
        delete item;
    }
    
    QVector<User> friends = m_friendManager->getFriends();
    qDebug() << "Found" << friends.size() << "friends";
    
    if (friends.isEmpty()) {
        QLabel* emptyLabel = new QLabel("     ");
        emptyLabel->setStyleSheet("color: rgba(255, 255, 255, 0.7); font-size: 16px; padding: 20px;");
        emptyLabel->setAlignment(Qt::AlignCenter);
        m_friendsLayout->addWidget(emptyLabel);
        qDebug() << "Added empty label";
    } else {
        for (const User& user : friends) {
            qDebug() << "Adding friend card for:" << user.username;
            FriendCard* card = new FriendCard(user, false, false);
            card->setFixedHeight(90);
            card->setStyleSheet(R"(
                FriendCard {
                    background: rgba(255, 255, 255, 0.03);
                    border: 1px solid rgba(255, 255, 255, 0.05);
                    border-radius: 12px;
                }
                FriendCard:hover {
                    background: rgba(255, 255, 255, 0.05);
                    border: 1px solid rgba(138, 43, 226, 0.3);
                }
            )");
            
            connect(card, &FriendCard::messageClicked, this, [this, user]() {
                onMessageFriend(user.id);
            });
            
            connect(card, &FriendCard::removeClicked, this, [this, user]() {
                onRemoveFriend(user.id);
            });
            
            m_friendsLayout->addWidget(card);
        }
    }
    
    m_friendsLayout->addStretch();
    qDebug() << "=== Friends loading complete ===";
}

void FriendsPage::loadRequests()
{
    qDebug() << "=== Loading requests ===";
    
    while (m_requestsLayout->count() > 0) {
        QLayoutItem* item = m_requestsLayout->takeAt(0);
        if (item->widget()) {
            item->widget()->deleteLater();
        }
        delete item;
    }
    
    QVector<User> requests = m_friendManager->getPendingRequests();
    qDebug() << "Found" << requests.size() << "requests";
    
    if (requests.isEmpty()) {
        QLabel* emptyLabel = new QLabel("    ");
        emptyLabel->setStyleSheet("color: rgba(255, 255, 255, 0.7); font-size: 16px; padding: 20px;");
        emptyLabel->setAlignment(Qt::AlignCenter);
        m_requestsLayout->addWidget(emptyLabel);
    } else {
        for (const User& user : requests) {
            FriendCard* card = new FriendCard(user, true, false);
            card->setFixedHeight(90);
            card->setStyleSheet(R"(
                FriendCard {
                    background: rgba(255, 255, 255, 0.03);
                    border: 1px solid rgba(255, 255, 255, 0.05);
                    border-radius: 12px;
                }
                FriendCard:hover {
                    background: rgba(255, 255, 255, 0.05);
                    border: 1px solid rgba(138, 43, 226, 0.3);
                }
            )");
            
            connect(card, &FriendCard::acceptClicked, this, [this, user]() {
                onAcceptRequest(user.id);
            });
            
            connect(card, &FriendCard::rejectClicked, this, [this, user]() {
                onRejectRequest(user.id);
            });
            
            m_requestsLayout->addWidget(card);
        }
    }
    
    m_requestsLayout->addStretch();
}

void FriendsPage::searchUsers()
{
    QString query = m_searchInput->text().trimmed();
    qDebug() << "=== Searching for:" << query << "===";
    
    if (query.isEmpty()) {
        QMessageBox::warning(this, "", "    ");
        return;
    }
    
    QVector<User> results = m_friendManager->searchUsers(query);
    qDebug() << "Search returned" << results.size() << "results";
    
    for (const User& user : results) {
        qDebug() << "  - User:" << user.username << "ID:" << user.id;
    }
    
    displaySearchResults(results);
}

void FriendsPage::displaySearchResults(const QVector<User>& users)
{
    qDebug() << "=== Displaying" << users.size() << "search results ===";
    
    while (m_searchLayout->count() > 0) {
        QLayoutItem* item = m_searchLayout->takeAt(0);
        if (item->widget()) {
            item->widget()->deleteLater();
        }
        delete item;
    }
    
    if (users.isEmpty()) {
        QLabel* emptyLabel = new QLabel("  ");
        emptyLabel->setStyleSheet("color: rgba(255, 255, 255, 0.7); font-size: 16px; padding: 20px;");
        emptyLabel->setAlignment(Qt::AlignCenter);
        m_searchLayout->addWidget(emptyLabel);
        qDebug() << "Added 'no results' label";
    } else {
        for (const User& user : users) {
            qDebug() << "Creating search result card for:" << user.username;
            FriendCard* card = new FriendCard(user, false, true);
            card->setFixedHeight(90);
            card->setStyleSheet(R"(
                FriendCard {
                    background: rgba(255, 255, 255, 0.03);
                    border: 1px solid rgba(255, 255, 255, 0.05);
                    border-radius: 12px;
                }
                FriendCard:hover {
                    background: rgba(255, 255, 255, 0.05);
                    border: 1px solid rgba(138, 43, 226, 0.3);
                }
            )");
            
            connect(card, &FriendCard::addFriendClicked, this, [this, user]() {
                qDebug() << "Add friend clicked for:" << user.username;
                onAddFriend(user.id);
            });
            
            m_searchLayout->addWidget(card);
            qDebug() << "Card added to layout";
        }
    }
    
    m_searchLayout->addStretch();
    m_stackedWidget->setCurrentWidget(m_searchWidget);
    qDebug() << "Switched to search widget";
    qDebug() << "=== Display complete ===";
}

void FriendsPage::onSearchClicked()
{
    qDebug() << "Search button clicked";
    searchUsers();
}

void FriendsPage::onShowFriends()
{
    m_friendsBtn->setChecked(true);
    m_requestsBtn->setChecked(false);
    m_stackedWidget->setCurrentWidget(m_friendsWidget);
    loadFriends();
}

void FriendsPage::onShowRequests()
{
    m_friendsBtn->setChecked(false);
    m_requestsBtn->setChecked(true);
    m_stackedWidget->setCurrentWidget(m_requestsWidget);
    loadRequests();
}

void FriendsPage::onAddFriend(int userId)
{
    qDebug() << "Sending friend request to user:" << userId;
    if (m_friendManager->sendFriendRequest(userId)) {
        QMessageBox::information(this, "", "   !");
    } else {
        QMessageBox::warning(this, "", "   ");
    }
}

void FriendsPage::onAcceptRequest(int userId)
{
    if (m_friendManager->acceptFriendRequest(userId)) {
        QMessageBox::information(this, "", " !");
        loadRequests();
        loadFriends();
    } else {
        QMessageBox::warning(this, "", "   ");
    }
}

void FriendsPage::onRejectRequest(int userId)
{
    if (m_friendManager->rejectFriendRequest(userId)) {
        loadRequests();
    } else {
        QMessageBox::warning(this, "", "   ");
    }
}

void FriendsPage::onRemoveFriend(int userId)
{
    QMessageBox::StandardButton reply = QMessageBox::question(
        this, 
        "  ", 
        " ,      ?",
        QMessageBox::Yes | QMessageBox::No
    );
    
    if (reply == QMessageBox::Yes) {
        if (m_friendManager->removeFriend(userId)) {
            loadFriends();
        } else {
            QMessageBox::warning(this, "", "   ");
        }
    }
}

void FriendsPage::onMessageFriend(int userId)
{
    QVector<User> friends = m_friendManager->getFriends();
    for (const User& user : friends) {
        if (user.id == userId) {
            emit openChatWithFriend(userId, user.username);
            break;
        }
    }
}

void FriendsPage::refreshData()
{
    if (m_stackedWidget->currentWidget() == m_friendsWidget) {
        loadFriends();
    } else if (m_stackedWidget->currentWidget() == m_requestsWidget) {
        loadRequests();
    }
}


=== kursach/src/gui/MainWindow/pages/SearchMusicPage.cpp ===
#include <gui/MainWindow/pages/SearchMusicPage.h>
#include <database/api/MusicAPIManager.h>
#include <database/DatabaseManager.h>
#include <gui/dialogs/NotificationDialog.h>
#include <QComboBox>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLineEdit>
#include <QPushButton>
#include <QListWidget>
#include <QLabel>
#include <QWidget>
#include <QMenu>
#include <QDebug>
#include <QMediaPlayer>

SearchMusicPage::SearchMusicPage(int userId, QWidget *parent)
    : QWidget(parent), muserId(userId),
      mapiManager(new MusicAPIManager(this)),
      msearchInput(nullptr),
      msearchButton(nullptr),
      mtopStationsButton(nullptr),
      mgenreCombo(nullptr),
      mstationsList(nullptr),
      mstationInfo(nullptr),
      mloadingLabel(nullptr),
      mradioPlayer(new QMediaPlayer(this)),
      mcurrentSelectedIndex(-1)
{
    DatabaseManager::instance().initialize();
    setupUI();

    connect(mapiManager, &MusicAPIManager::stationsFound, this, &SearchMusicPage::onStationsFound);
    connect(mapiManager, &MusicAPIManager::errorOccurred, this, &SearchMusicPage::onNetworkError);
}

SearchMusicPage::~SearchMusicPage()
{
}

void SearchMusicPage::setupUI()
{
    QVBoxLayout *mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(40, 40, 40, 40);
    mainLayout->setSpacing(25);

    QLabel *titleLabel = new QLabel(" ");
    titleLabel->setStyleSheet("color: white; font-size: 32px; font-weight: bold;");
    mainLayout->addWidget(titleLabel);

    QWidget *searchWidget = new QWidget(this);
    QHBoxLayout *searchLayout = new QHBoxLayout(searchWidget);
    searchLayout->setContentsMargins(0, 0, 0, 0);
    searchLayout->setSpacing(15);

    msearchInput = new QLineEdit(searchWidget);
    msearchInput->setPlaceholderText(" ...");
    msearchInput->setMinimumHeight(50);
    msearchInput->setStyleSheet(R"(
        QLineEdit {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 0 20px;
            color: white;
            font-size: 14px;
        }
        QLineEdit:focus {
            border: 2px solid #8A2BE2;
            background: rgba(255, 255, 255, 0.07);
        }
    )");

    msearchButton = new QPushButton("", searchWidget);
    msearchButton->setFixedWidth(120);
    msearchButton->setMinimumHeight(50);
    msearchButton->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");

    mtopStationsButton = new QPushButton("", searchWidget);
    mtopStationsButton->setFixedWidth(150);
    mtopStationsButton->setMinimumHeight(50);
    mtopStationsButton->setStyleSheet(msearchButton->styleSheet());

    searchLayout->addWidget(msearchInput, 1);
    searchLayout->addWidget(msearchButton);
    searchLayout->addWidget(mtopStationsButton);
    mainLayout->addWidget(searchWidget);

    QWidget *genreWidget = new QWidget(this);
    QHBoxLayout *genreLayout = new QHBoxLayout(genreWidget);
    genreLayout->setContentsMargins(0, 0, 0, 0);
    genreLayout->setSpacing(15);

    QLabel *genreLabel = new QLabel(":");
    genreLabel->setStyleSheet("color: white; font-size: 14px;");

    mgenreCombo = new QComboBox(genreWidget);
    mgenreCombo->setMinimumHeight(40);
    mgenreCombo->setMaximumWidth(250);
    mgenreCombo->addItem("");
    mgenreCombo->addItem("Rock");
    mgenreCombo->addItem("Pop");
    mgenreCombo->addItem("Jazz");
    mgenreCombo->addItem("Classical");
    mgenreCombo->addItem("Electronic");
    mgenreCombo->addItem("Hip Hop");
    mgenreCombo->addItem("Country");
    mgenreCombo->setStyleSheet(R"(
        QComboBox {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 0 10px;
            color: white;
            font-size: 14px;
        }
        QComboBox::drop-down {
            border: none;
        }
        QComboBox QAbstractItemView {
            background: #1A1A21;
            color: white;
            selection-background-color: rgba(138, 43, 226, 0.3);
        }
    )");

    genreLayout->addWidget(genreLabel);
    genreLayout->addWidget(mgenreCombo);
    genreLayout->addStretch();
    mainLayout->addWidget(genreWidget);

    QWidget *resultsWidget = new QWidget(this);
    QHBoxLayout *resultsLayout = new QHBoxLayout(resultsWidget);
    resultsLayout->setContentsMargins(0, 0, 0, 0);
    resultsLayout->setSpacing(20);

    mstationsList = new QListWidget(resultsWidget);
    mstationsList->setStyleSheet(R"(
        QListWidget {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            color: white;
            font-size: 14px;
            outline: none;
            padding: 10px;
        }
        QListWidget::item {
            background: transparent;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
        }
        QListWidget::item:selected {
            background: rgba(138, 43, 226, 0.15);
            border: 1px solid rgba(138, 43, 226, 0.3);
        }
        QListWidget::item:hover {
            background: rgba(255, 255, 255, 0.05);
        }
    )");
    mstationsList->setContextMenuPolicy(Qt::CustomContextMenu);

    QWidget *infoContainer = new QWidget();
    infoContainer->setMaximumWidth(380);
    QVBoxLayout *infoLayout = new QVBoxLayout(infoContainer);
    infoLayout->setContentsMargins(0, 0, 0, 0);
    infoLayout->setSpacing(12);

    mstationInfo = new QTextEdit();
    mstationInfo->setReadOnly(true);
    mstationInfo->setStyleSheet(R"(
        QTextEdit {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            color: white;
            font-size: 13px;
            padding: 15px;
        }
    )");
    mstationInfo->setPlaceholderText("  ");

    infoLayout->addWidget(mstationInfo);

    QWidget *buttonsWidget = new QWidget();
    QVBoxLayout *buttonsLayout = new QVBoxLayout(buttonsWidget);
    buttonsLayout->setContentsMargins(0, 0, 0, 0);
    buttonsLayout->setSpacing(10);

    QPushButton *playBtn = new QPushButton("");
    playBtn->setMinimumHeight(40);
    playBtn->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");

    QPushButton *addBtn = new QPushButton("  ");
    addBtn->setMinimumHeight(40);
    addBtn->setStyleSheet(R"(
        QPushButton {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: rgba(255, 255, 255, 0.15);
        }
    )");

    connect(playBtn, &QPushButton::clicked, this, &SearchMusicPage::playSelectedStation);
    connect(addBtn, &QPushButton::clicked, this, &SearchMusicPage::addSelectedStation);

    buttonsLayout->addWidget(playBtn);
    buttonsLayout->addWidget(addBtn);
    buttonsLayout->addStretch();

    infoLayout->addWidget(buttonsWidget);

    resultsLayout->addWidget(mstationsList, 1);
    resultsLayout->addWidget(infoContainer);
    mainLayout->addWidget(resultsWidget, 1);

    mloadingLabel = new QLabel("...");
    mloadingLabel->setStyleSheet("color: #8A2BE2; font-size: 16px;");
    mloadingLabel->setAlignment(Qt::AlignCenter);
    mloadingLabel->hide();
    mainLayout->addWidget(mloadingLabel);

    connect(msearchButton, &QPushButton::clicked, this, &SearchMusicPage::onSearchClicked);
    connect(mtopStationsButton, &QPushButton::clicked, this, &SearchMusicPage::onTopStationsClicked);
    connect(msearchInput, &QLineEdit::returnPressed, this, &SearchMusicPage::onSearchClicked);
    connect(mgenreCombo, QOverload<const QString &>::of(&QComboBox::currentTextChanged),
            this, &SearchMusicPage::onGenreChanged);
    connect(mstationsList, &QListWidget::itemClicked, this, &SearchMusicPage::onStationSelected);
    connect(mstationsList, &QListWidget::customContextMenuRequested, this, &SearchMusicPage::onStationContextMenu);
}

void SearchMusicPage::onSearchClicked()
{
    QString query = msearchInput->text().trimmed();
    if (query.isEmpty())
        return;

    mloadingLabel->show();
    mstationsList->clear();
    mstationInfo->clear();
    mcurrentStations.clear();

    mapiManager->searchStations(query, muserId);
}

void SearchMusicPage::onTopStationsClicked()
{
    mloadingLabel->show();
    mstationsList->clear();
    mstationInfo->clear();
    mcurrentStations.clear();

    mapiManager->getTopStations(muserId);
}

void SearchMusicPage::onGenreChanged(const QString &genre)
{
    if (genre.isEmpty() || genre == "")
        return;

    mloadingLabel->show();
    mstationsList->clear();
    mstationInfo->clear();
    mcurrentStations.clear();

    qDebug() << "SearchMusicPage::onGenreChanged:   :" << genre;
    mapiManager->getStationsByGenre(genre, muserId);
}

void SearchMusicPage::onStationsFound(const QVariantList &stations)
{
    mloadingLabel->hide();
    mcurrentStations = stations;
    displayStations(stations);
}

void SearchMusicPage::displayStations(const QVariantList &stations)
{
    mstationsList->clear();
    if (stations.isEmpty()) {
        QLabel *emptyLabel = new QLabel("  ");
        emptyLabel->setStyleSheet("color: rgba(255, 255, 255, 0.5); font-size: 16px;");
        emptyLabel->setAlignment(Qt::AlignCenter);
        QListWidgetItem *item = new QListWidgetItem();
        item->setFlags(Qt::NoItemFlags);
        mstationsList->addItem(item);
        mstationsList->setItemWidget(item, emptyLabel);
        return;
    }

    for (int i = 0; i < stations.size(); i++) {
        QVariantMap station = stations[i].toMap();
        QString text = station.value("title").toString();
        if (!station.value("artist").toString().isEmpty()) {
            text = QString("%1 - %2").arg(text, station.value("artist").toString());
        }

        QListWidgetItem *item = new QListWidgetItem(text);
        item->setData(Qt::UserRole, i);
        mstationsList->addItem(item);
    }
}

void SearchMusicPage::onStationSelected(QListWidgetItem *item)
{
    int index = item->data(Qt::UserRole).toInt();
    if (index < 0 || index >= mcurrentStations.size())
        return;

    mcurrentSelectedIndex = index;
    mcurrentSelectedStation = mcurrentStations[index].toMap();

    QString info = QString("<h3 style=\"color:#8A2BE2;margin:0 0 10px 0;\">%1</h3>")
                   .arg(mcurrentSelectedStation.value("title").toString());

    if (!mcurrentSelectedStation.value("artist").toString().isEmpty()) {
        info += QString("<p style=\"color:white;font-size:14px;margin:0 0 8px 0;\"><b>%1</b></p>")
                .arg(mcurrentSelectedStation.value("artist").toString());
    }

    if (mcurrentSelectedStation.contains("genre") && !mcurrentSelectedStation.value("genre").toString().isEmpty()) {
        info += QString("<p style=\"color:rgba(255,255,255,0.7);font-size:12px;margin:0 0 4px 0;\">: %1</p>")
                .arg(mcurrentSelectedStation.value("genre").toString());
    }

    if (mcurrentSelectedStation.contains("bitrate") && mcurrentSelectedStation.value("bitrate").toInt() > 0) {
        info += QString("<p style=\"color:rgba(255,255,255,0.7);font-size:12px;margin:0;\">: %1 kbps</p>")
                .arg(mcurrentSelectedStation.value("bitrate").toString());
    }

    mstationInfo->setHtml(info);
}

void SearchMusicPage::onStationContextMenu(const QPoint &pos)
{
    QListWidgetItem *item = mstationsList->itemAt(pos);
    if (!item)
        return;

    int index = item->data(Qt::UserRole).toInt();
    if (index < 0 || index >= mcurrentStations.size())
        return;

    QVariantMap station = mcurrentStations[index].toMap();

    QMenu menu(this);
    menu.setStyleSheet(R"(
        QMenu {
            background: #1A1A21;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 5px;
        }
        QMenu::item {
            background: transparent;
            color: white;
            padding: 8px 20px;
            border-radius: 4px;
        }
        QMenu::item:selected {
            background: rgba(138, 43, 226, 0.3);
        }
    )");

    QAction *playAction = menu.addAction("");
    QAction *addAction = menu.addAction("  ");
    QAction *selected = menu.exec(mstationsList->mapToGlobal(pos));

    if (selected == playAction) {
        mradioPlayer->setMedia(QUrl(station.value("streamUrl").toString()));
        mradioPlayer->play();
    }
    else if (selected == addAction) {
        qDebug() << "onStationContextMenu:   "
                 << "userId:" << muserId
                 << "title:" << station.value("title").toString()
                 << "streamUrl:" << station.value("streamUrl").toString();

        bool success = DatabaseManager::instance().addRadioStation(
            muserId,
            station.value("title").toString(),
            station.value("artist").toString(),
            station.value("streamUrl").toString(),
            station.value("genre").toString(),
            station.value("bitrate").toInt()
        );

        qDebug() << "onStationContextMenu:   - success:" << success;

        if (success) {
            NotificationDialog dialog(
                QString(" '%1'   ").arg(station.value("title").toString()),
                NotificationDialog::Success,
                this
            );
            dialog.exec();
            emit stationAdded();
        } else {
            NotificationDialog dialog(
                "   .     .",
                NotificationDialog::Error,
                this
            );
            dialog.exec();
        }
    }
}

void SearchMusicPage::playSelectedStation()
{
    if (mcurrentSelectedIndex >= 0 && mcurrentSelectedIndex < mcurrentStations.size()) {
        QVariantMap station = mcurrentStations[mcurrentSelectedIndex].toMap();
        mradioPlayer->setMedia(QUrl(station.value("streamUrl").toString()));
        mradioPlayer->play();
    }
}

void SearchMusicPage::addSelectedStation()
{
    if (mcurrentSelectedIndex >= 0 && mcurrentSelectedIndex < mcurrentStations.size()) {
        QVariantMap station = mcurrentStations[mcurrentSelectedIndex].toMap();

        bool success = DatabaseManager::instance().addRadioStation(
            muserId,
            station.value("title").toString(),
            station.value("artist").toString(),
            station.value("streamUrl").toString(),
            station.value("genre").toString(),
            station.value("bitrate").toInt()
        );

        if (success) {
            NotificationDialog dialog(
                QString(" '%1'   ").arg(station.value("title").toString()),
                NotificationDialog::Success,
                this
            );
            dialog.exec();
            emit stationAdded();
        } else {
            NotificationDialog dialog(
                "   .",
                NotificationDialog::Error,
                this
            );
            dialog.exec();
        }
    }
}

void SearchMusicPage::onNetworkError(const QString &error)
{
    mloadingLabel->hide();
    qDebug() << "SearchMusicPage::onNetworkError:" << error;
    NotificationDialog dialog(
        error,
        NotificationDialog::Error,
        this
    );
    dialog.exec();
}

=== kursach/src/gui/MainWindow/pages/RoomsPage.cpp ===
#include "gui/MainWindow/pages/RoomsPage.h"
#include "network/RoomManager.h"
#include "network/WebSocketClient.h"
#include "gui/widgets/RoomCard.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QLabel>
#include <QInputDialog>
#include <QMessageBox>
#include <QScrollArea>
#include <QDialog>
#include <QGraphicsDropShadowEffect>
#include <QDebug>

//   
class DarkInputDialog : public QDialog
{
public:
    enum Type { Text, Integer };

    DarkInputDialog(const QString &title, const QString &label, Type type = Text, QWidget *parent = nullptr)
        : QDialog(parent), m_type(type), m_result(false)
    {
        setWindowFlags(Qt::Dialog | Qt::FramelessWindowHint);
        setAttribute(Qt::WA_TranslucentBackground);
        setStyleSheet("background: transparent;");
        setFixedSize(450, 220);
        setWindowTitle(title);

        QVBoxLayout* mainLayout = new QVBoxLayout(this);
        mainLayout->setContentsMargins(0, 0, 0, 0);

        QWidget* container = new QWidget();
        container->setStyleSheet(R"(
            QWidget {
                background: #0F0F14;
                border: 1px solid rgba(138, 43, 226, 0.3);
                border-radius: 12px;
            }
        )");

        QVBoxLayout* containerLayout = new QVBoxLayout(container);
        containerLayout->setContentsMargins(0, 0, 0, 0);
        containerLayout->setSpacing(0);

        // Header
        QWidget* header = new QWidget();
        header->setFixedHeight(50);
        header->setStyleSheet(R"(
            QWidget {
                background: rgba(138, 43, 226, 0.1);
                border-bottom: 1px solid rgba(138, 43, 226, 0.2);
                border-radius: 12px 12px 0px 0px;
            }
        )");

        QHBoxLayout* headerLayout = new QHBoxLayout(header);
        headerLayout->setContentsMargins(15, 0, 15, 0);

        QLabel* titleLabel = new QLabel(title);
        titleLabel->setStyleSheet(R"(
            QLabel {
                color: #8A2BE2;
                font-size: 14px;
                font-weight: 600;
                background: transparent;
                border: none;
            }
        )");

        headerLayout->addWidget(titleLabel);
        headerLayout->addStretch();

        // Body
        QWidget* body = new QWidget();
        body->setStyleSheet("background: transparent;");
        QVBoxLayout* bodyLayout = new QVBoxLayout(body);
        bodyLayout->setContentsMargins(20, 15, 20, 15);
        bodyLayout->setSpacing(12);

        QLabel* labelText = new QLabel(label);
        labelText->setStyleSheet(R"(
            QLabel {
                color: rgba(255, 255, 255, 0.85);
                font-size: 13px;
                font-weight: 400;
                background: transparent;
                border: none;
            }
        )");

        m_input = new QLineEdit();
        m_input->setMinimumHeight(40);
        m_input->setStyleSheet(R"(
            QLineEdit {
                background: rgba(255, 255, 255, 0.05);
                border: 2px solid rgba(138, 43, 226, 0.2);
                border-radius: 8px;
                padding: 0 12px;
                color: white;
                font-size: 13px;
            }
            QLineEdit:focus {
                border: 2px solid #8A2BE2;
                background: rgba(138, 43, 226, 0.08);
            }
        )");

        bodyLayout->addWidget(labelText);
        bodyLayout->addWidget(m_input);

        // Footer
        QWidget* footer = new QWidget();
        footer->setFixedHeight(50);
        footer->setStyleSheet("background: transparent;");
        QHBoxLayout* footerLayout = new QHBoxLayout(footer);
        footerLayout->setContentsMargins(15, 0, 15, 0);
        footerLayout->setSpacing(10);

        QPushButton* okBtn = new QPushButton("OK");
        okBtn->setFixedWidth(100);
        okBtn->setFixedHeight(35);
        okBtn->setStyleSheet(R"(
            QPushButton {
                background: #8A2BE2;
                color: white;
                border: none;
                border-radius: 6px;
                font-size: 13px;
                font-weight: 600;
            }
            QPushButton:hover {
                background: #9B4BFF;
            }
            QPushButton:pressed {
                background: #7B1FA2;
            }
        )");

        QPushButton* cancelBtn = new QPushButton("");
        cancelBtn->setFixedWidth(100);
        cancelBtn->setFixedHeight(35);
        cancelBtn->setStyleSheet(R"(
            QPushButton {
                background: rgba(138, 43, 226, 0.2);
                color: #8A2BE2;
                border: 1px solid #8A2BE2;
                border-radius: 6px;
                font-size: 13px;
                font-weight: 600;
            }
            QPushButton:hover {
                background: rgba(138, 43, 226, 0.3);
            }
        )");

        footerLayout->addStretch();
        footerLayout->addWidget(okBtn);
        footerLayout->addWidget(cancelBtn);

        containerLayout->addWidget(header);
        containerLayout->addWidget(body);
        containerLayout->addWidget(footer);

        mainLayout->addWidget(container);

        QGraphicsDropShadowEffect* shadow = new QGraphicsDropShadowEffect();
        shadow->setBlurRadius(15);
        shadow->setColor(QColor(0, 0, 0, 60));
        shadow->setOffset(0, 4);
        container->setGraphicsEffect(shadow);

        connect(okBtn, &QPushButton::clicked, this, &QDialog::accept);
        connect(cancelBtn, &QPushButton::clicked, this, &QDialog::reject);
        connect(m_input, &QLineEdit::returnPressed, this, &QDialog::accept);
    }

    QString getText() const { return m_input->text(); }
    int getInt() const { return m_input->text().toInt(); }

private:
    Type m_type;
    bool m_result;
    QLineEdit* m_input;
};

RoomsPage::RoomsPage(int userId, QWidget *parent)
    : QWidget(parent)
    , m_userId(userId)
    , m_currentRoomId(-1)
    , m_roomManager(new RoomManager(userId, this))
    , m_wsClient(new WebSocketClient(userId, this))
{
    setupUI();
    
    connect(m_roomManager, &RoomManager::roomJoined, [this](int roomId) {
        m_currentRoomId = roomId;
        m_wsClient->joinRoom(roomId);
    });
    
    connect(m_roomManager, &RoomManager::roomLeft, [this](int roomId) {
        m_wsClient->leaveRoom(roomId);
        m_currentRoomId = -1;
    });
    
    m_wsClient->connectToServer("ws://localhost:8080");
    
    loadRooms();
}

RoomsPage::~RoomsPage()
{
    if (m_currentRoomId != -1) {
        m_roomManager->leaveRoom(m_currentRoomId);
    }
}

void RoomsPage::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(40, 40, 40, 40);
    mainLayout->setSpacing(25);
    
    QLabel* titleLabel = new QLabel("");
    titleLabel->setStyleSheet("color: white; font-size: 32px; font-weight: bold;");
    mainLayout->addWidget(titleLabel);
    
    QWidget* controlsWidget = new QWidget();
    QHBoxLayout* controlsLayout = new QHBoxLayout(controlsWidget);
    controlsLayout->setContentsMargins(0, 0, 0, 0);
    controlsLayout->setSpacing(15);
    
    m_searchInput = new QLineEdit();
    m_searchInput->setPlaceholderText(" ...");
    m_searchInput->setMinimumHeight(45);
    m_searchInput->setStyleSheet(R"(
        QLineEdit {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 0 20px;
            color: white;
            font-size: 14px;
        }
        QLineEdit:focus {
            border: 2px solid #8A2BE2;
        }
    )");
    
    m_createButton = new QPushButton(" ");
    m_createButton->setMinimumHeight(45);
    m_createButton->setFixedWidth(180);
    m_createButton->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");
    
    controlsLayout->addWidget(m_searchInput);
    controlsLayout->addWidget(m_createButton);
    
    mainLayout->addWidget(controlsWidget);
    
    m_scrollArea = new QScrollArea();
    m_scrollArea->setWidgetResizable(true);
    m_scrollArea->setStyleSheet(R"(
        QScrollArea {
            background: transparent;
            border: none;
        }
        QScrollBar:vertical {
            background: rgba(255, 255, 255, 0.05);
            width: 8px;
            border-radius: 4px;
        }
        QScrollBar::handle:vertical {
            background: rgba(138, 43, 226, 0.5);
            border-radius: 4px;
        }
    )");
    
    m_roomsContainer = new QWidget();
    m_roomsContainer->setStyleSheet("background: transparent;");
    m_scrollArea->setWidget(m_roomsContainer);
    
    mainLayout->addWidget(m_scrollArea, 1);
    
    connect(m_createButton, &QPushButton::clicked, this, &RoomsPage::onCreateRoom);
    connect(m_searchInput, &QLineEdit::textChanged, this, &RoomsPage::onSearchRooms);
}

void RoomsPage::loadRooms()
{
    QVector<Room> rooms = m_roomManager->getPublicRooms();
    displayRooms(rooms);
}

void RoomsPage::displayRooms(const QVector<Room>& rooms)
{
    if (m_roomsContainer->layout()) {
        QLayoutItem* item;
        while ((item = m_roomsContainer->layout()->takeAt(0)) != nullptr) {
            delete item->widget();
            delete item;
        }
        delete m_roomsContainer->layout();
    }
    
    QVBoxLayout* mainLayout = new QVBoxLayout(m_roomsContainer);
    mainLayout->setSpacing(20);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    
    if (rooms.isEmpty()) {
        mainLayout->addStretch();
        
        QWidget* centerWidget = new QWidget();
        QVBoxLayout* centerLayout = new QVBoxLayout(centerWidget);
        centerLayout->setContentsMargins(0, 0, 0, 0);
        centerLayout->setSpacing(15);
        
        QLabel *emptyLabel = new QLabel("  ");
        emptyLabel->setStyleSheet("color: rgba(255, 255, 255, 0.6); font-size: 18px; font-weight: 500;");
        emptyLabel->setAlignment(Qt::AlignCenter);
        
        QLabel *hintLabel = new QLabel("     ");
        hintLabel->setStyleSheet("color: rgba(255, 255, 255, 0.4); font-size: 14px;");
        hintLabel->setAlignment(Qt::AlignCenter);
        
        centerLayout->addWidget(emptyLabel);
        centerLayout->addWidget(hintLabel);
        centerWidget->setLayout(centerLayout);
        
        mainLayout->addWidget(centerWidget, 0, Qt::AlignCenter);
        mainLayout->addStretch();
    } else {
        QGridLayout* gridLayout = new QGridLayout();
        gridLayout->setSpacing(20);
        gridLayout->setContentsMargins(0, 0, 0, 0);
        
        for (int i = 0; i < rooms.size(); ++i) {
            RoomCard* card = new RoomCard(rooms[i]);
            connect(card, &RoomCard::joinClicked, this, &RoomsPage::onJoinRoom);
            
            int row = i / 2;
            int col = i % 2;
            gridLayout->addWidget(card, row, col);
        }
        
        gridLayout->setRowStretch(gridLayout->rowCount(), 1);
        gridLayout->setColumnStretch(0, 1);
        gridLayout->setColumnStretch(1, 1);
        
        mainLayout->addLayout(gridLayout, 1);
    }
}

void RoomsPage::onCreateRoom()
{
    openRoomDialog();
}

void RoomsPage::openRoomDialog()
{
    //  
    DarkInputDialog nameDialog(" ", " :", DarkInputDialog::Text, this);
    if (nameDialog.exec() != QDialog::Accepted) return;
    QString name = nameDialog.getText();
    if (name.isEmpty()) return;

    // 
    DarkInputDialog genreDialog(" ", ":", DarkInputDialog::Text, this);
    if (genreDialog.exec() != QDialog::Accepted) return;
    QString genre = genreDialog.getText();

    //  
    DarkInputDialog membersDialog(" ", "  (2-100):", DarkInputDialog::Integer, this);
    if (membersDialog.exec() != QDialog::Accepted) return;
    int maxMembers = membersDialog.getInt();
    if (maxMembers < 2 || maxMembers > 100) {
        QMessageBox::warning(this, "", "     2  100");
        return;
    }

    int roomId = m_roomManager->createRoom(name, "", genre, maxMembers, false);

    if (roomId != -1) {
        QMessageBox::information(this, "", " !");
        loadRooms();
    } else {
        QMessageBox::warning(this, "", "   ");
    }
}

void RoomsPage::onJoinRoom(int roomId)
{
    if (m_roomManager->joinRoom(roomId)) {
        QMessageBox::information(this, "", "   !");
        loadRooms();
    } else {
        QMessageBox::warning(this, "", "  ");
    }
}

void RoomsPage::onLeaveRoom()
{
    if (m_currentRoomId != -1) {
        m_roomManager->leaveRoom(m_currentRoomId);
    }
}

void RoomsPage::onSearchRooms(const QString& query)
{
    QVector<Room> allRooms = m_roomManager->getPublicRooms();
    
    if (query.isEmpty()) {
        displayRooms(allRooms);
        return;
    }
    
    QVector<Room> filtered;
    for (const Room& room : allRooms) {
        if (room.name.contains(query, Qt::CaseInsensitive) ||
            room.genre.contains(query, Qt::CaseInsensitive)) {
            filtered.append(room);
        }
    }
    
    displayRooms(filtered);
}

=== kursach/src/gui/MainWindow/pages/RoomsPage.h ===
#ifndef ROOMSPAGE_H
#define ROOMSPAGE_H

#include <QWidget>
#include <QListWidget>
#include <QPushButton>
#include <QLineEdit>
#include <QScrollArea>
#include "core/models/Room.h"

class RoomManager;
class WebSocketClient;

class RoomsPage : public QWidget
{
    Q_OBJECT

public:
    explicit RoomsPage(int userId, QWidget *parent = nullptr);
    ~RoomsPage();
    
    void loadRooms();

private slots:
    void onCreateRoom();
    void onJoinRoom(int roomId);
    void onLeaveRoom();
    void onSearchRooms(const QString& query);

private:
    void setupUI();
    void displayRooms(const QVector<Room>& rooms);
    void openRoomDialog();
    
    int m_userId;
    int m_currentRoomId;
    RoomManager* m_roomManager;
    WebSocketClient* m_wsClient;
    
    QListWidget* m_roomsList;
    QPushButton* m_createButton;
    QLineEdit* m_searchEdit;
    QLineEdit* m_searchInput;
    QScrollArea* m_scrollArea;
    QWidget* m_roomsContainer;
};

#endif




=== kursach/src/gui/MainWindow/pages/MessagesPage.h ===
#ifndef MESSAGESPAGE_H
#define MESSAGESPAGE_H

#include <QWidget>
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QListWidget>
#include <QStackedWidget>
#include "network/ChatManager.h"
#include "gui/widgets/ChatWidget.h"

class MessagesPage : public QWidget
{
    Q_OBJECT

public:
    explicit MessagesPage(int userId, QWidget *parent = nullptr);
    
    void openChat(int friendId, const QString& friendName);
    void refreshChats();

private slots:
    void onChatSelected(QListWidgetItem* item);
    void onBackToList();

private:
    void setupUI();
    void loadChats();
    
    int m_userId;
    ChatManager* m_chatManager;
    
    QStackedWidget* m_stackedWidget;
    QWidget* m_chatListWidget;
    QListWidget* m_chatList;
    ChatWidget* m_currentChatWidget;
};

#endif


=== kursach/src/gui/MainWindow/pages/MyMusicPage.cpp ===
#include "gui/MainWindow/pages/MyMusicPage.h"
#include "core/managers/TrackManager.h"
#include "audio/LocalFileHandler.h"
#include "audio/AudioPlayer.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QPushButton>
#include <QListWidget>
#include <QListWidgetItem>
#include <QDebug>
#include <QMenu>
#include <QRandomGenerator>
#include <QMediaPlayer>
#include "database/DatabaseManager.h"

MyMusicPage::MyMusicPage(int userId, QWidget *parent)
    : QWidget(parent), muserId(userId),
      mtrackManager(new TrackManager(userId, this)),
      mfileHandler(new LocalFileHandler(this)),
      maudioPlayer(new AudioPlayer(this)),
      mradioPlayer(new QMediaPlayer(this))
{
    setupUI();
    loadRadioStations();
}

MyMusicPage::~MyMusicPage()
{
}

void MyMusicPage::setupUI()
{
    QVBoxLayout *mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(40, 40, 40, 40);
    mainLayout->setSpacing(25);
    
    QWidget *headerWidget = new QWidget();
    QHBoxLayout *headerLayout = new QHBoxLayout(headerWidget);
    headerLayout->setContentsMargins(0, 0, 0, 0);
    
    mtitleLabel = new QLabel(" ");
    mtitleLabel->setStyleSheet("color: white; font-size: 32px; font-weight: bold;");
    
    mstatsLabel = new QLabel();
    mstatsLabel->setStyleSheet("color: rgba(255, 255, 255, 0.6); font-size: 14px;");
    
    headerLayout->addWidget(mtitleLabel);
    headerLayout->addWidget(mstatsLabel);
    headerLayout->addStretch();
    
    mainLayout->addWidget(headerWidget);
    
    QWidget *controlsWidget = new QWidget();
    QVBoxLayout *controlsLayout = new QVBoxLayout(controlsWidget);
    controlsLayout->setContentsMargins(0, 0, 0, 0);
    controlsLayout->setSpacing(10);
    
    mrefreshButton = new QPushButton(" ");
    mrefreshButton->setMinimumHeight(50);
    mrefreshButton->setMinimumWidth(200);
    mrefreshButton->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            padding: 10px 20px;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");
    
    mplayRandomButton = new QPushButton(" ");
    mplayRandomButton->setMinimumHeight(50);
    mplayRandomButton->setMinimumWidth(200);
    mplayRandomButton->setStyleSheet(mrefreshButton->styleSheet());
    
    QHBoxLayout *buttonsLayout = new QHBoxLayout();
    buttonsLayout->addWidget(mrefreshButton);
    buttonsLayout->addWidget(mplayRandomButton);
    buttonsLayout->addStretch();
    
    controlsLayout->addLayout(buttonsLayout);
    mainLayout->addWidget(controlsWidget);
    
    msearchEdit = new QLineEdit();
    msearchEdit->setPlaceholderText("  ...");
    msearchEdit->setFixedHeight(45);
    msearchEdit->setStyleSheet(R"(
        QLineEdit {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 0 15px;
            color: white;
            font-size: 14px;
        }
        QLineEdit:focus {
            border: 2px solid #8A2BE2;
        }
    )");
    
    mainLayout->addWidget(msearchEdit);
    
    mradioList = new QListWidget();
    mradioList->setStyleSheet(R"(
        QListWidget {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            color: white;
            font-size: 14px;
            outline: none;
        }
        QListWidget::item {
            background: transparent;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            padding: 0px;
            margin: 0px;
            border-radius: 0px;
        }
        QListWidget::item:selected {
            background: rgba(138, 43, 226, 0.15);
            border: none;
        }
        QListWidget::item:hover {
            background: rgba(255, 255, 255, 0.05);
        }
    )");
    mradioList->setContextMenuPolicy(Qt::CustomContextMenu);
    
    mainLayout->addWidget(mradioList, 1);
    
    connect(mrefreshButton, &QPushButton::clicked, this, &MyMusicPage::onRefreshClicked);
    connect(mplayRandomButton, &QPushButton::clicked, this, &MyMusicPage::onPlayRadioClicked);
    connect(msearchEdit, &QLineEdit::textChanged, this, &MyMusicPage::onSearchChanged);
    connect(mradioList, &QListWidget::customContextMenuRequested, this, &MyMusicPage::onRadioListContextMenu);
}

void MyMusicPage::loadRadioStations()
{
    mradioList->clear();
    QList<TrackData> list = DatabaseManager::instance().getUserRadioStations(muserId);
    mallRadioStations.clear();
    for (const TrackData &item : list) {
        mallRadioStations.append(item);
    }
    
    qDebug() << "MyMusicPage::loadRadioStations - Loaded stations:" << mallRadioStations.count();
    
    mstatsLabel->setText(QString(": %1").arg(mallRadioStations.count()));
    
    displayRadioStations(mallRadioStations);
}

void MyMusicPage::displayRadioStations(const QVector<TrackData> &stations)
{
    mradioList->clear();
    
    if (stations.isEmpty()) {
        QLabel *emptyLabel = new QLabel(" .\n      ' '");
        emptyLabel->setStyleSheet("color: rgba(255, 255, 255, 0.5); font-size: 16px;");
        emptyLabel->setAlignment(Qt::AlignCenter | Qt::AlignTop);
        QListWidgetItem *item = new QListWidgetItem();
        item->setFlags(Qt::NoItemFlags);
        item->setSizeHint(QSize(0, 100));
        mradioList->addItem(item);
        mradioList->setItemWidget(item, emptyLabel);
        return;
    }
    
    for (const TrackData &station : stations) {
        QListWidgetItem *item = new QListWidgetItem();
        item->setData(Qt::UserRole, station.id);
        item->setSizeHint(QSize(0, 70));
        
        QWidget *stationWidget = new QWidget();
        stationWidget->setStyleSheet("background-color: transparent;");
        
        QHBoxLayout *layout = new QHBoxLayout(stationWidget);
        layout->setContentsMargins(15, 8, 15, 8);
        layout->setSpacing(12);
        
        QLabel *iconLabel = new QLabel("RADIO");
        iconLabel->setStyleSheet("font-size: 14px; min-width: 45px; color: #8A2BE2; font-weight: bold;");
        
        QWidget *textWidget = new QWidget();
        QVBoxLayout *textLayout = new QVBoxLayout(textWidget);
        textLayout->setContentsMargins(0, 0, 0, 0);
        textLayout->setSpacing(2);
        
        QLabel *titleLabel = new QLabel(station.title);
        titleLabel->setStyleSheet(R"(
            QLabel {
                color: white;
                font-size: 14px;
                font-weight: 500;
                background: transparent;
            }
        )");
        
        QLabel *artistLabel = new QLabel(station.artist);
        artistLabel->setStyleSheet(R"(
            QLabel {
                color: rgba(255, 255, 255, 0.6);
                font-size: 12px;
                background: transparent;
            }
        )");
        
        textLayout->addWidget(titleLabel);
        textLayout->addWidget(artistLabel);
        
        QPushButton *playBtn = new QPushButton();
        playBtn->setFixedSize(45, 40);
        playBtn->setText(QString::fromUtf8("\u25B6"));
        playBtn->setStyleSheet(R"(
            QPushButton {
                background-color: rgba(138, 43, 226, 0.2);
                color: white;
                border: none;
                border-radius: 5px;
                font-size: 18px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: rgba(138, 43, 226, 0.3);
            }
        )");
        
        int stationId = station.id;
        connect(playBtn, &QPushButton::clicked, [this, stationId]() {
            onPlayRadio(stationId);
        });
        
        layout->addWidget(iconLabel);
        layout->addWidget(textWidget, 1);
        layout->addWidget(playBtn);
        
        mradioList->addItem(item);
        mradioList->setItemWidget(item, stationWidget);
    }
}

void MyMusicPage::onRefreshClicked()
{
    loadRadioStations();
}

void MyMusicPage::onPlayRadioClicked()
{
    if (mallRadioStations.isEmpty()) {
        return;
    }
    
    int randomIndex = QRandomGenerator::global()->bounded(mallRadioStations.count());
    onPlayRadio(mallRadioStations[randomIndex].id);
}

void MyMusicPage::onSearchChanged(const QString &text)
{
    if (text.isEmpty()) {
        displayRadioStations(mallRadioStations);
        return;
    }
    
    QVector<TrackData> filtered;
    for (const TrackData &station : mallRadioStations) {
        if (station.title.contains(text, Qt::CaseInsensitive) ||
            station.artist.contains(text, Qt::CaseInsensitive)) {
            filtered.append(station);
        }
    }
    
    displayRadioStations(filtered);
}

void MyMusicPage::onRadioListContextMenu(const QPoint &pos)
{
    QListWidgetItem *item = mradioList->itemAt(pos);
    if (!item) return;
    
    int stationId = item->data(Qt::UserRole).toInt();
    
    QMenu menu(this);
    menu.setStyleSheet(R"(
        QMenu {
            background: #1A1A21;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 5px;
        }
        QMenu::item {
            background: transparent;
            color: white;
            padding: 8px 20px;
            border-radius: 4px;
        }
        QMenu::item:selected {
            background: rgba(138, 43, 226, 0.3);
        }
    )");
    
    QAction *playAction = menu.addAction("");
    QAction *deleteAction = menu.addAction("");
    
    QAction *selected = menu.exec(mradioList->mapToGlobal(pos));
    
    if (selected == playAction) {
        onPlayRadio(stationId);
    }
    else if (selected == deleteAction) {
        onDeleteRadio(stationId);
    }
}

void MyMusicPage::onPlayRadio(int stationId)
{
    for (const TrackData &station : mallRadioStations) {
        if (station.id == stationId) {
            qDebug() << "Playing radio station:" << station.title << station.streamUrl;
            mradioPlayer->setMedia(QUrl(station.streamUrl));
            mradioPlayer->play();
            return;
        }
    }
}

void MyMusicPage::onDeleteRadio(int stationId)
{
    if (DatabaseManager::instance().deleteRadioStation(stationId)) {
        loadRadioStations();
    }
}

void MyMusicPage::loadTracks()
{
}

void MyMusicPage::displayTracks(const QVector<TrackData> &tracks)
{
}

void MyMusicPage::onTrackDoubleClicked(QListWidgetItem *item)
{
}

void MyMusicPage::onTrackContextMenu(const QPoint &pos)
{
}

void MyMusicPage::onDeleteTrack(int trackId)
{
}

=== kursach/src/gui/MainWindow/pages/ProfilePage.h ===
#ifndef PROFILEPAGE_H
#define PROFILEPAGE_H

#include <QWidget>
#include <QLabel>
#include <QLineEdit>
#include <QPushButton>
#include <QTextEdit>
#include "core/models/User.h"

class UserManager;

class ProfilePage : public QWidget
{
    Q_OBJECT

public:
    explicit ProfilePage(int userId, QWidget *parent = nullptr);
    ~ProfilePage();

private slots:
    void onChangeAvatar();
    void onSaveProfile();
    void onChangePassword();

private:
    void setupUI();
    void loadUserData();
    void updateAvatar(const QPixmap& avatar);
    
    int m_userId;
    UserManager* m_userManager;
    
    QLabel* m_avatarLabel;
    QPushButton* m_changeAvatarButton;
    QLineEdit* m_usernameInput;
    QLineEdit* m_emailInput;
    QTextEdit* m_bioInput;
    QPushButton* m_saveButton;
    QPushButton* m_changePasswordButton;
    QLabel* m_statsLabel;
};

#endif


=== kursach/src/gui/MainWindow/pages/ProfilePage.cpp ===
#include "ProfilePage.h"
#include "core/models/Track.h"
#include "core/managers/UserManager.h"
#include "database/DatabaseManager.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QFileDialog>
#include <QMessageBox>
#include <QInputDialog>
#include <QPainter>
#include <QPainterPath>

ProfilePage::ProfilePage(int userId, QWidget *parent)
    : QWidget(parent)
    , m_userId(userId)
    , m_userManager(new UserManager(this))
{
    setupUI();
    loadUserData();
}

ProfilePage::~ProfilePage()
{
}

void ProfilePage::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(40, 40, 40, 40);
    mainLayout->setSpacing(30);
    
    QLabel* titleLabel = new QLabel("");
    titleLabel->setStyleSheet("color: white; font-size: 32px; font-weight: bold;");
    mainLayout->addWidget(titleLabel);
    
    QWidget* contentWidget = new QWidget();
    contentWidget->setMaximumWidth(600);
    QVBoxLayout* contentLayout = new QVBoxLayout(contentWidget);
    contentLayout->setSpacing(25);
    
    QWidget* avatarSection = new QWidget();
    QVBoxLayout* avatarLayout = new QVBoxLayout(avatarSection);
    avatarLayout->setAlignment(Qt::AlignCenter);
    avatarLayout->setSpacing(15);
    
    m_avatarLabel = new QLabel();
    m_avatarLabel->setFixedSize(150, 150);
    m_avatarLabel->setStyleSheet(R"(
        border: 3px solid #8A2BE2;
        border-radius: 75px;
        background: rgba(138, 43, 226, 0.1);
    )");
    m_avatarLabel->setAlignment(Qt::AlignCenter);
    
    m_changeAvatarButton = new QPushButton(" ");
    m_changeAvatarButton->setFixedWidth(180);
    m_changeAvatarButton->setStyleSheet(R"(
        QPushButton {
            background: rgba(138, 43, 226, 0.2);
            border: 1px solid #8A2BE2;
            color: #8A2BE2;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: rgba(138, 43, 226, 0.3);
        }
    )");
    
    avatarLayout->addWidget(m_avatarLabel);
    avatarLayout->addWidget(m_changeAvatarButton);
    
    contentLayout->addWidget(avatarSection);
    
    QWidget* formWidget = new QWidget();
    QVBoxLayout* formLayout = new QVBoxLayout(formWidget);
    formLayout->setSpacing(15);
    
    QLabel* usernameLabel = new QLabel(" ");
    usernameLabel->setStyleSheet("color: rgba(255, 255, 255, 0.7); font-size: 14px;");
    
    m_usernameInput = new QLineEdit();
    m_usernameInput->setReadOnly(true);
    m_usernameInput->setStyleSheet(R"(
        QLineEdit {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 12px 15px;
            color: white;
            font-size: 14px;
        }
    )");
    
    QLabel* emailLabel = new QLabel("Email");
    emailLabel->setStyleSheet("color: rgba(255, 255, 255, 0.7); font-size: 14px;");
    
    m_emailInput = new QLineEdit();
    m_emailInput->setStyleSheet(R"(
        QLineEdit {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 12px 15px;
            color: white;
            font-size: 14px;
        }
        QLineEdit:focus {
            border: 2px solid #8A2BE2;
        }
    )");
    
    QLabel* bioLabel = new QLabel(" ");
    bioLabel->setStyleSheet("color: rgba(255, 255, 255, 0.7); font-size: 14px;");
    
    m_bioInput = new QTextEdit();
    m_bioInput->setMaximumHeight(120);
    m_bioInput->setStyleSheet(R"(
        QTextEdit {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 12px 15px;
            color: white;
            font-size: 14px;
        }
        QTextEdit:focus {
            border: 2px solid #8A2BE2;
        }
    )");
    
    formLayout->addWidget(usernameLabel);
    formLayout->addWidget(m_usernameInput);
    formLayout->addWidget(emailLabel);
    formLayout->addWidget(m_emailInput);
    formLayout->addWidget(bioLabel);
    formLayout->addWidget(m_bioInput);
    
    contentLayout->addWidget(formWidget);
    
    m_statsLabel = new QLabel();
    m_statsLabel->setStyleSheet(R"(
        background: rgba(138, 43, 226, 0.1);
        border: 1px solid rgba(138, 43, 226, 0.3);
        border-radius: 10px;
        padding: 15px;
        color: white;
        font-size: 13px;
    )");
    contentLayout->addWidget(m_statsLabel);
    
    QWidget* buttonsWidget = new QWidget();
    QHBoxLayout* buttonsLayout = new QHBoxLayout(buttonsWidget);
    buttonsLayout->setSpacing(15);
    
    m_saveButton = new QPushButton(" ");
    m_saveButton->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 10px;
            padding: 12px 30px;
            font-weight: 600;
            font-size: 14px;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");
    
    m_changePasswordButton = new QPushButton(" ");
    m_changePasswordButton->setStyleSheet(R"(
        QPushButton {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 12px 30px;
            font-weight: 600;
            font-size: 14px;
        }
        QPushButton:hover {
            background: rgba(255, 255, 255, 0.15);
        }
    )");
    
    buttonsLayout->addWidget(m_saveButton);
    buttonsLayout->addWidget(m_changePasswordButton);
    buttonsLayout->addStretch();
    
    contentLayout->addWidget(buttonsWidget);
    
    mainLayout->addWidget(contentWidget);
    mainLayout->addStretch();
    
    connect(m_changeAvatarButton, &QPushButton::clicked, this, &ProfilePage::onChangeAvatar);
    connect(m_saveButton, &QPushButton::clicked, this, &ProfilePage::onSaveProfile);
    connect(m_changePasswordButton, &QPushButton::clicked, this, &ProfilePage::onChangePassword);
}

void ProfilePage::loadUserData()
{
    User user = m_userManager->getUser(m_userId);
    
    if (user.id == -1) return;
    
    m_usernameInput->setText(user.username);
    m_emailInput->setText(user.email);
    m_bioInput->setText(user.bio);
    
    if (!user.avatarPath.isEmpty()) {
        QPixmap avatar(user.avatarPath);
        if (!avatar.isNull()) {
            updateAvatar(avatar);
        } else {
            m_avatarLabel->setText(user.username.left(1).toUpper());
            m_avatarLabel->setStyleSheet(m_avatarLabel->styleSheet() + 
                "font-size: 60px; font-weight: bold; color: white;");
        }
    } else {
        m_avatarLabel->setText(user.username.left(1).toUpper());
        m_avatarLabel->setStyleSheet(m_avatarLabel->styleSheet() + 
            "font-size: 60px; font-weight: bold; color: white;");
    }
    
    QList<TrackData> tracks = DatabaseManager::instance().getUserTracks(m_userId);
    int totalTracks = tracks.size();
    int totalPlayCount = 0;
    
    for (const TrackData& track : tracks) {
        totalPlayCount += track.playCount;
    }
    
    QString stats = QString(
        "<b>:</b><br>"
        "  : %1<br>"
        " : %2<br>"
        " : %3"
    ).arg(totalTracks).arg(totalPlayCount).arg(user.createdAt.toString("dd.MM.yyyy"));
    
    m_statsLabel->setText(stats);
}

void ProfilePage::updateAvatar(const QPixmap& avatar)
{
    QPixmap scaled = avatar.scaled(150, 150, Qt::KeepAspectRatioByExpanding, Qt::SmoothTransformation);
    
    QPixmap rounded(150, 150);
    rounded.fill(Qt::transparent);
    
    QPainter painter(&rounded);
    painter.setRenderHint(QPainter::Antialiasing);
    
    QPainterPath path;
    path.addEllipse(0, 0, 150, 150);
    painter.setClipPath(path);
    
    painter.drawPixmap(0, 0, scaled);
    
    m_avatarLabel->setPixmap(rounded);
}

void ProfilePage::onChangeAvatar()
{
    QString fileName = QFileDialog::getOpenFileName(
        this,
        " ",
        QDir::homePath(),
        "Images (*.png *.jpg *.jpeg *.bmp)"
    );
    
    if (fileName.isEmpty()) return;
    
    QPixmap avatar(fileName);
    if (avatar.isNull()) {
        QMessageBox::warning(this, "", "   ");
        return;
    }
    
    QString avatarDir = "avatars";
    QDir().mkpath(avatarDir);
    
    QString avatarPath = QString("%1/user_%2.png").arg(avatarDir).arg(m_userId);
    
    if (avatar.save(avatarPath)) {
        if (m_userManager->updateAvatar(m_userId, avatarPath)) {
            updateAvatar(avatar);
            QMessageBox::information(this, "", " !");
        }
    }
}

void ProfilePage::onSaveProfile()
{
    QString email = m_emailInput->text().trimmed();
    QString bio = m_bioInput->toPlainText().trimmed();
    
    bool success = true;
    
    if (!email.isEmpty()) {
        success = success && m_userManager->updateEmail(m_userId, email);
    }
    
    success = success && m_userManager->updateBio(m_userId, bio);
    
    if (success) {
        QMessageBox::information(this, "", " !");
    } else {
        QMessageBox::warning(this, "", "   ");
    }
}

void ProfilePage::onChangePassword()
{
    bool ok;
    QString oldPassword = QInputDialog::getText(
        this,
        " ",
        "  :",
        QLineEdit::Password,
        "",
        &ok
    );
    
    if (!ok || oldPassword.isEmpty()) return;
    
    QString newPassword = QInputDialog::getText(
        this,
        " ",
        "   ( 6 ):",
        QLineEdit::Password,
        "",
        &ok
    );
    
    if (!ok || newPassword.length() < 6) {
        QMessageBox::warning(this, "", "    6 ");
        return;
    }
    
    QString confirmPassword = QInputDialog::getText(
        this,
        " ",
        "  :",
        QLineEdit::Password,
        "",
        &ok
    );
    
    if (!ok || newPassword != confirmPassword) {
        QMessageBox::warning(this, "", "  ");
        return;
    }
    
    QMessageBox::information(this, "", " !");
}


=== kursach/src/gui/MainWindow/pages/FriendsPage.h ===
#ifndef FRIENDSPAGE_H
#define FRIENDSPAGE_H

#include <QWidget>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLineEdit>
#include <QPushButton>
#include <QScrollArea>
#include <QStackedWidget>
#include "network/FriendManager.h"

class FriendsPage : public QWidget
{
    Q_OBJECT

public:
    explicit FriendsPage(int userId, QWidget *parent = nullptr);
    
    void refreshData();

signals:
    void openChatWithFriend(int friendId, const QString& friendName);

private slots:
    void onSearchClicked();
    void onShowFriends();
    void onShowRequests();
    void onAddFriend(int userId);
    void onAcceptRequest(int userId);
    void onRejectRequest(int userId);
    void onRemoveFriend(int userId);
    void onMessageFriend(int userId);

private:
    void setupUI();
    void loadFriends();
    void loadRequests();
    void searchUsers();
    void displaySearchResults(const QVector<User>& users);
    
    int m_userId;
    FriendManager* m_friendManager;
    
    QLineEdit* m_searchInput;
    QPushButton* m_friendsBtn;
    QPushButton* m_requestsBtn;
    QStackedWidget* m_stackedWidget;
    QScrollArea* m_friendsWidget;
    QScrollArea* m_requestsWidget;
    QScrollArea* m_searchWidget;
    QVBoxLayout* m_friendsLayout;
    QVBoxLayout* m_requestsLayout;
    QVBoxLayout* m_searchLayout;
};

#endif


=== kursach/src/gui/MainWindow/pages/MyMusicPage.h ===
#ifndef MYMUSICPAGEH
#define MYMUSICPAGEH

#include <QWidget>
#include <QListWidget>
#include <QPushButton>
#include <QLineEdit>
#include <QLabel>
#include <QMediaPlayer>
#include <core/models/Track.h>

class TrackManager;
class LocalFileHandler;
class AudioPlayer;

class MyMusicPage : public QWidget
{
    Q_OBJECT

public:
    explicit MyMusicPage(int userId, QWidget *parent = nullptr);
    ~MyMusicPage();

    void loadRadioStations();

signals:
    void playTrackRequested(const TrackData &track);

private slots:
    void onTrackDoubleClicked(QListWidgetItem *item);
    void onSearchChanged(const QString &text);
    void onTrackContextMenu(const QPoint &pos);
    void onDeleteTrack(int trackId);
    void onRefreshClicked();
    void onPlayRadioClicked();
    void onRadioListContextMenu(const QPoint &pos);
    void onPlayRadio(int stationId);
    void onDeleteRadio(int stationId);

private:
    void setupUI();
    void loadTracks();
    void displayTracks(const QVector<TrackData> &tracks);
    void displayRadioStations(const QVector<TrackData> &stations);

    int muserId;
    TrackManager *mtrackManager;
    LocalFileHandler *mfileHandler;
    AudioPlayer *maudioPlayer;
    QMediaPlayer *mradioPlayer;

    QLabel *mtitleLabel;
    QLabel *mstatsLabel;
    QPushButton *mrefreshButton;
    QPushButton *mplayRandomButton;
    QLineEdit *msearchEdit;
    QListWidget *mtracksList;
    QListWidget *mradioList;

    QVector<TrackData> mallTracks;
    QVector<TrackData> mallRadioStations;
};

#endif

=== kursach/src/gui/MainWindow/pages/PlaylistsPage.h ===
#ifndef PLAYLISTPAGE_H
#define PLAYLISTPAGE_H

#include <QWidget>
#include <QListWidget>
#include <QPushButton>
#include <QLabel>
#include <QVector>
#include "core/models/Playlist.h"
#include "core/models/Track.h"

class PlaylistManager;

class PlaylistPage : public QWidget
{
    Q_OBJECT

public:
    explicit PlaylistPage(int userId, QWidget *parent = nullptr);
    ~PlaylistPage();
    
    void loadPlaylists();

signals:
    void playTrackRequested(const TrackData& track);

private slots:
    void onCreatePlaylist();
    void onPlaylistSelected(QListWidgetItem* item);
    void onTrackDoubleClicked(QListWidgetItem* item);
    void onBackToPlaylists();

private:
    void setupUI();
    void displayPlaylists(const QVector<Playlist>& playlists);
    void displayPlaylistTracks(int playlistId);
    void showPlaylistsView();
    void showTracksView();
    
    int m_userId;
    int m_currentPlaylistId;
    PlaylistManager* m_playlistManager;
    
    QWidget* m_playlistsWidget;
    QWidget* m_tracksWidget;
    QListWidget* m_playlistsList;
    QListWidget* m_tracksList;
    QPushButton* m_createButton;
    QPushButton* m_backButton;
    QLabel* m_playlistTitleLabel;
};

#endif


=== kursach/src/gui/MainWindow/pages/SearchMusicPage.h ===
#ifndef SEARCHMUSICPAGE_H
#define SEARCHMUSICPAGE_H

#include <QWidget>
#include <QListWidget>
#include <QPushButton>
#include <QLineEdit>
#include <QLabel>
#include <QComboBox>
#include <QTextEdit>
#include <QVariant>
#include <QMediaPlayer>

class MusicAPIManager;

class SearchMusicPage : public QWidget
{
    Q_OBJECT

public:
    explicit SearchMusicPage(int userId, QWidget *parent = nullptr);
    ~SearchMusicPage();

signals:
    void stationAdded();

private slots:
    void onSearchClicked();
    void onTopStationsClicked();
    void onGenreChanged(const QString &genre);
    void onStationsFound(const QVariantList &stations);
    void onStationSelected(QListWidgetItem *item);
    void onStationContextMenu(const QPoint &pos);
    void onNetworkError(const QString &error);
    void playSelectedStation();
    void addSelectedStation();

private:
    void setupUI();
    void displayStations(const QVariantList &stations);

    int muserId;
    MusicAPIManager *mapiManager;
    QMediaPlayer *mradioPlayer;

    QLineEdit *msearchInput;
    QPushButton *msearchButton;
    QPushButton *mtopStationsButton;
    QComboBox *mgenreCombo;
    QListWidget *mstationsList;
    QTextEdit *mstationInfo;
    QLabel *mloadingLabel;

    QVariantList mcurrentStations;
    QVariantMap mcurrentSelectedStation;
    int mcurrentSelectedIndex;
};

#endif

=== kursach/src/gui/MainWindow/pages/PlaylistsPage.cpp ===
#include "PlaylistsPage.h"
#include "core/managers/PlaylistManager.h"
#include "gui/widgets/TrackListItem.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QInputDialog>
#include <QMessageBox>
#include <QMenu>
#include <QStackedWidget>

PlaylistPage::PlaylistPage(int userId, QWidget *parent)
    : QWidget(parent)
    , m_userId(userId)
    , m_currentPlaylistId(-1)
    , m_playlistManager(new PlaylistManager(userId, this))
{
    setupUI();
    loadPlaylists();
    
    connect(m_playlistManager, &PlaylistManager::playlistCreated, [this](int) {
        loadPlaylists();
    });
}

PlaylistPage::~PlaylistPage()
{
}

void PlaylistPage::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);
    
    QStackedWidget* stackedWidget = new QStackedWidget();
    
    m_playlistsWidget = new QWidget();
    QVBoxLayout* playlistsLayout = new QVBoxLayout(m_playlistsWidget);
    playlistsLayout->setContentsMargins(40, 40, 40, 40);
    playlistsLayout->setSpacing(25);
    
    QWidget* headerWidget = new QWidget();
    QHBoxLayout* headerLayout = new QHBoxLayout(headerWidget);
    headerLayout->setContentsMargins(0, 0, 0, 0);
    
    QLabel* titleLabel = new QLabel("");
    titleLabel->setStyleSheet("color: white; font-size: 32px; font-weight: bold;");
    
    m_createButton = new QPushButton("+  ");
    m_createButton->setFixedHeight(45);
    m_createButton->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 10px;
            padding: 0 25px;
            font-size: 14px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");
    
    headerLayout->addWidget(titleLabel);
    headerLayout->addStretch();
    headerLayout->addWidget(m_createButton);
    
    m_playlistsList = new QListWidget();
    m_playlistsList->setStyleSheet(R"(
        QListWidget {
            background: transparent;
            border: none;
            outline: none;
        }
        QListWidget::item {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 10px;
        }
        QListWidget::item:hover {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(138, 43, 226, 0.3);
        }
        QListWidget::item:selected {
            background: rgba(138, 43, 226, 0.15);
            border: 1px solid #8A2BE2;
        }
    )");
    
    playlistsLayout->addWidget(headerWidget);
    playlistsLayout->addWidget(m_playlistsList);
    
    m_tracksWidget = new QWidget();
    QVBoxLayout* tracksLayout = new QVBoxLayout(m_tracksWidget);
    tracksLayout->setContentsMargins(40, 40, 40, 40);
    tracksLayout->setSpacing(25);
    
    QWidget* tracksHeaderWidget = new QWidget();
    QHBoxLayout* tracksHeaderLayout = new QHBoxLayout(tracksHeaderWidget);
    tracksHeaderLayout->setContentsMargins(0, 0, 0, 0);
    
    m_backButton = new QPushButton(" ");
    m_backButton->setStyleSheet(R"(
        QPushButton {
            background: transparent;
            color: rgba(255, 255, 255, 0.7);
            border: none;
            font-size: 14px;
            padding: 10px;
        }
        QPushButton:hover {
            color: white;
        }
    )");
    
    m_playlistTitleLabel = new QLabel();
    m_playlistTitleLabel->setStyleSheet("color: white; font-size: 28px; font-weight: bold;");
    
    tracksHeaderLayout->addWidget(m_backButton);
    tracksHeaderLayout->addWidget(m_playlistTitleLabel);
    tracksHeaderLayout->addStretch();
    
    m_tracksList = new QListWidget();
    m_tracksList->setStyleSheet(R"(
        QListWidget {
            background: rgba(255, 255, 255, 0.02);
            border: 2px solid rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            outline: none;
            padding: 10px;
        }
        QListWidget::item {
            background: transparent;
            border: none;
        }
        QListWidget::item:hover {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }
    )");
    
    tracksLayout->addWidget(tracksHeaderWidget);
    tracksLayout->addWidget(m_tracksList);
    
    stackedWidget->addWidget(m_playlistsWidget);
    stackedWidget->addWidget(m_tracksWidget);
    
    mainLayout->addWidget(stackedWidget);
    
    connect(m_createButton, &QPushButton::clicked, this, &PlaylistPage::onCreatePlaylist);
    connect(m_playlistsList, &QListWidget::itemDoubleClicked, this, &PlaylistPage::onPlaylistSelected);
    connect(m_tracksList, &QListWidget::itemDoubleClicked, this, &PlaylistPage::onTrackDoubleClicked);
    connect(m_backButton, &QPushButton::clicked, this, &PlaylistPage::onBackToPlaylists);
}

void PlaylistPage::loadPlaylists()
{
    QVector<Playlist> playlists = m_playlistManager->getUserPlaylists();
    displayPlaylists(playlists);
}

void PlaylistPage::displayPlaylists(const QVector<Playlist>& playlists)
{
    m_playlistsList->clear();
    
    for (const Playlist& playlist : playlists) {
        QListWidgetItem* item = new QListWidgetItem();
        item->setData(Qt::UserRole, playlist.id);
        
        QString displayText = QString("  %1\n%2")
            .arg(playlist.name)
            .arg(playlist.createdAt);
        
        item->setText(displayText);
        item->setSizeHint(QSize(0, 80));
        
        m_playlistsList->addItem(item);
    }
}

void PlaylistPage::onCreatePlaylist()
{
    bool ok;
    QString name = QInputDialog::getText(
        this,
        " ",
        " :",
        QLineEdit::Normal,
        "",
        &ok
    );
    
    if (!ok || name.isEmpty()) return;
    
    QString description = QInputDialog::getText(
        this,
        " ",
        " ():",
        QLineEdit::Normal,
        "",
        &ok
    );
    
    int playlistId = m_playlistManager->createPlaylist(name, description);
    
    if (playlistId != -1) {
        QMessageBox::information(this, "", " !");
        loadPlaylists();
    } else {
        QMessageBox::warning(this, "", "   ");
    }
}

void PlaylistPage::onPlaylistSelected(QListWidgetItem* item)
{
    int playlistId = item->data(Qt::UserRole).toInt();
    m_currentPlaylistId = playlistId;
    
    Playlist playlist = m_playlistManager->getPlaylist(playlistId);
    m_playlistTitleLabel->setText(playlist.name);
    
    displayPlaylistTracks(playlistId);
    showTracksView();
}

void PlaylistPage::displayPlaylistTracks(int playlistId)
{
    m_tracksList->clear();
    
    QVector<TrackData> tracks = m_playlistManager->getPlaylistTracks(playlistId);
    
    if (tracks.isEmpty()) {
        QLabel* emptyLabel = new QLabel("     ");
        emptyLabel->setStyleSheet("color: rgba(255, 255, 255, 0.5); font-size: 16px;");
        emptyLabel->setAlignment(Qt::AlignCenter);
        
        QListWidgetItem* item = new QListWidgetItem(m_tracksList);
        item->setSizeHint(QSize(0, 100));
        m_tracksList->setItemWidget(item, emptyLabel);
        return;
    }
    
    for (const TrackData& track : tracks) {
        QListWidgetItem* item = new QListWidgetItem(m_tracksList);
        item->setData(Qt::UserRole, track.id);
        
        TrackListItem* trackWidget = new TrackListItem(track, true);
        
        connect(trackWidget, &TrackListItem::playClicked, [this, track]() {
            emit playTrackRequested(track);
        });
        
        connect(trackWidget, &TrackListItem::moreClicked, [this, track, playlistId](int trackId, const QPoint& pos) {
            QMenu menu(this);
            menu.setStyleSheet(R"(
                QMenu {
                    background: #1A1A21;
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    border-radius: 8px;
                    padding: 5px;
                }
                QMenu::item {
                    background: transparent;
                    color: white;
                    padding: 8px 20px;
                    border-radius: 4px;
                }
                QMenu::item:selected {
                    background: rgba(138, 43, 226, 0.3);
                }
            )");
            
            QAction* playAction = menu.addAction("");
            QAction* removeAction = menu.addAction("  ");
            
            QAction* selected = menu.exec(pos);
            
            if (selected == playAction) {
                emit playTrackRequested(track);
            } else if (selected == removeAction) {
                if (m_playlistManager->removeTrackFromPlaylist(playlistId, trackId)) {
                    displayPlaylistTracks(playlistId);
                }
            }
        });
        
        item->setSizeHint(trackWidget->sizeHint());
        m_tracksList->setItemWidget(item, trackWidget);
    }
}

void PlaylistPage::onTrackDoubleClicked(QListWidgetItem* item)
{
    int trackId = item->data(Qt::UserRole).toInt();
    
    QVector<TrackData> tracks = m_playlistManager->getPlaylistTracks(m_currentPlaylistId);
    
    for (const TrackData& track : tracks) {
        if (track.id == trackId) {
            emit playTrackRequested(track);
            break;
        }
    }
}

void PlaylistPage::onBackToPlaylists()
{
    showPlaylistsView();
}

void PlaylistPage::showPlaylistsView()
{
    QStackedWidget* stack = qobject_cast<QStackedWidget*>(layout()->itemAt(0)->widget());
    if (stack) {
        stack->setCurrentIndex(0);
    }
}

void PlaylistPage::showTracksView()
{
    QStackedWidget* stack = qobject_cast<QStackedWidget*>(layout()->itemAt(0)->widget());
    if (stack) {
        stack->setCurrentIndex(1);
    }
}


=== kursach/src/gui/MainWindow/MainWindow_Slots.cpp ===
#include "MainWindow.h"
#include "pages/FriendsPage.h"
#include "pages/MessagesPage.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QPushButton>
#include <QListWidgetItem>
#include <QMessageBox>
#include <QMenu>
#include <QApplication>
#include <QRandomGenerator>
#include <QDialog>
#include <QGraphicsDropShadowEffect>
#include "database/DatabaseManager.h"
#include "database/api/MusicAPIManager.h"
#include "audio/AudioPlayer.h"
#include "core/models/Track.h"


class ModernNotificationDialog : public QDialog
{
public:
    enum Type { Success, Error, Info };

    ModernNotificationDialog(const QString& message, Type type, QWidget* parent = nullptr)
        : QDialog(parent)
    {
        setWindowFlags(Qt::Dialog | Qt::FramelessWindowHint);
        setAttribute(Qt::WA_TranslucentBackground);
        setStyleSheet("background: transparent;");
        setFixedSize(420, 140);

        QString accentColor;
        QString icon;

        switch(type) {
            case Success:
                accentColor = "#2ECC71";
                icon = "";
                break;
            case Error:
                accentColor = "#E74C3C";
                icon = "";
                break;
            case Info:
            default:
                accentColor = "#3498DB";
                icon = "";
                break;
        }

        QVBoxLayout* mainLayout = new QVBoxLayout(this);
        mainLayout->setContentsMargins(0, 0, 0, 0);

        QWidget* container = new QWidget();
        container->setStyleSheet(QString(R"(
            QWidget {
                background: #0F0F14;
                border: 1px solid rgba(%1, 0.3);
                border-radius: 12px;
            }
        )").arg(accentColor.mid(1)));

        QVBoxLayout* containerLayout = new QVBoxLayout(container);
        containerLayout->setContentsMargins(0, 0, 0, 0);
        containerLayout->setSpacing(0);

        QWidget* header = new QWidget();
        header->setFixedHeight(50);
        header->setStyleSheet(QString(R"(
            QWidget {
                background: rgba(%1, 0.1);
                border-bottom: 1px solid rgba(%1, 0.2);
                border-radius: 12px 12px 0px 0px;
            }
        )").arg(accentColor.mid(1)));

        QHBoxLayout* headerLayout = new QHBoxLayout(header);
        headerLayout->setContentsMargins(15, 0, 15, 0);

        QLabel* iconLabel = new QLabel(icon);
        iconLabel->setStyleSheet(QString(R"(
            QLabel {
                color: %1;
                font-size: 20px;
                font-weight: bold;
                min-width: 30px;
                background: transparent;
                border: none;
            }
        )").arg(accentColor));

        QLabel* titleLabel = new QLabel("");
        titleLabel->setStyleSheet(QString(R"(
            QLabel {
                color: %1;
                font-size: 14px;
                font-weight: 600;
                background: transparent;
                border: none;
            }
        )").arg(accentColor));

        headerLayout->addWidget(iconLabel);
        headerLayout->addWidget(titleLabel);
        headerLayout->addStretch();

        QWidget* body = new QWidget();
        body->setStyleSheet("background: transparent;");
        QVBoxLayout* bodyLayout = new QVBoxLayout(body);
        bodyLayout->setContentsMargins(20, 15, 20, 15);
        bodyLayout->setSpacing(12);

        QLabel* messageLabel = new QLabel(message);
        messageLabel->setStyleSheet(R"(
            QLabel {
                color: rgba(255, 255, 255, 0.85);
                font-size: 13px;
                font-weight: 400;
                background: transparent;
                border: none;
            }
        )");
        messageLabel->setWordWrap(true);

        bodyLayout->addWidget(messageLabel);

        QWidget* footer = new QWidget();
        footer->setFixedHeight(45);
        footer->setStyleSheet("background: transparent;");
        QHBoxLayout* footerLayout = new QHBoxLayout(footer);
        footerLayout->setContentsMargins(15, 0, 15, 0);
        footerLayout->setSpacing(10);

        QPushButton* okBtn = new QPushButton("OK");
        okBtn->setFixedWidth(100);
        okBtn->setFixedHeight(35);
        okBtn->setStyleSheet(QString(R"(
            QPushButton {
                background: %1;
                color: white;
                border: none;
                border-radius: 6px;
                font-size: 13px;
                font-weight: 600;
            }
            QPushButton:hover {
                background: rgba(%2, 0.8);
            }
            QPushButton:pressed {
                background: rgba(%2, 0.7);
            }
        )").arg(accentColor).arg(accentColor.mid(1)));

        connect(okBtn, &QPushButton::clicked, this, &QDialog::accept);

        footerLayout->addStretch();
        footerLayout->addWidget(okBtn);

        containerLayout->addWidget(header);
        containerLayout->addWidget(body);
        containerLayout->addWidget(footer);

        mainLayout->addWidget(container);

        QGraphicsDropShadowEffect* shadow = new QGraphicsDropShadowEffect();
        shadow->setBlurRadius(15);
        shadow->setColor(QColor(0, 0, 0, 60));
        shadow->setOffset(0, 4);
        container->setGraphicsEffect(shadow);
    }
};


void MainWindow::setupConnections()
{
    connect(myMusicBtn, &QPushButton::clicked, this, [this]() {
        mainStack->setCurrentIndex(MYMUSICPAGE);
    });

    connect(profileBtn, &QPushButton::clicked, this, [this]() {
        mainStack->setCurrentIndex(PROFILEPAGE);
    });

    connect(messagesBtn, &QPushButton::clicked, this, [this]() {
        mainStack->setCurrentIndex(MESSAGESPAGE);
    });

    connect(friendsBtn, &QPushButton::clicked, this, [this]() {
        mainStack->setCurrentIndex(FRIENDSPAGE);
    });

    connect(notificationsBtn, &QPushButton::clicked, this, [this]() {
        mainStack->setCurrentIndex(NOTIFICATIONSPAGE);
    });

    connect(playlistBtn, &QPushButton::clicked, this, [this]() {
        mainStack->setCurrentIndex(PLAYLISTPAGE);
    });

    connect(musicSearchBtn, &QPushButton::clicked, this, [this]() {
        mainStack->setCurrentIndex(MUSICPAGE);
    });

    connect(roomsBtn, &QPushButton::clicked, this, [this]() {
        mainStack->setCurrentIndex(ROOMSPAGE);
    });

    connect(avatarButton, &QPushButton::clicked, this, &MainWindow::changeAvatar);
}


void MainWindow::playRadio(int radioId)
{
    QList<TrackData> radioList = DatabaseManager::instance().getUserTracks(currentUserId);

    for (const TrackData& radio : radioList) {
        if (radio.id == radioId) {
            audioPlayer->updateTrackInfo(radio.title, radio.artist);

            if (radio.filePath.startsWith("lastfm://")) {
                ModernNotificationDialog dialog(QString(" '%1 - %2'  - Last.fm.     URL   Last.fm API.").arg(radio.artist).arg(radio.title), ModernNotificationDialog::Info, this);
                dialog.exec();
                return;
            }

            if (QFile::exists(radio.filePath)) {
                audioPlayer->playTrack(radio.filePath);
                DatabaseManager::instance().incrementPlayCount(radioId);
            } else {
                ModernNotificationDialog dialog("  : " + radio.filePath, ModernNotificationDialog::Error, this);
                dialog.exec();
            }
            break;
        }
    }
}


void MainWindow::onPlaylistItemClicked(QListWidgetItem *item)
{
    if (item) {
        int radioId = item->data(Qt::UserRole).toInt();
        playRadio(radioId);
    }
}


void MainWindow::onRadioDeleteRequested(int radioId)
{
    bool success = DatabaseManager::instance().deleteTrack(radioId);

    if (success) {
        ModernNotificationDialog dialog("   !", ModernNotificationDialog::Success, this);
        dialog.exec();
    } else {
        ModernNotificationDialog dialog("   ", ModernNotificationDialog::Error, this);
        dialog.exec();
    }
}


void MainWindow::loadUserRadio()
{
    qDebug() << "loadUserRadio:  ,  MyMusicPage  ";
}


void MainWindow::showProfilePage() { mainStack->setCurrentIndex(PROFILEPAGE); }
void MainWindow::showMessagesPage() { mainStack->setCurrentIndex(MESSAGESPAGE); }
void MainWindow::showFriendsPage() { mainStack->setCurrentIndex(FRIENDSPAGE); }
void MainWindow::showNotificationsPage() { mainStack->setCurrentIndex(NOTIFICATIONSPAGE); }
void MainWindow::showPlaylistPage() { mainStack->setCurrentIndex(PLAYLISTPAGE); }
void MainWindow::showRoomsPage() { mainStack->setCurrentIndex(ROOMSPAGE); }


void MainWindow::onRadioStationAdded()
{
    qDebug() << "onRadioStationAdded:  ,    userId:" << currentUserId;
}

=== kursach/src/gui/MainWindow/MainWindow_Pages.cpp ===
#include <gui/MainWindow/MainWindow.h>
#include <gui/MainWindow/pages/FriendsPage.h>
#include <gui/MainWindow/pages/MessagesPage.h>
#include <gui/MainWindow/pages/MyMusicPage.h>
#include <gui/MainWindow/pages/SearchMusicPage.h>
#include <gui/MainWindow/pages/RoomsPage.h>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QPushButton>
#include <QStackedWidget>
#include <QDebug>

void MainWindow::createPages()
{
    mainStack = new QStackedWidget();
    mainStack->setStyleSheet(R"(
        QStackedWidget {
            background: #0F0F14;
        }
    )");

    MyMusicPage *myMusicPage = new MyMusicPage(currentUserId, this);
    SearchMusicPage *musicSearchPage = new SearchMusicPage(currentUserId, this);
    FriendsPage *friendsPage = new FriendsPage(currentUserId, this);
    MessagesPage *messagesPage = new MessagesPage(currentUserId, this);

    MessagesPage *messagesPagePtr = dynamic_cast<MessagesPage*>(messagesPage);
    FriendsPage *friendsPagePtr = dynamic_cast<FriendsPage*>(friendsPage);

    if (friendsPagePtr && messagesPagePtr) {
        connect(friendsPagePtr, &FriendsPage::openChatWithFriend, this, [this, messagesPagePtr](int friendId, const QString &friendName) {
            messagesPagePtr->openChat(friendId, friendName);
            mainStack->setCurrentWidget(messagesPagePtr);
        });
    }

    QWidget *profilePage = createSimplePage("", "   ");
    QWidget *notificationsPage = createSimplePage("", "  ");
    QWidget *playlistPage = createSimplePage("", "  ");
    RoomsPage *roomsPage = new RoomsPage(currentUserId, this);

    mainStack->addWidget(myMusicPage);
    mainStack->addWidget(profilePage);
    mainStack->addWidget(messagesPage);
    mainStack->addWidget(friendsPage);
    mainStack->addWidget(notificationsPage);
    mainStack->addWidget(playlistPage);
    mainStack->addWidget(musicSearchPage);
    mainStack->addWidget(roomsPage);

    connect(musicSearchPage, &SearchMusicPage::stationAdded, this, &MainWindow::onRadioStationAdded);

    qDebug() << "createPages:       userId:" << currentUserId;
}

QWidget* MainWindow::createSimplePage(const QString &title, const QString &description)
{
    QWidget *page = new QWidget();
    QVBoxLayout *layout = new QVBoxLayout(page);
    layout->setContentsMargins(40, 40, 40, 40);

    QLabel *titleLabel = new QLabel(title);
    titleLabel->setStyleSheet(R"(
        QLabel {
            color: #FFFFFF;
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            background: transparent;
            border: none;
        }
    )");

    QLabel *descLabel = new QLabel(description);
    descLabel->setStyleSheet(R"(
        QLabel {
            color: rgba(255, 255, 255, 0.5);
            font-size: 16px;
            text-align: center;
            background: transparent;
            border: none;
        }
    )");

    layout->addStretch();
    layout->addWidget(titleLabel);
    layout->addWidget(descLabel);
    layout->addStretch();

    return page;
}

=== kursach/src/gui/MainWindow/MainWindow_Avatar.cpp ===
#include "MainWindow.h"
#include "pages/FriendsPage.h"
#include "pages/MessagesPage.h"
#include <QVBoxLayout>
#include <QInputDialog>
#include <QHBoxLayout>
#include <QStackedWidget>
#include <QLabel>
#include <QPushButton>
#include <QFrame>
#include <QLineEdit>
#include <QListWidget>
#include <QTextEdit>
#include <QListWidgetItem>
#include <QFileDialog>
#include <QMessageBox>
#include <QDir>
#include <QFile>
#include <QPixmap>
#include <QPainter>
#include <QPainterPath>
#include <QToolButton>
#include <QTimer>
#include <QApplication>
#include <QMenu>
#include <QEvent>
#include <QScrollArea>
#include <QScrollBar>
#include <QDebug>
#include "database/DatabaseManager.h"
#include "database/api/MusicAPIManager.h"
#include "audio/AudioPlayer.h"
#include "core/models/Track.h"

void MainWindow::setupAvatar()
{
    setDefaultAvatar();
}

void MainWindow::setAvatarPixmap(const QPixmap& pixmap)
{
    QPixmap scaledPixmap = pixmap.scaled(100, 100, Qt::KeepAspectRatioByExpanding, Qt::SmoothTransformation);

    QPixmap circularPixmap(100, 100);
    circularPixmap.fill(Qt::transparent);

    QPainter painter(&circularPixmap);
    painter.setRenderHint(QPainter::Antialiasing, true);
    painter.setRenderHint(QPainter::SmoothPixmapTransform, true);

    QPainterPath path;
    path.addEllipse(0, 0, 100, 100);
    painter.setClipPath(path);

    int x = (100 - scaledPixmap.width()) / 2;
    int y = (100 - scaledPixmap.height()) / 2;
    painter.drawPixmap(x, y, scaledPixmap);

    avatarButton->setIcon(QIcon(circularPixmap));
    avatarButton->setIconSize(QSize(100, 100));
    avatarButton->setText("");
}

void MainWindow::setDefaultAvatar()
{
    QPixmap defaultPixmap(100, 100);
    defaultPixmap.fill(Qt::transparent);

    QPainter painter(&defaultPixmap);
    painter.setRenderHint(QPainter::Antialiasing, true);

    QPainterPath circlePath;
    circlePath.addEllipse(0, 0, 100, 100);
    painter.setClipPath(circlePath);

    QRadialGradient gradient(50, 50, 50);
    gradient.setColorAt(0, QColor("#9B4BFF"));
    gradient.setColorAt(1, QColor("#7B1FA2"));

    painter.setBrush(QBrush(gradient));
    painter.setPen(Qt::NoPen);
    painter.drawEllipse(0, 0, 100, 100);

    painter.setPen(QPen(Qt::white, 2));
    painter.setFont(QFont("Arial", 24, QFont::Bold));

    QString initials = currentUsername.left(2).toUpper();
    painter.drawText(QRect(0, 0, 100, 100), Qt::AlignCenter, initials);

    avatarButton->setIcon(QIcon(defaultPixmap));
    avatarButton->setIconSize(QSize(100, 100));
    avatarButton->setText("");
}

void MainWindow::changeAvatar()
{
    QString filePath = QFileDialog::getOpenFileName(
        this,
        "   ",
        QDir::homePath(),
        "Images (*.png *.jpg *.jpeg *.bmp *.gif)"
    );

    if (!filePath.isEmpty()) {
        QPixmap newAvatar(filePath);
        if (newAvatar.isNull()) {
            QMessageBox msgBox;
            msgBox.setWindowTitle("");
            msgBox.setText("   ");
            msgBox.setStyleSheet(R"(
                QMessageBox {
                    background-color: #1A1A21;
                    color: white;
                }
                QMessageBox QLabel {
                    color: white;
                }
                QMessageBox QPushButton {
                    background-color: #8A2BE2;
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 6px;
                    min-width: 60px;
                }
                QMessageBox QPushButton:hover {
                    background-color: #9B4BFF;
                }
            )");
            msgBox.exec();
            return;
        }

        saveAvatar(newAvatar);
        setAvatarPixmap(newAvatar);

        QMessageBox msgBox;
        msgBox.setWindowTitle("");
        msgBox.setText("  !");
        msgBox.setStyleSheet(R"(
            QMessageBox {
                background-color: #1A1A21;
                color: white;
            }
            QMessageBox QLabel {
                color: white;
            }
            QMessageBox QPushButton {
                background-color: #8A2BE2;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 6px;
                min-width: 60px;
            }
            QMessageBox QPushButton:hover {
                background-color: #9B4BFF;
            }
        )");
        msgBox.exec();
    }
}

void MainWindow::saveAvatar(const QPixmap& avatar)
{
    QDir dir("avatars");
    if (!dir.exists()) {
        dir.mkpath(".");
    }

    QString filePath = QString("avatars/user_%1.png").arg(currentUserId);

    if (!avatar.save(filePath, "PNG", 100)) {
        qDebug() << "   :" << filePath;
    } else {
        qDebug() << " :" << filePath;
    }
}

void MainWindow::loadUserAvatar()
{
    QString userAvatarPath = QString("avatars/user_%1.png").arg(currentUserId);
    QFile avatarFile(userAvatarPath);

    if (avatarFile.exists()) {
        QPixmap avatarPixmap(userAvatarPath);
        if (!avatarPixmap.isNull()) {
            setAvatarPixmap(avatarPixmap);
            return;
        }
    }

    setDefaultAvatar();
}

void MainWindow::showAvatarOverlay()
{
    if (!avatarOverlay) {
        avatarOverlay = new QLabel(avatarButton);
        avatarOverlay->setText("\n?");
        avatarOverlay->setStyleSheet(R"(
            QLabel {
                background-color: rgba(0, 0, 0, 0.85);
                color: white;
                font-weight: 600;
                font-size: 12px;
                border-radius: 50px;
                border: 2px solid rgba(138, 43, 226, 0.5);
                text-align: center;
                padding: 5px;
            }
        )");
        avatarOverlay->setAlignment(Qt::AlignCenter);

        avatarOverlay->setFixedSize(100, 100);

        avatarOverlay->move(0, 0);

        avatarOverlay->setAttribute(Qt::WA_TransparentForMouseEvents);
    }

    avatarOverlay->show();
    avatarOverlay->raise();
}

void MainWindow::hideAvatarOverlay()
{
    if (avatarOverlay) {
        avatarOverlay->hide();
    }
}

void MainWindow::onAvatarButtonEnter()
{
    showAvatarOverlay();
}

void MainWindow::onAvatarButtonLeave()
{
    hideAvatarOverlay();
}

=== kursach/src/gui/MainWindow/MainWindow_UI.cpp ===
#include "MainWindow.h"
#include "pages/FriendsPage.h"
#include "pages/MessagesPage.h"
#include <QVBoxLayout>
#include <QInputDialog>
#include <QHBoxLayout>
#include <QStackedWidget>
#include <QLabel>
#include <QPushButton>
#include <QFrame>
#include <QLineEdit>
#include <QListWidget>
#include <QTextEdit>
#include <QListWidgetItem>
#include <QFileDialog>
#include <QMessageBox>
#include <QDir>
#include <QFile>
#include <QPixmap>
#include <QPainter>
#include <QPainterPath>
#include <QToolButton>
#include <QTimer>
#include <QApplication>
#include <QMenu>
#include <QEvent>
#include <QScrollArea>
#include <QScrollBar>
#include <QDebug>
#include "database/DatabaseManager.h"
#include "database/api/MusicAPIManager.h"
#include "audio/AudioPlayer.h"
#include "core/models/Track.h"

void MainWindow::setupUI()
{
    QWidget *centralWidget = new QWidget();
    centralWidget->setObjectName("windowContent");
    centralWidget->setStyleSheet(R"(
        #windowContent {
            background-color: #0F0F14;
            border-radius: 0;
        }
    )");

    QVBoxLayout *mainLayout = new QVBoxLayout(centralWidget);
    mainLayout->setSpacing(0);
    mainLayout->setContentsMargins(0, 0, 0, 0);

    QWidget *titleBar = new QWidget();
    titleBar->setFixedHeight(40);
    titleBar->setStyleSheet(R"(
        QWidget {
            background: rgba(15, 15, 20, 0.8);
            border-top-left-radius: 0;
            border-top-right-radius: 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
    )");

    QHBoxLayout *titleLayout = new QHBoxLayout(titleBar);
    titleLayout->setContentsMargins(20, 0, 20, 0);

    QLabel *titleLabel = new QLabel("Chorus");
    titleLabel->setStyleSheet(R"(
        QLabel {
            color: #8A2BE2;
            font-size: 16px;
            font-weight: bold;
            opacity: 0.9;
        }
    )");

    QWidget *windowButtons = new QWidget();
    QHBoxLayout *buttonsLayout = new QHBoxLayout(windowButtons);
    buttonsLayout->setContentsMargins(0, 0, 0, 0);
    buttonsLayout->setSpacing(5);

    QPushButton *minimizeBtn = new QPushButton("-");
    QPushButton *maximizeBtn = new QPushButton("[]");
    QPushButton *closeBtn = new QPushButton("x");

    QString windowBtnStyle = R"(
        QPushButton {
            background: transparent;
            color: rgba(255, 255, 255, 0.6);
            border: none;
            font-size: 16px;
            padding: 0;
            min-width: 28px;
            min-height: 28px;
            border-radius: 4px;
            font-weight: 300;
        }
        QPushButton:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        QPushButton#closeBtn:hover {
            background: #FF4444;
            color: white;
        }
    )";

    minimizeBtn->setStyleSheet(windowBtnStyle);
    maximizeBtn->setStyleSheet(windowBtnStyle);
    closeBtn->setStyleSheet(windowBtnStyle);
    closeBtn->setObjectName("closeBtn");

    buttonsLayout->addWidget(minimizeBtn);
    buttonsLayout->addWidget(maximizeBtn);
    buttonsLayout->addWidget(closeBtn);

    titleLayout->addWidget(titleLabel);
    titleLayout->addStretch();
    titleLayout->addWidget(windowButtons);

    connect(minimizeBtn, &QPushButton::clicked, this, &QMainWindow::showMinimized);
    connect(closeBtn, &QPushButton::clicked, this, &QMainWindow::close);
    connect(maximizeBtn, &QPushButton::clicked, this, [this]() {
        if (isMaximized()) {
            showNormal();
        } else {
            showMaximized();
        }
    });

    QHBoxLayout *contentLayout = new QHBoxLayout();
    contentLayout->setSpacing(0);
    contentLayout->setContentsMargins(0, 0, 0, 0);

    createSidebar();
    contentLayout->addWidget(sidebar);

    createPages();
    contentLayout->addWidget(mainStack, 1);

    mainLayout->addWidget(titleBar);
    mainLayout->addLayout(contentLayout, 1);

    audioPlayer->setupPlayerControls(centralWidget);
    mainLayout->addWidget(audioPlayer->getPlayerControls());

    setCentralWidget(centralWidget);
}

void MainWindow::createSidebar()
{
    sidebar = new QWidget();
    sidebar->setFixedWidth(280);
    sidebar->setStyleSheet(R"(
        QWidget {
            background: #0F0F14;
            border-right: 1px solid rgba(255, 255, 255, 0.05);
        }
    )");

    QVBoxLayout *sidebarLayout = new QVBoxLayout(sidebar);
    sidebarLayout->setContentsMargins(0, 0, 0, 0);
    sidebarLayout->setSpacing(0);

    QWidget *logoSection = new QWidget();
    logoSection->setFixedHeight(70);
    logoSection->setStyleSheet(R"(
        QWidget {
            background: rgba(138, 43, 226, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
    )");

    QHBoxLayout *logoLayout = new QHBoxLayout(logoSection);
    logoLayout->setContentsMargins(20, 0, 20, 0);

    QLabel *logoLabel = new QLabel("Chorus");
    logoLabel->setStyleSheet(R"(
        QLabel {
            color: #8A2BE2;
            font-size: 22px;
            font-weight: 800;
        }
    )");

    logoLayout->addWidget(logoLabel);
    sidebarLayout->addWidget(logoSection);

    QWidget *profileSection = new QWidget();
    profileSection->setStyleSheet(R"(
        QWidget {
            background: transparent;
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
    )");

    QVBoxLayout *profileLayout = new QVBoxLayout(profileSection);
    profileLayout->setContentsMargins(0, 0, 0, 0);
    profileLayout->setSpacing(15);
    profileLayout->setAlignment(Qt::AlignTop);

    avatarButton = new QPushButton();
    avatarButton->setFixedSize(100, 100);
    avatarButton->setStyleSheet(R"(
        QPushButton {
            border: 3px solid #8A2BE2;
            border-radius: 50px;
            padding: 0;
            background: transparent;
        }
        QPushButton:hover {
            border-color: #9B4BFF;
            background: rgba(138, 43, 226, 0.1);
        }
    )");

    QGraphicsDropShadowEffect *avatarEffect = new QGraphicsDropShadowEffect();
    avatarEffect->setBlurRadius(20);
    avatarEffect->setColor(QColor(138, 43, 226, 100));
    avatarEffect->setOffset(0, 0);
    avatarButton->setGraphicsEffect(avatarEffect);

    usernameLabel = new QLabel(currentUsername);
    usernameLabel->setStyleSheet(R"(
        QLabel {
            color: #FFFFFF;
            font-size: 18px;
            font-weight: 600;
            text-align: center;
            padding: 10px 0 5px 0;
        }
    )");
    usernameLabel->setWordWrap(true);
    usernameLabel->setMaximumWidth(260);

    QToolButton *statusButton = new QToolButton();
    statusButton->setText("");
    statusButton->setObjectName("statusButton");
    statusButton->setToolButtonStyle(Qt::ToolButtonTextOnly);
    statusButton->setArrowType(Qt::NoArrow);
    statusButton->setStyleSheet(R"(
        QToolButton {
            color: #4CAF50;
            font-size: 14px;
            font-weight: 500;
            background: transparent;
            border: 1px solid rgba(76, 175, 80, 0.3);
            border-radius: 12px;
            padding: 6px 15px;
            margin: 0 70px;
        }
        QToolButton:hover {
            background: rgba(76, 175, 80, 0.1);
        }
        QToolButton::menu-indicator {
            width: 0px;
        }
    )");
    statusButton->setCursor(Qt::PointingHandCursor);

    profileLayout->addWidget(avatarButton, 0, Qt::AlignHCenter);
    profileLayout->addWidget(usernameLabel, 0, Qt::AlignHCenter);
    profileLayout->addWidget(statusButton, 0, Qt::AlignHCenter);
    sidebarLayout->addWidget(profileSection);

    QWidget *navSection = new QWidget();
    navSection->setStyleSheet("background: transparent;");

    QVBoxLayout *navLayout = new QVBoxLayout(navSection);
    navLayout->setContentsMargins(15, 20, 15, 20);
    navLayout->setSpacing(3);

    QString navButtonStyle = R"(
        QPushButton {
            background: transparent;
            color: rgba(255, 255, 255, 0.8);
            border: none;
            text-align: left;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            border-radius: 8px;
            min-height: 45px;
        }
        QPushButton:hover {
            color: #FFFFFF;
            background: rgba(138, 43, 226, 0.15);
            padding-left: 25px;
        }
        QPushButton:pressed {
            background: rgba(138, 43, 226, 0.25);
        }
    )";

    myMusicBtn = new QPushButton(" ");
    profileBtn = new QPushButton("");
    musicSearchBtn = new QPushButton(" ");
    playlistBtn = new QPushButton(" ");
    friendsBtn = new QPushButton("");
    messagesBtn = new QPushButton("");
    notificationsBtn = new QPushButton("");
    roomsBtn = new QPushButton("");

    QList<QPushButton*> navButtons = {
        myMusicBtn, profileBtn, musicSearchBtn, playlistBtn,
        friendsBtn, messagesBtn, notificationsBtn, roomsBtn
    };

    for (auto btn : navButtons) {
        btn->setStyleSheet(navButtonStyle);
        btn->setCursor(Qt::PointingHandCursor);
        navLayout->addWidget(btn);
    }

    navLayout->addStretch();
    sidebarLayout->addWidget(navSection, 1);

    QWidget *bottomSection = new QWidget();
    bottomSection->setStyleSheet(R"(
        QWidget {
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }
    )");

    QPushButton *logoutBtn = new QPushButton("");
    logoutBtn->setObjectName("logoutBtn");
    logoutBtn->setStyleSheet(R"(
        QPushButton {
            background: rgba(255, 68, 68, 0.1);
            border: 1px solid rgba(255, 68, 68, 0.3);
            color: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            padding: 12px;
            font-size: 14px;
            font-weight: 500;
            width: 100%;
            min-height: 45px;
        }
        QPushButton:hover {
            background: rgba(255, 68, 68, 0.2);
            color: #FFFFFF;
        }
    )");
    connect(logoutBtn, &QPushButton::clicked, this, &QMainWindow::close);

    QVBoxLayout *bottomLayout = new QVBoxLayout(bottomSection);
    bottomLayout->setContentsMargins(0, 0, 0, 0);
    bottomLayout->addWidget(logoutBtn);

    sidebarLayout->addWidget(bottomSection);

    QMenu *statusMenu = new QMenu(this);
    statusMenu->setStyleSheet(R"(
        QMenu {
            background-color: #1A1A21;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 5px;
        }
        QMenu::item {
            background-color: transparent;
            color: rgba(255, 255, 255, 0.8);
            padding: 8px 25px;
            border-radius: 4px;
            margin: 2px;
            font-size: 14px;
            min-height: 30px;
        }
        QMenu::item:selected {
            background-color: rgba(138, 43, 226, 0.3);
            color: #8A2BE2;
        }
    )");

    QAction *onlineAction = new QAction("", this);
    QAction *awayAction = new QAction("", this);
    QAction *dndAction = new QAction(" ", this);
    QAction *invisibleAction = new QAction("", this);

    statusMenu->addAction(onlineAction);
    statusMenu->addAction(awayAction);
    statusMenu->addAction(dndAction);
    statusMenu->addAction(invisibleAction);

    statusButton->setMenu(statusMenu);
    statusButton->setPopupMode(QToolButton::InstantPopup);

    connect(onlineAction, &QAction::triggered, [statusButton]() {
        statusButton->setText("");
        statusButton->setStyleSheet(R"(
            QToolButton {
                color: #4CAF50;
                font-size: 14px;
                font-weight: 500;
                background: transparent;
                border: 1px solid rgba(76, 175, 80, 0.3);
                border-radius: 12px;
                padding: 6px 15px;
                margin: 0 70px;
            }
            QToolButton:hover {
                background: rgba(76, 175, 80, 0.1);
            }
            QToolButton::menu-indicator {
                width: 0px;
            }
        )");
    });

    connect(awayAction, &QAction::triggered, [statusButton]() {
        statusButton->setText("");
        statusButton->setStyleSheet(R"(
            QToolButton {
                color: #FFC107;
                font-size: 14px;
                font-weight: 500;
                background: transparent;
                border: 1px solid rgba(255, 193, 7, 0.3);
                border-radius: 12px;
                padding: 6px 15px;
                margin: 0 70px;
            }
            QToolButton:hover {
                background: rgba(255, 193, 7, 0.1);
            }
            QToolButton::menu-indicator {
                width: 0px;
            }
        )");
    });

    connect(dndAction, &QAction::triggered, [statusButton]() {
        statusButton->setText(" ");
        statusButton->setStyleSheet(R"(
            QToolButton {
                color: #F44336;
                font-size: 14px;
                font-weight: 500;
                background: transparent;
                border: 1px solid rgba(244, 67, 54, 0.3);
                border-radius: 12px;
                padding: 6px 15px;
                margin: 0 70px;
            }
            QToolButton:hover {
                background: rgba(244, 67, 54, 0.1);
            }
            QToolButton::menu-indicator {
                width: 0px;
            }
        )");
    });

    connect(invisibleAction, &QAction::triggered, [statusButton]() {
        statusButton->setText("");
        statusButton->setStyleSheet(R"(
            QToolButton {
                color: #9E9E9E;
                font-size: 14px;
                font-weight: 500;
                background: transparent;
                border: 1px solid rgba(158, 158, 158, 0.3);
                border-radius: 12px;
                padding: 6px 15px;
                margin: 0 70px;
            }
            QToolButton:hover {
                background: rgba(158, 158, 158, 0.1);
            }
            QToolButton::menu-indicator {
                width: 0px;
            }
        )");
    });
}

=== kursach/src/gui/MainWindow/MainWindow.cpp ===
#include <gui/MainWindow/MainWindow.h>
#include "pages/FriendsPage.h"
#include "pages/MessagesPage.h"
#include <QVBoxLayout>
#include <QInputDialog>
#include <QHBoxLayout>
#include <QStackedWidget>
#include <QLabel>
#include <QPushButton>
#include <QFrame>
#include <QLineEdit>
#include <QListWidget>
#include <QTextEdit>
#include <QListWidgetItem>
#include <QFileDialog>
#include <QMessageBox>
#include <QDir>
#include <QFile>
#include <QPixmap>
#include <QPainter>
#include <QPainterPath>
#include <QToolButton>
#include <QTimer>
#include <QApplication>
#include <QMenu>
#include <QEvent>
#include <QScrollArea>
#include <QScrollBar>
#include <QDebug>
#include "database/DatabaseManager.h"
#include "database/api/MusicAPIManager.h"
#include "audio/AudioPlayer.h"
#include "core/models/Track.h"

MainWindow::MainWindow(const QString &username, int userId, QWidget *parent)
    : FramelessWindow(parent)
    , currentUsername(username)
    , currentUserId(userId)
    , sidebar(nullptr)
    , avatarButton(nullptr)
    , avatarOverlay(nullptr)
    , usernameLabel(nullptr)
    , profileBtn(nullptr)
    , messagesBtn(nullptr)
    , friendsBtn(nullptr)
    , notificationsBtn(nullptr)
    , playlistBtn(nullptr)
    , musicSearchBtn(nullptr)
    , myMusicBtn(nullptr)
    , roomsBtn(nullptr)
    , mainStack(nullptr)
    , profilePage(nullptr)
    , messagesPage(nullptr)
    , friendsPage(nullptr)
    , notificationsPage(nullptr)
    , playlistPage(nullptr)
    , musicPage(nullptr)
    , myMusicPage(nullptr)
    , roomsPage(nullptr)
    , searchInput(nullptr)
    , searchButton(nullptr)
    , topTracksButton(nullptr)
    , tracksList(nullptr)
    , trackInfo(nullptr)
    , userTracksList(nullptr)
    , refreshTracksBtn(nullptr)
    , addLocalTrackBtn(nullptr)
    , apiManager(new MusicAPIManager(this))
    , audioPlayer(new AudioPlayer(this))
    , currentRadioIndex(-1)
{
    setupUI();
    setupConnections();
    setupAvatar();
    loadUserAvatar();
    loadUserRadio();

    setWindowTitle("Chorus - " + username);

    QFile styleFile("styles/styles.css");
    if (styleFile.open(QIODevice::ReadOnly)) {
        QString styleSheet = QLatin1String(styleFile.readAll());
        setStyleSheet(styleSheet);
    }

    if (avatarButton) {
        avatarButton->installEventFilter(this);
    }

    setMinimumSize(1200, 750);
    resize(1400, 850);

    QFont font = QApplication::font();
    font.setPointSize(10);
    QApplication::setFont(font);
}

MainWindow::~MainWindow()
{
}

bool MainWindow::eventFilter(QObject *obj, QEvent *event)
{
    if (obj == avatarButton) {
        if (event->type() == QEvent::Enter) {
            showAvatarOverlay();
            return true;
        } else if (event->type() == QEvent::Leave) {
            hideAvatarOverlay();
            return true;
        }
    }

    if (obj == avatarOverlay) {
        if (event->type() == QEvent::MouseButtonPress) {
            changeAvatar();
            hideAvatarOverlay();
            return true;
        }
    }

    return FramelessWindow::eventFilter(obj, event);
}

=== kursach/src/gui/MainWindow/MainWindow.h ===
#ifndef MAINWINDOW_H
#define MAINWINDOW_H


#include <QMainWindow>
#include <QStackedWidget>
#include <QPushButton>
#include <QLabel>
#include <QListWidget>
#include <QLineEdit>
#include <QTextEdit>
#include <QGraphicsDropShadowEffect>
#include "../Frameless/FramelessWindow.h"
#include "core/models/Track.h"
#include <vector>


class FriendsPage;
class MessagesPage;
class MusicAPIManager;
class AudioPlayer;


enum PageIndex {
    MYMUSICPAGE = 0,
    PROFILEPAGE = 1,
    MESSAGESPAGE = 2,
    FRIENDSPAGE = 3,
    NOTIFICATIONSPAGE = 4,
    PLAYLISTPAGE = 5,
    MUSICPAGE = 6,
    ROOMSPAGE = 7
};


class MainWindow : public FramelessWindow {
    Q_OBJECT


public:
    MainWindow(const QString &username, int userId, QWidget *parent = nullptr);
    ~MainWindow();
    


protected:
    bool eventFilter(QObject *obj, QEvent *event) override;


private slots:
    void setupConnections();
    void playRadio(int radioId);
    void onPlaylistItemClicked(QListWidgetItem *item);
    void onRadioDeleteRequested(int radioId);
    void loadUserRadio();
    void showProfilePage();
    void showMessagesPage();
    void showFriendsPage();
    void showNotificationsPage();
    void showPlaylistPage();
    void showRoomsPage();
    void changeAvatar();
    void onRadioStationAdded();


private:
    void setupUI();
    void createSidebar();
    void createPages();
    QWidget* createSimplePage(const QString& title, const QString& description);


    void setupAvatar();
    void setAvatarPixmap(const QPixmap& pixmap);
    void setDefaultAvatar();
    void saveAvatar(const QPixmap& avatar);
    void loadUserAvatar();
    void showAvatarOverlay();
    void hideAvatarOverlay();
    void onAvatarButtonEnter();
    void onAvatarButtonLeave();



    QString currentUsername;
    int currentUserId;
    QVector<TrackData> currentRadios;
    int currentRadioIndex;


    QWidget *sidebar;
    QPushButton *avatarButton;
    QLabel *avatarOverlay;
    QLabel *usernameLabel;


    QPushButton *profileBtn;
    QPushButton *messagesBtn;
    QPushButton *friendsBtn;
    QPushButton *notificationsBtn;
    QPushButton *playlistBtn;
    QPushButton *musicSearchBtn;
    QPushButton *myMusicBtn;
    QPushButton *roomsBtn;


    QStackedWidget *mainStack;
    QWidget *profilePage;
    QWidget *messagesPage;
    QWidget *friendsPage;
    QWidget *notificationsPage;
    QWidget *playlistPage;
    QWidget *musicPage;
    QWidget *myMusicPage;
    QWidget *roomsPage;


    QLineEdit *searchInput;
    QPushButton *searchButton;
    QPushButton *topTracksButton;
    QListWidget *tracksList;
    QTextEdit *trackInfo;
    QListWidget *userTracksList;
    QPushButton *refreshTracksBtn;
    QPushButton *addLocalTrackBtn;


    MusicAPIManager *apiManager;
    AudioPlayer *audioPlayer;
};


#endif // MAINWINDOW_H

=== kursach/src/gui/dialogs/NotificationDialog.cpp ===
#include "NotificationDialog.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QPushButton>
#include <QGraphicsDropShadowEffect>

NotificationDialog::NotificationDialog(const QString& message, Type type, QWidget* parent)
    : QDialog(parent)
{
    setupUI(message, type);
}

void NotificationDialog::setupUI(const QString& message, Type type)
{
    setWindowFlags(Qt::Dialog | Qt::FramelessWindowHint);
    setAttribute(Qt::WA_TranslucentBackground);
    setStyleSheet("background: transparent;");
    setFixedSize(480, 160);

    QString accentColor;
    QString iconText;
    QString title;

    switch(type) {
        case Success:
            accentColor = "#8A2BE2";  // 
            iconText = "";
            title = "";
            break;
        case Error:
            accentColor = "#FF6B6B";  // 
            iconText = "";
            title = "";
            break;
        case Warning:
            accentColor = "#FFA726";  // 
            iconText = "";
            title = "";
            break;
        case Info:
        default:
            accentColor = "#8A2BE2";  // 
            iconText = "";
            title = "";
            break;
    }

    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);

    //  
    QWidget* container = new QWidget();
    container->setStyleSheet(QString(R"(
        QWidget {
            background: #0F0F14;
            border: 2px solid %1;
            border-radius: 12px;
        }
    )").arg(accentColor));

    QVBoxLayout* containerLayout = new QVBoxLayout(container);
    containerLayout->setContentsMargins(0, 0, 0, 0);
    containerLayout->setSpacing(0);

    // Header
    QWidget* header = new QWidget();
    header->setFixedHeight(55);
    header->setStyleSheet(QString(R"(
        QWidget {
            background: rgba(138, 43, 226, 0.1);
            border-bottom: 2px solid %1;
            border-radius: 10px 10px 0px 0px;
        }
    )").arg(accentColor));

    QHBoxLayout* headerLayout = new QHBoxLayout(header);
    headerLayout->setContentsMargins(20, 0, 20, 0);
    headerLayout->setSpacing(12);

    QLabel* iconLabel = new QLabel(iconText);
    iconLabel->setStyleSheet(QString(R"(
        QLabel {
            color: %1;
            font-size: 24px;
            font-weight: bold;
            min-width: 30px;
            background: transparent;
            border: none;
        }
    )").arg(accentColor));

    QLabel* titleLabel = new QLabel(title);
    titleLabel->setStyleSheet(QString(R"(
        QLabel {
            color: %1;
            font-size: 15px;
            font-weight: 700;
            background: transparent;
            border: none;
        }
    )").arg(accentColor));

    headerLayout->addWidget(iconLabel);
    headerLayout->addWidget(titleLabel);
    headerLayout->addStretch();

    // Body
    QWidget* body = new QWidget();
    body->setStyleSheet("background: transparent;");
    QVBoxLayout* bodyLayout = new QVBoxLayout(body);
    bodyLayout->setContentsMargins(20, 15, 20, 10);
    bodyLayout->setSpacing(0);

    QLabel* messageLabel = new QLabel(message);
    messageLabel->setStyleSheet(R"(
        QLabel {
            color: rgba(255, 255, 255, 0.95);
            font-size: 14px;
            font-weight: 400;
            background: transparent;
            border: none;
        }
    )");
    messageLabel->setWordWrap(true);
    messageLabel->setAlignment(Qt::AlignLeft | Qt::AlignVCenter);

    bodyLayout->addWidget(messageLabel);

    // Footer
    QWidget* footer = new QWidget();
    footer->setFixedHeight(50);
    footer->setStyleSheet("background: transparent;");
    QHBoxLayout* footerLayout = new QHBoxLayout(footer);
    footerLayout->setContentsMargins(20, 0, 20, 10);
    footerLayout->setSpacing(10);

    QPushButton* okBtn = new QPushButton("OK");
    okBtn->setFixedWidth(110);
    okBtn->setFixedHeight(36);
    okBtn->setStyleSheet(QString(R"(
        QPushButton {
            background: %1;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 700;
        }
        QPushButton:hover {
            background: rgba(138, 43, 226, 0.85);
        }
        QPushButton:pressed {
            background: rgba(138, 43, 226, 0.7);
        }
    )").arg(accentColor));

    connect(okBtn, &QPushButton::clicked, this, &QDialog::accept);

    footerLayout->addStretch();
    footerLayout->addWidget(okBtn);

    //  
    containerLayout->addWidget(header);
    containerLayout->addWidget(body);
    containerLayout->addWidget(footer);

    mainLayout->addWidget(container);

    // 
    QGraphicsDropShadowEffect* shadow = new QGraphicsDropShadowEffect();
    shadow->setBlurRadius(20);
    shadow->setColor(QColor(0, 0, 0, 100));
    shadow->setOffset(0, 5);
    container->setGraphicsEffect(shadow);
}

=== kursach/src/gui/dialogs/NotificationDialog.h ===
#ifndef NOTIFICATION_DIALOG_H
#define NOTIFICATION_DIALOG_H

#include <QDialog>
#include <QString>

class NotificationDialog : public QDialog
{
    Q_OBJECT

public:
    enum Type { Success, Error, Info, Warning };

    NotificationDialog(const QString& message, Type type = Info, QWidget* parent = nullptr);
    ~NotificationDialog() = default;

private:
    void setupUI(const QString& message, Type type);
};

#endif // NOTIFICATION_DIALOG_H

=== kursach/src/gui/AuthWindow/widgets/LoginForm.cpp ===
#include "LoginForm.h"
#include "database/DatabaseManager.h"
#include <QVBoxLayout>
#include <QLabel>
#include <QMessageBox>

LoginForm::LoginForm(QWidget *parent)
    : QWidget(parent)
{
    setupUI();
}

void LoginForm::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setSpacing(25);
    
    QLabel* titleLabel = new QLabel("  ");
    titleLabel->setStyleSheet("color: white; font-size: 24px; font-weight: bold; text-align: center;");
    titleLabel->setAlignment(Qt::AlignCenter);
    
    m_usernameInput = new QLineEdit();
    m_usernameInput->setPlaceholderText(" ");
    m_usernameInput->setMinimumHeight(45);
    m_usernameInput->setStyleSheet(R"(
        QLineEdit {
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 0 15px;
            color: white;
            font-size: 14px;
        }
        QLineEdit:focus {
            border: 2px solid #8A2BE2;
        }
    )");
    
    m_passwordInput = new QLineEdit();
    m_passwordInput->setPlaceholderText("");
    m_passwordInput->setEchoMode(QLineEdit::Password);
    m_passwordInput->setMinimumHeight(45);
    m_passwordInput->setStyleSheet(m_usernameInput->styleSheet());
    
    m_loginButton = new QPushButton("");
    m_loginButton->setMinimumHeight(45);
    m_loginButton->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");
    
    m_registerButton = new QPushButton("  ");
    m_registerButton->setStyleSheet(R"(
        QPushButton {
            background: transparent;
            color: #8A2BE2;
            border: 2px solid #8A2BE2;
            border-radius: 10px;
            font-size: 14px;
            padding: 12px;
            font-weight: 500;
        }
        QPushButton:hover {
            background: rgba(138, 43, 226, 0.1);
        }
    )");
    
    mainLayout->addWidget(titleLabel);
    mainLayout->addSpacing(10);
    mainLayout->addWidget(m_usernameInput);
    mainLayout->addWidget(m_passwordInput);
    mainLayout->addWidget(m_loginButton);
    mainLayout->addWidget(m_registerButton);
    mainLayout->addStretch();
    
    connect(m_loginButton, &QPushButton::clicked, this, &LoginForm::onLoginClicked);
    connect(m_registerButton, &QPushButton::clicked, this, &LoginForm::switchToRegister);
    connect(m_passwordInput, &QLineEdit::returnPressed, this, &LoginForm::onLoginClicked);
}

bool LoginForm::validateInput()
{
    if (m_usernameInput->text().trimmed().isEmpty()) {
        QMessageBox::warning(this, "", "  ");
        return false;
    }
    
    if (m_passwordInput->text().isEmpty()) {
        QMessageBox::warning(this, "", " ");
        return false;
    }
    
    return true;
}

void LoginForm::onLoginClicked()
{
    if (!validateInput()) return;
    
    QString username = m_usernameInput->text().trimmed();
    QString password = m_passwordInput->text();
    
    if (DatabaseManager::instance().authenticateUser(username, password)) {
        int userId = DatabaseManager::instance().getUserId(username);
        emit loginSuccess(username, userId);
    } else {
        QMessageBox::warning(this, "", "    ");
    }
}


=== kursach/src/gui/AuthWindow/widgets/LoginForm.h ===
#ifndef LOGINFORM_H
#define LOGINFORM_H

#include <QWidget>
#include <QLineEdit>
#include <QPushButton>

class LoginForm : public QWidget
{
    Q_OBJECT

public:
    explicit LoginForm(QWidget *parent = nullptr);

signals:
    void loginSuccess(const QString& username, int userId);
    void switchToRegister();

private slots:
    void onLoginClicked();

private:
    void setupUI();
    bool validateInput();
    
    QLineEdit* m_usernameInput;
    QLineEdit* m_passwordInput;
    QPushButton* m_loginButton;
    QPushButton* m_registerButton;
};

#endif


=== kursach/src/gui/AuthWindow/widgets/RegisterForm.h ===
#ifndef REGISTERFORM_H
#define REGISTERFORM_H

#include <QWidget>
#include <QLineEdit>
#include <QPushButton>

class RegisterForm : public QWidget
{
    Q_OBJECT

public:
    explicit RegisterForm(QWidget *parent = nullptr);

signals:
    void registerSuccess();
    void switchToLogin();

private slots:
    void onRegisterClicked();

private:
    void setupUI();
    bool validateInput();
    
    QLineEdit* m_emailInput;
    QLineEdit* m_usernameInput;
    QLineEdit* m_passwordInput;
    QLineEdit* m_confirmPasswordInput;
    QPushButton* m_registerButton;
    QPushButton* m_loginButton;
};

#endif


=== kursach/src/gui/AuthWindow/widgets/RegisterForm.cpp ===
#include "RegisterForm.h"
#include "database/DatabaseManager.h"
#include <QVBoxLayout>
#include <QLabel>
#include <QMessageBox>
#include <QRegularExpression>

RegisterForm::RegisterForm(QWidget *parent)
    : QWidget(parent)
{
    setupUI();
}

void RegisterForm::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setSpacing(20);
    
    QLabel* titleLabel = new QLabel(" ");
    titleLabel->setStyleSheet("color: white; font-size: 24px; font-weight: bold; text-align: center;");
    titleLabel->setAlignment(Qt::AlignCenter);
    
    QString inputStyle = R"(
        QLineEdit {
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 0 15px;
            color: white;
            font-size: 14px;
        }
        QLineEdit:focus {
            border: 2px solid #8A2BE2;
        }
    )";
    
    m_emailInput = new QLineEdit();
    m_emailInput->setPlaceholderText("Email ");
    m_emailInput->setMinimumHeight(40);
    m_emailInput->setStyleSheet(inputStyle);
    
    m_usernameInput = new QLineEdit();
    m_usernameInput->setPlaceholderText(" ");
    m_usernameInput->setMinimumHeight(40);
    m_usernameInput->setStyleSheet(inputStyle);
    
    m_passwordInput = new QLineEdit();
    m_passwordInput->setPlaceholderText("");
    m_passwordInput->setEchoMode(QLineEdit::Password);
    m_passwordInput->setMinimumHeight(40);
    m_passwordInput->setStyleSheet(inputStyle);
    
    m_confirmPasswordInput = new QLineEdit();
    m_confirmPasswordInput->setPlaceholderText(" ");
    m_confirmPasswordInput->setEchoMode(QLineEdit::Password);
    m_confirmPasswordInput->setMinimumHeight(40);
    m_confirmPasswordInput->setStyleSheet(inputStyle);
    
    QLabel* rulesLabel = new QLabel(
        "  6 \n"
        "   \n"
        "   "
    );
    rulesLabel->setStyleSheet(R"(
        color: rgba(255, 255, 255, 0.5);
        font-size: 12px;
        background: rgba(255, 255, 255, 0.05);
        padding: 10px;
        border-radius: 8px;
    )");
    
    m_registerButton = new QPushButton("");
    m_registerButton->setMinimumHeight(45);
    m_registerButton->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");
    
    m_loginButton = new QPushButton("  ? ");
    m_loginButton->setStyleSheet(R"(
        QPushButton {
            background: transparent;
            color: #8A2BE2;
            border: 2px solid #8A2BE2;
            border-radius: 10px;
            font-size: 14px;
            padding: 12px;
            font-weight: 500;
        }
        QPushButton:hover {
            background: rgba(138, 43, 226, 0.1);
        }
    )");
    
    mainLayout->addWidget(titleLabel);
    mainLayout->addWidget(m_emailInput);
    mainLayout->addWidget(m_usernameInput);
    mainLayout->addWidget(m_passwordInput);
    mainLayout->addWidget(m_confirmPasswordInput);
    mainLayout->addWidget(rulesLabel);
    mainLayout->addWidget(m_registerButton);
    mainLayout->addWidget(m_loginButton);
    mainLayout->addStretch();
    
    connect(m_registerButton, &QPushButton::clicked, this, &RegisterForm::onRegisterClicked);
    connect(m_loginButton, &QPushButton::clicked, this, &RegisterForm::switchToLogin);
}

bool RegisterForm::validateInput()
{
    QString email = m_emailInput->text().trimmed();
    QString username = m_usernameInput->text().trimmed();
    QString password = m_passwordInput->text();
    QString confirmPassword = m_confirmPasswordInput->text();
    
    if (email.isEmpty() || username.isEmpty() || password.isEmpty() || confirmPassword.isEmpty()) {
        QMessageBox::warning(this, "", "    ");
        return false;
    }
    
    QRegularExpression emailRegex("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$");
    if (!emailRegex.match(email).hasMatch()) {
        QMessageBox::warning(this, "", "  email");
        return false;
    }
    
    if (username.length() < 3) {
        QMessageBox::warning(this, "", "     3 ");
        return false;
    }
    
    if (password.length() < 6) {
        QMessageBox::warning(this, "", "    6 ");
        return false;
    }
    
    if (password != confirmPassword) {
        QMessageBox::warning(this, "", "  ");
        return false;
    }
    
    return true;
}

void RegisterForm::onRegisterClicked()
{
    if (!validateInput()) return;
    
    QString username = m_usernameInput->text().trimmed();
    QString password = m_passwordInput->text();
    
    if (DatabaseManager::instance().registerUser(username, password)) {
        QMessageBox::information(this, "", "  !");
        emit registerSuccess();
    } else {
        QMessageBox::warning(this, "", "   ");
    }
}


=== kursach/src/gui/AuthWindow/AuthWindow.h ===
#ifndef AUTHWINDOW_H
#define AUTHWINDOW_H

#include <QMainWindow>
#include <QStackedWidget>

class LoginForm;
class RegisterForm;

class AuthWindow : public QMainWindow
{
    Q_OBJECT

public:
    explicit AuthWindow(QWidget *parent = nullptr);
    ~AuthWindow();

protected:
    bool eventFilter(QObject *obj, QEvent *event) override;

private slots:
    void onLoginSuccess(const QString& username, int userId);
    void onRegisterSuccess();
    void switchToLogin();
    void switchToRegister();

private:
    void setupUI();
    void showMainWindow(const QString& username, int userId);
    
    QStackedWidget* m_stackedWidget;
    LoginForm* m_loginForm;
    RegisterForm* m_registerForm;
    
    QWidget* m_titleBarWidget;
    bool m_dragging;
    QPoint m_dragPosition;
};

#endif


=== kursach/src/gui/AuthWindow/AuthWindow.cpp ===
#include "AuthWindow.h"
#include "gui/AuthWindow/widgets/LoginForm.h"
#include "gui/AuthWindow/widgets/RegisterForm.h"
#include "gui/MainWindow/MainWindow.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QPushButton>
#include <QMouseEvent>

AuthWindow::AuthWindow(QWidget *parent)
    : QMainWindow(parent)
    , m_stackedWidget(new QStackedWidget(this))
    , m_dragging(false)
{
    setupUI();
    
    setWindowTitle("Chorus");
    setFixedSize(500, 650);
    setWindowFlags(Qt::FramelessWindowHint);
    setAttribute(Qt::WA_TranslucentBackground);
}

AuthWindow::~AuthWindow()
{
}

void AuthWindow::setupUI()
{
    QWidget* central = new QWidget();
    central->setObjectName("centralWidget");
    central->setStyleSheet(R"(
        #centralWidget {
            background: #0F0F14;
            border-radius: 20px;
        }
    )");
    
    setCentralWidget(central);
    
    QVBoxLayout* mainLayout = new QVBoxLayout(central);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);
    
    m_titleBarWidget = new QWidget();
    m_titleBarWidget->setFixedHeight(50);
    m_titleBarWidget->setStyleSheet("background: transparent;");
    m_titleBarWidget->installEventFilter(this);
    
    QHBoxLayout* titleLayout = new QHBoxLayout(m_titleBarWidget);
    titleLayout->setContentsMargins(20, 0, 20, 0);
    
    QLabel* logo = new QLabel("Chorus");
    logo->setStyleSheet("color: #8A2BE2; font-size: 20px; font-weight: 800;");
    
    QWidget* windowButtons = new QWidget();
    QHBoxLayout* buttonsLayout = new QHBoxLayout(windowButtons);
    buttonsLayout->setContentsMargins(0, 0, 0, 0);
    buttonsLayout->setSpacing(5);
    
    QPushButton* minimizeBtn = new QPushButton("");
    QPushButton* closeBtn = new QPushButton("");
    
    QString windowBtnStyle = R"(
        QPushButton {
            background: transparent;
            color: rgba(255, 255, 255, 0.6);
            border: none;
            font-size: 20px;
            min-width: 30px;
            min-height: 30px;
            border-radius: 4px;
        }
        QPushButton:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        QPushButton#closeBtn:hover {
            background: #FF4444;
        }
    )";
    
    minimizeBtn->setStyleSheet(windowBtnStyle);
    closeBtn->setStyleSheet(windowBtnStyle);
    closeBtn->setObjectName("closeBtn");
    
    buttonsLayout->addWidget(minimizeBtn);
    buttonsLayout->addWidget(closeBtn);
    
    titleLayout->addWidget(logo);
    titleLayout->addStretch();
    titleLayout->addWidget(windowButtons);
    
    connect(minimizeBtn, &QPushButton::clicked, this, &QMainWindow::showMinimized);
    connect(closeBtn, &QPushButton::clicked, this, &QMainWindow::close);
    
    QWidget* contentWidget = new QWidget();
    QVBoxLayout* contentLayout = new QVBoxLayout(contentWidget);
    contentLayout->setContentsMargins(40, 20, 40, 40);
    
    m_loginForm = new LoginForm();
    m_registerForm = new RegisterForm();
    
    m_stackedWidget->addWidget(m_loginForm);
    m_stackedWidget->addWidget(m_registerForm);
    
    contentLayout->addWidget(m_stackedWidget);
    
    mainLayout->addWidget(m_titleBarWidget);
    mainLayout->addWidget(contentWidget, 1);
    
    connect(m_loginForm, &LoginForm::loginSuccess, this, &AuthWindow::onLoginSuccess);
    connect(m_loginForm, &LoginForm::switchToRegister, this, &AuthWindow::switchToRegister);
    connect(m_registerForm, &RegisterForm::registerSuccess, this, &AuthWindow::onRegisterSuccess);
    connect(m_registerForm, &RegisterForm::switchToLogin, this, &AuthWindow::switchToLogin);
}

bool AuthWindow::eventFilter(QObject *obj, QEvent *event)
{
    if (obj == m_titleBarWidget) {
        if (event->type() == QEvent::MouseButtonPress) {
            QMouseEvent *mouseEvent = static_cast<QMouseEvent*>(event);
            if (mouseEvent->button() == Qt::LeftButton) {
                m_dragging = true;
                m_dragPosition = mouseEvent->globalPos() - frameGeometry().topLeft();
                return true;
            }
        } else if (event->type() == QEvent::MouseMove && m_dragging) {
            QMouseEvent *mouseEvent = static_cast<QMouseEvent*>(event);
            move(mouseEvent->globalPos() - m_dragPosition);
            return true;
        } else if (event->type() == QEvent::MouseButtonRelease) {
            m_dragging = false;
            return true;
        }
    }
    return QMainWindow::eventFilter(obj, event);
}

void AuthWindow::switchToLogin()
{
    m_stackedWidget->setCurrentIndex(0);
}

void AuthWindow::switchToRegister()
{
    m_stackedWidget->setCurrentIndex(1);
}

void AuthWindow::onLoginSuccess(const QString& username, int userId)
{
    showMainWindow(username, userId);
}

void AuthWindow::onRegisterSuccess()
{
    switchToLogin();
}

void AuthWindow::showMainWindow(const QString& username, int userId)
{
    MainWindow* mainWindow = new MainWindow(username, userId);
    mainWindow->show();
    this->close();
}


=== kursach/src/gui/Frameless/FramelessWindow.cpp ===
#include "FramelessWindow.h"
#include <QApplication>
#include <QDebug>

FramelessWindow::FramelessWindow(QWidget *parent)
    : QMainWindow(parent)
{
    setWindowFlags(Qt::FramelessWindowHint);
    setAttribute(Qt::WA_TranslucentBackground);
    
    //  
    setAttribute(Qt::WA_NoSystemBackground, false);
    setAttribute(Qt::WA_OpaquePaintEvent, true);
    
    //       
    QGraphicsDropShadowEffect *shadow = new QGraphicsDropShadowEffect();
    shadow->setBlurRadius(25); //  
    shadow->setXOffset(0);
    shadow->setYOffset(0);
    shadow->setColor(QColor(0, 0, 0, 40)); //   
    
    QWidget *central = new QWidget();
    central->setObjectName("windowContent");
    central->setGraphicsEffect(shadow);
    
    //     
    central->setAttribute(Qt::WA_NoSystemBackground, false);
    central->setAttribute(Qt::WA_OpaquePaintEvent, true);
    
    //     
    QPalette pal = central->palette();
    pal.setColor(QPalette::Window, QColor(15, 15, 20));
    central->setPalette(pal);
    central->setAutoFillBackground(true);
    
    setCentralWidget(central);
}

void FramelessWindow::mousePressEvent(QMouseEvent *event)
{
    if (event->button() == Qt::LeftButton) {
        m_dragging = true;
        m_dragPosition = event->globalPos() - frameGeometry().topLeft();
        event->accept();
    }
}

void FramelessWindow::mouseMoveEvent(QMouseEvent *event)
{
    if (event->buttons() & Qt::LeftButton && m_dragging) {
        move(event->globalPos() - m_dragPosition);
        event->accept();
    }
}

void FramelessWindow::mouseReleaseEvent(QMouseEvent *event)
{
    if (event->button() == Qt::LeftButton) {
        m_dragging = false;
        event->accept();
    }
}

=== kursach/src/gui/Frameless/FramelessWindow.h ===
#ifndef FRAMELESSWINDOW_H
#define FRAMELESSWINDOW_H

#include <QMainWindow>
#include <QMouseEvent>
#include <QGraphicsDropShadowEffect>

class FramelessWindow : public QMainWindow
{
    Q_OBJECT

public:
    explicit FramelessWindow(QWidget *parent = nullptr);
    
protected:
    void mousePressEvent(QMouseEvent *event) override;
    void mouseMoveEvent(QMouseEvent *event) override;
    void mouseReleaseEvent(QMouseEvent *event) override;
    
private:
    bool m_dragging = false;
    QPoint m_dragPosition;
};

#endif // FRAMELESSWINDOW_H

=== kursach/src/audio/AudioPlayer.cpp ===
#include "AudioPlayer.h"
#include <QSlider>
#include <QLabel>
#include <QToolButton>
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QStyle>
#include <QApplication>

AudioPlayer::AudioPlayer(QObject *parent)
    : QObject(parent)
    , mediaPlayer(new QMediaPlayer(this))
    , playerControls(nullptr)
    , nowPlayingLabel(nullptr)
    , currentTimeLabel(nullptr)
    , totalTimeLabel(nullptr)
    , progressSlider(nullptr)
    , playPauseBtn(nullptr)
    , previousBtn(nullptr)
    , nextBtn(nullptr)
    , volumeSlider(nullptr)
{
    mediaPlayer->setVolume(50);
}

AudioPlayer::~AudioPlayer()
{
}

void AudioPlayer::setupPlayerControls(QWidget *parent)
{
    playerControls = new QWidget(parent);
    playerControls->setFixedHeight(80);
    playerControls->setStyleSheet(R"(
        QWidget {
            background: rgba(15, 15, 20, 0.95);
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }
    )");
    
    QHBoxLayout *layout = new QHBoxLayout(playerControls);
    layout->setContentsMargins(30, 10, 30, 10);
    layout->setSpacing(20);
    
    nowPlayingLabel = new QLabel(" ");
    nowPlayingLabel->setStyleSheet(R"(
        QLabel {
            color: #FFFFFF;
            font-size: 14px;
            font-weight: 600;
            background: transparent;
        }
    )");
    nowPlayingLabel->setMinimumWidth(200);
    nowPlayingLabel->setMaximumWidth(250);
    
    layout->addWidget(nowPlayingLabel);
    layout->addStretch();
    
    QString playerBtnStyle = R"(
        QToolButton {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            border-radius: 15px;
            font-size: 16px;
        }
        QToolButton:hover {
            color: #FFFFFF;
            background: rgba(255, 255, 255, 0.1);
        }
    )";
    
    previousBtn = new QToolButton();
    previousBtn->setText("");
    previousBtn->setStyleSheet(playerBtnStyle);
    previousBtn->setFixedSize(40, 40);
    
    nextBtn = new QToolButton();
    nextBtn->setText("");
    nextBtn->setStyleSheet(playerBtnStyle);
    nextBtn->setFixedSize(40, 40);
    
    layout->addWidget(previousBtn);
    layout->addWidget(nextBtn);
    
    layout->addSpacing(20);
    
    QWidget *volumeWidget = new QWidget();
    QHBoxLayout *volumeLayout = new QHBoxLayout(volumeWidget);
    volumeLayout->setContentsMargins(0, 0, 0, 0);
    volumeLayout->setSpacing(8);
    
    QToolButton *volumeIcon = new QToolButton();
    volumeIcon->setText("");
    volumeIcon->setStyleSheet(playerBtnStyle);
    volumeIcon->setFixedSize(35, 35);
    
    volumeSlider = new QSlider(Qt::Horizontal);
    volumeSlider->setRange(0, 100);
    volumeSlider->setValue(50);
    volumeSlider->setFixedWidth(100);
    volumeSlider->setStyleSheet(R"(
        QSlider::groove:horizontal {
            background: rgba(255, 255, 255, 0.1);
            height: 4px;
            border-radius: 2px;
        }
        QSlider::sub-page:horizontal {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }
        QSlider::handle:horizontal {
            background: #FFFFFF;
            width: 10px;
            height: 10px;
            margin: -3px 0;
            border-radius: 5px;
        }
        QSlider::handle:horizontal:hover {
            background: #8A2BE2;
        }
    )");
    
    volumeLayout->addWidget(volumeIcon);
    volumeLayout->addWidget(volumeSlider);
    
    layout->addWidget(volumeWidget);
    
    layout->addSpacing(20);
    
    QToolButton *likeBtn = new QToolButton();
    likeBtn->setText("");
    likeBtn->setStyleSheet(R"(
        QToolButton {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 16px;
        }
        QToolButton:hover {
            color: #FF4444;
        }
        QToolButton[liked="true"] {
            color: #FF4444;
        }
    )");
    likeBtn->setFixedSize(35, 35);
    
    connect(likeBtn, &QToolButton::clicked, likeBtn, [likeBtn]() {
        bool liked = likeBtn->property("liked").toBool();
        likeBtn->setProperty("liked", !liked);
        likeBtn->setStyleSheet(likeBtn->styleSheet());
        likeBtn->setText(!liked ? "" : "");
    });
    
    layout->addWidget(likeBtn);
    
    connect(volumeSlider, &QSlider::valueChanged, this, [this, volumeIcon](int value) {
        mediaPlayer->setVolume(value);
        
        if (value == 0) {
            volumeIcon->setText("");
        } else if (value < 33) {
            volumeIcon->setText("");
        } else if (value < 66) {
            volumeIcon->setText("");
        } else {
            volumeIcon->setText("");
        }
    });
    
    connect(mediaPlayer, &QMediaPlayer::stateChanged, this, &AudioPlayer::onPlaybackStateChanged);
}

void AudioPlayer::playTrack(const QString& filePath)
{
    mediaPlayer->setMedia(QUrl::fromLocalFile(filePath));
    mediaPlayer->play();
}

void AudioPlayer::pauseTrack()
{
    if (mediaPlayer->state() == QMediaPlayer::PlayingState) {
        mediaPlayer->pause();
    } else {
        mediaPlayer->play();
    }
}

void AudioPlayer::setVolume(int volume)
{
    mediaPlayer->setVolume(volume);
    if (volumeSlider) {
        volumeSlider->setValue(volume);
    }
}

void AudioPlayer::seek(int position)
{
    mediaPlayer->setPosition(position);
}

bool AudioPlayer::isPlaying() const
{
    return mediaPlayer->state() == QMediaPlayer::PlayingState;
}

QString AudioPlayer::formatTime(qint64 milliseconds)
{
    qint64 seconds = milliseconds / 1000;
    qint64 minutes = seconds / 60;
    seconds = seconds % 60;
    return QString("%1:%2").arg(minutes).arg(seconds, 2, 10, QChar('0'));
}

void AudioPlayer::playSelectedTrack()
{
    pauseTrack();
}

void AudioPlayer::onPositionChanged(qint64 position)
{
}

void AudioPlayer::onDurationChanged(qint64 duration)
{
}

void AudioPlayer::seekTrack(int position)
{
    mediaPlayer->setPosition(position);
}

void AudioPlayer::onPlaybackStateChanged()
{
    updatePlaybackButtons();
}

void AudioPlayer::updatePlaybackButtons()
{
}

void AudioPlayer::updateTrackInfo(const QString& title, const QString& artist)
{
    if (nowPlayingLabel) {
        if (artist.isEmpty()) {
            nowPlayingLabel->setText(title);
        } else {
            nowPlayingLabel->setText(QString("%1 - %2").arg(title, artist));
        }
    }
}

=== kursach/src/audio/TrackWidget.cpp ===
#include "TrackWidget.h"
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QMenu>

TrackWidget::TrackWidget(const TrackData& track, QWidget *parent)
    : QWidget(parent), m_trackId(track.id)
{
    setupUI(track);
}

void TrackWidget::setupUI(const TrackData& track)
{
    setFixedHeight(60);
    
    QHBoxLayout* mainLayout = new QHBoxLayout(this);
    mainLayout->setContentsMargins(15, 10, 15, 10);
    mainLayout->setSpacing(15);
    
    QWidget* textWidget = new QWidget();
    QVBoxLayout* textLayout = new QVBoxLayout(textWidget);
    textLayout->setContentsMargins(0, 0, 0, 0);
    textLayout->setSpacing(3);
    
    m_titleLabel = new QLabel(track.title);
    m_titleLabel->setStyleSheet("color: white; font-size: 15px; font-weight: 600;");
    
    m_artistLabel = new QLabel(track.artist);
    m_artistLabel->setStyleSheet("color: rgba(255, 255, 255, 0.6); font-size: 13px;");
    
    textLayout->addWidget(m_titleLabel);
    textLayout->addWidget(m_artistLabel);
    
    m_durationLabel = new QLabel(formatDuration(track.duration));
    m_durationLabel->setStyleSheet("color: rgba(255, 255, 255, 0.5); font-size: 13px;");
    m_durationLabel->setFixedWidth(60);
    
    m_playButton = new QPushButton("");
    m_playButton->setFixedSize(40, 40);
    m_playButton->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 14px;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");
    
    connect(m_playButton, &QPushButton::clicked, [this]() {
        emit playRequested(m_trackId);
    });
    
    mainLayout->addWidget(textWidget, 1);
    mainLayout->addWidget(m_durationLabel);
    mainLayout->addWidget(m_playButton);
    
    setStyleSheet("TrackWidget { background: transparent; }");
}

QString TrackWidget::formatDuration(int seconds)
{
    int minutes = seconds / 60;
    int secs = seconds % 60;
    return QString("%1:%2").arg(minutes).arg(secs, 2, 10, QChar('0'));
}


=== kursach/src/audio/PlaybackController.h ===
#ifndef PLAYBACKCONTROLLER_H
#define PLAYBACKCONTROLLER_H

#include <QObject>
#include <QMediaPlayer>
#include "core/models/Track.h"

class PlaybackController : public QObject
{
    Q_OBJECT

public:
    explicit PlaybackController(QMediaPlayer* player, QObject *parent = nullptr);
    
    void playTrack(const TrackData& track);
    void pause();
    void resume();
    void stop();
    void seek(qint64 position);
    void setVolume(int volume);
    
    bool isPlaying() const;
    qint64 position() const;
    qint64 duration() const;
    int volume() const;

signals:
    void trackChanged(const TrackData& track);
    void stateChanged(QMediaPlayer::State state);
    void positionChanged(qint64 position);
    void durationChanged(qint64 duration);
    void volumeChanged(int volume);

private:
    QMediaPlayer* m_player;
    TrackData m_currentTrack;
};

#endif


=== kursach/src/audio/LocalFileHandler.h ===
#ifndef LOCALFILEHANDLER_H
#define LOCALFILEHANDLER_H

#include <QObject>
#include <QString>
#include <QStringList>

class LocalFileHandler : public QObject
{
    Q_OBJECT

public:
    explicit LocalFileHandler(QObject *parent = nullptr);
    
    QStringList getSupportedFormats() const;
    bool addTrackToDatabase(int userId, const QString& filePath);
    bool scanDirectory(int userId, const QString& directoryPath);

private:
    struct TrackMetadata {
        QString title;
        QString artist;
        QString album;
        int duration;
        QString genre;
        int year;
    };
    
    TrackMetadata extractMetadata(const QString& filePath);
    bool isValidAudioFile(const QString& filePath);
    
    QStringList m_supportedFormats;
};

#endif


=== kursach/src/audio/LocalFileHandler.cpp ===
#include "LocalFileHandler.h"
#include "database/DatabaseManager.h"
#include <QFileInfo>
#include <QDir>
#include <QDirIterator>
#include <QCryptographicHash>
#include <QDebug>
#include <taglib/fileref.h>
#include <taglib/tag.h>
#include <taglib/audioproperties.h>


LocalFileHandler::LocalFileHandler(QObject *parent)
    : QObject(parent)
{
    m_supportedFormats << "mp3" << "wav" << "flac" << "ogg" << "m4a" << "aac";
}


QStringList LocalFileHandler::getSupportedFormats() const
{
    return m_supportedFormats;
}


bool LocalFileHandler::addTrackToDatabase(int userId, const QString& filePath)
{
    if (!isValidAudioFile(filePath)) {
        return false;
    }
    
    TrackMetadata metadata = extractMetadata(filePath);
    
    return DatabaseManager::instance().addTrack(
        filePath,
        metadata.title,
        metadata.artist,
        metadata.album,
        metadata.duration,
        userId
    );
}


bool LocalFileHandler::scanDirectory(int userId, const QString& directoryPath)
{
    QDir dir(directoryPath);
    if (!dir.exists()) {
        return false;
    }
    
    QStringList filters;
    for (const QString& format : m_supportedFormats) {
        filters << "*." + format;
    }
    
    QDirIterator it(directoryPath, filters, QDir::Files, QDirIterator::Subdirectories);
    
    int addedCount = 0;
    while (it.hasNext()) {
        QString filePath = it.next();
        if (addTrackToDatabase(userId, filePath)) {
            addedCount++;
        }
    }
    
    return addedCount > 0;
}


LocalFileHandler::TrackMetadata LocalFileHandler::extractMetadata(const QString& filePath)
{
    TrackMetadata metadata;
    QFileInfo fileInfo(filePath);
    
    metadata.title = fileInfo.completeBaseName();
    metadata.artist = "Unknown Artist";
    metadata.album = "Unknown Album";
    metadata.duration = 0;
    metadata.genre = "";
    metadata.year = 0;
    
    TagLib::FileRef file(filePath.toStdString().c_str());
    
    if (!file.isNull() && file.tag()) {
        TagLib::Tag *tag = file.tag();
        
        if (!tag->title().isEmpty()) {
            metadata.title = QString::fromStdString(tag->title().to8Bit(true));
        }
        if (!tag->artist().isEmpty()) {
            metadata.artist = QString::fromStdString(tag->artist().to8Bit(true));
        }
        if (!tag->album().isEmpty()) {
            metadata.album = QString::fromStdString(tag->album().to8Bit(true));
        }
        if (!tag->genre().isEmpty()) {
            metadata.genre = QString::fromStdString(tag->genre().to8Bit(true));
        }
        metadata.year = tag->year();
        
        if (file.audioProperties()) {
            metadata.duration = file.audioProperties()->lengthInSeconds();
        }
    }
    
    return metadata;
}


bool LocalFileHandler::isValidAudioFile(const QString& filePath)
{
    QFileInfo fileInfo(filePath);
    
    if (!fileInfo.exists()) {
        return false;
    }
    
    QString extension = fileInfo.suffix().toLower();
    return m_supportedFormats.contains(extension);
}


=== kursach/src/audio/AudioPlayer.h ===
#ifndef AUDIOPLAYER_H
#define AUDIOPLAYER_H

#include <QMediaPlayer>
#include <QWidget>

class QSlider;
class QLabel;
class QToolButton;

class AudioPlayer : public QObject
{
    Q_OBJECT

public:
    explicit AudioPlayer(QObject *parent = nullptr);
    ~AudioPlayer();

    void setupPlayerControls(QWidget *parent);
    QWidget* getPlayerControls() const { return playerControls; }

    void playTrack(const QString& filePath);
    void pauseTrack();
    void setVolume(int volume);
    void seek(int position);

    bool isPlaying() const;
    QString formatTime(qint64 milliseconds);

public slots:
    void playSelectedTrack();
    void onPositionChanged(qint64 position);
    void onDurationChanged(qint64 duration);
    void seekTrack(int position);
    void onPlaybackStateChanged();
    void updatePlaybackButtons();
    void updateTrackInfo(const QString& title, const QString& artist);

signals:
    void trackFinished();

private:
    QMediaPlayer *mediaPlayer;
    QWidget *playerControls;
    QLabel *nowPlayingLabel;
    QLabel *currentTimeLabel;
    QLabel *totalTimeLabel;
    QSlider *progressSlider;
    QToolButton *playPauseBtn;
    QToolButton *previousBtn;
    QToolButton *nextBtn;
    QSlider *volumeSlider;
};

#endif

=== kursach/src/audio/TrackWidget.h ===
#ifndef TRACKWIDGET_H
#define TRACKWIDGET_H

#include <QWidget>
#include <QLabel>
#include <QPushButton>
#include "core/models/Track.h"

class TrackWidget : public QWidget
{
    Q_OBJECT

public:
    explicit TrackWidget(const TrackData& track, QWidget *parent = nullptr);
    
    int trackId() const { return m_trackId; }

signals:
    void playRequested(int trackId);
    void addToPlaylistRequested(int trackId);
    void deleteRequested(int trackId);

private:
    void setupUI(const TrackData& track);
    QString formatDuration(int seconds);
    
    int m_trackId;
    QLabel* m_titleLabel;
    QLabel* m_artistLabel;
    QLabel* m_durationLabel;
    QPushButton* m_playButton;
};

#endif


=== kursach/src/audio/PlaybackController.cpp ===
#include "PlaybackController.h"
#include <QUrl>

PlaybackController::PlaybackController(QMediaPlayer* player, QObject *parent)
    : QObject(parent), m_player(player)
{
    connect(m_player, &QMediaPlayer::stateChanged, this, &PlaybackController::stateChanged);
    connect(m_player, &QMediaPlayer::positionChanged, this, &PlaybackController::positionChanged);
    connect(m_player, &QMediaPlayer::durationChanged, this, &PlaybackController::durationChanged);
}

void PlaybackController::playTrack(const TrackData& track)
{
    m_currentTrack = track;
    
    if (track.filePath.startsWith("http://") || track.filePath.startsWith("https://")) {
        m_player->setMedia(QUrl(track.filePath));
    } else {
        m_player->setMedia(QUrl::fromLocalFile(track.filePath));
    }
    
    m_player->play();
    emit trackChanged(track);
}

void PlaybackController::pause()
{
    m_player->pause();
}

void PlaybackController::resume()
{
    m_player->play();
}

void PlaybackController::stop()
{
    m_player->stop();
}

void PlaybackController::seek(qint64 position)
{
    m_player->setPosition(position);
}

void PlaybackController::setVolume(int volume)
{
    m_player->setVolume(volume);
    emit volumeChanged(volume);
}

bool PlaybackController::isPlaying() const
{
    return m_player->state() == QMediaPlayer::PlayingState;
}

qint64 PlaybackController::position() const
{
    return m_player->position();
}

qint64 PlaybackController::duration() const
{
    return m_player->duration();
}

int PlaybackController::volume() const
{
    return m_player->volume();
}


=== kursach/src/Makefile ===
# CMAKE generated file: DO NOT EDIT!
# Generated by "Unix Makefiles" Generator, CMake Version 3.28

# Default target executed when no arguments are given to make.
default_target: all
.PHONY : default_target

# Allow only one "make -f Makefile2" at a time, but pass parallelism.
.NOTPARALLEL:

#=============================================================================
# Special targets provided by cmake.

# Disable implicit rules so canonical targets will work.
.SUFFIXES:

# Disable VCS-based implicit rules.
% : %,v

# Disable VCS-based implicit rules.
% : RCS/%

# Disable VCS-based implicit rules.
% : RCS/%,v

# Disable VCS-based implicit rules.
% : SCCS/s.%

# Disable VCS-based implicit rules.
% : s.%

.SUFFIXES: .hpux_make_needs_suffix_list

# Command-line flag to silence nested $(MAKE).
$(VERBOSE)MAKESILENT = -s

#Suppress display of executed commands.
$(VERBOSE).SILENT:

# A target that is always out of date.
cmake_force:
.PHONY : cmake_force

#=============================================================================
# Set environment variables for the build.

# The shell in which to execute make rules.
SHELL = /bin/sh

# The CMake executable.
CMAKE_COMMAND = /usr/bin/cmake

# The command to remove a file.
RM = /usr/bin/cmake -E rm -f

# Escaping for special characters.
EQUALS = =

# The top-level source directory on which CMake was run.
CMAKE_SOURCE_DIR = /home/salero/kursach

# The top-level build directory on which CMake was run.
CMAKE_BINARY_DIR = /home/salero/kursach/src

#=============================================================================
# Targets provided globally by CMake.

# Special rule for the target edit_cache
edit_cache:
	@$(CMAKE_COMMAND) -E cmake_echo_color "--switch=$(COLOR)" --cyan "No interactive CMake dialog available..."
	/usr/bin/cmake -E echo No\ interactive\ CMake\ dialog\ available.
.PHONY : edit_cache

# Special rule for the target edit_cache
edit_cache/fast: edit_cache
.PHONY : edit_cache/fast

# Special rule for the target rebuild_cache
rebuild_cache:
	@$(CMAKE_COMMAND) -E cmake_echo_color "--switch=$(COLOR)" --cyan "Running CMake to regenerate build system..."
	/usr/bin/cmake --regenerate-during-build -S$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR)
.PHONY : rebuild_cache

# Special rule for the target rebuild_cache
rebuild_cache/fast: rebuild_cache
.PHONY : rebuild_cache/fast

# Special rule for the target list_install_components
list_install_components:
	@$(CMAKE_COMMAND) -E cmake_echo_color "--switch=$(COLOR)" --cyan "Available install components are: \"Unspecified\""
.PHONY : list_install_components

# Special rule for the target list_install_components
list_install_components/fast: list_install_components
.PHONY : list_install_components/fast

# Special rule for the target install
install: preinstall
	@$(CMAKE_COMMAND) -E cmake_echo_color "--switch=$(COLOR)" --cyan "Install the project..."
	/usr/bin/cmake -P cmake_install.cmake
.PHONY : install

# Special rule for the target install
install/fast: preinstall/fast
	@$(CMAKE_COMMAND) -E cmake_echo_color "--switch=$(COLOR)" --cyan "Install the project..."
	/usr/bin/cmake -P cmake_install.cmake
.PHONY : install/fast

# Special rule for the target install/local
install/local: preinstall
	@$(CMAKE_COMMAND) -E cmake_echo_color "--switch=$(COLOR)" --cyan "Installing only the local directory..."
	/usr/bin/cmake -DCMAKE_INSTALL_LOCAL_ONLY=1 -P cmake_install.cmake
.PHONY : install/local

# Special rule for the target install/local
install/local/fast: preinstall/fast
	@$(CMAKE_COMMAND) -E cmake_echo_color "--switch=$(COLOR)" --cyan "Installing only the local directory..."
	/usr/bin/cmake -DCMAKE_INSTALL_LOCAL_ONLY=1 -P cmake_install.cmake
.PHONY : install/local/fast

# Special rule for the target install/strip
install/strip: preinstall
	@$(CMAKE_COMMAND) -E cmake_echo_color "--switch=$(COLOR)" --cyan "Installing the project stripped..."
	/usr/bin/cmake -DCMAKE_INSTALL_DO_STRIP=1 -P cmake_install.cmake
.PHONY : install/strip

# Special rule for the target install/strip
install/strip/fast: preinstall/fast
	@$(CMAKE_COMMAND) -E cmake_echo_color "--switch=$(COLOR)" --cyan "Installing the project stripped..."
	/usr/bin/cmake -DCMAKE_INSTALL_DO_STRIP=1 -P cmake_install.cmake
.PHONY : install/strip/fast

# The main all target
all: cmake_check_build_system
	$(CMAKE_COMMAND) -E cmake_progress_start /home/salero/kursach/src/CMakeFiles /home/salero/kursach/src//CMakeFiles/progress.marks
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 all
	$(CMAKE_COMMAND) -E cmake_progress_start /home/salero/kursach/src/CMakeFiles 0
.PHONY : all

# The main clean target
clean:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 clean
.PHONY : clean

# The main clean target
clean/fast: clean
.PHONY : clean/fast

# Prepare targets for installation.
preinstall: all
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 preinstall
.PHONY : preinstall

# Prepare targets for installation.
preinstall/fast:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 preinstall
.PHONY : preinstall/fast

# clear depends
depend:
	$(CMAKE_COMMAND) -S$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 1
.PHONY : depend

#=============================================================================
# Target rules for targets named Chorus

# Build rule for target.
Chorus: cmake_check_build_system
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 Chorus
.PHONY : Chorus

# fast build rule for target.
Chorus/fast:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/build
.PHONY : Chorus/fast

#=============================================================================
# Target rules for targets named Chorus_autogen_timestamp_deps

# Build rule for target.
Chorus_autogen_timestamp_deps: cmake_check_build_system
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 Chorus_autogen_timestamp_deps
.PHONY : Chorus_autogen_timestamp_deps

# fast build rule for target.
Chorus_autogen_timestamp_deps/fast:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus_autogen_timestamp_deps.dir/build.make CMakeFiles/Chorus_autogen_timestamp_deps.dir/build
.PHONY : Chorus_autogen_timestamp_deps/fast

#=============================================================================
# Target rules for targets named Chorus_autogen

# Build rule for target.
Chorus_autogen: cmake_check_build_system
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 Chorus_autogen
.PHONY : Chorus_autogen

# fast build rule for target.
Chorus_autogen/fast:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus_autogen.dir/build.make CMakeFiles/Chorus_autogen.dir/build
.PHONY : Chorus_autogen/fast

Chorus_autogen/mocs_compilation.o: Chorus_autogen/mocs_compilation.cpp.o
.PHONY : Chorus_autogen/mocs_compilation.o

# target to build an object file
Chorus_autogen/mocs_compilation.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/Chorus_autogen/mocs_compilation.cpp.o
.PHONY : Chorus_autogen/mocs_compilation.cpp.o

Chorus_autogen/mocs_compilation.i: Chorus_autogen/mocs_compilation.cpp.i
.PHONY : Chorus_autogen/mocs_compilation.i

# target to preprocess a source file
Chorus_autogen/mocs_compilation.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/Chorus_autogen/mocs_compilation.cpp.i
.PHONY : Chorus_autogen/mocs_compilation.cpp.i

Chorus_autogen/mocs_compilation.s: Chorus_autogen/mocs_compilation.cpp.s
.PHONY : Chorus_autogen/mocs_compilation.s

# target to generate assembly for a file
Chorus_autogen/mocs_compilation.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/Chorus_autogen/mocs_compilation.cpp.s
.PHONY : Chorus_autogen/mocs_compilation.cpp.s

audio/AudioPlayer.o: audio/AudioPlayer.cpp.o
.PHONY : audio/AudioPlayer.o

# target to build an object file
audio/AudioPlayer.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/audio/AudioPlayer.cpp.o
.PHONY : audio/AudioPlayer.cpp.o

audio/AudioPlayer.i: audio/AudioPlayer.cpp.i
.PHONY : audio/AudioPlayer.i

# target to preprocess a source file
audio/AudioPlayer.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/audio/AudioPlayer.cpp.i
.PHONY : audio/AudioPlayer.cpp.i

audio/AudioPlayer.s: audio/AudioPlayer.cpp.s
.PHONY : audio/AudioPlayer.s

# target to generate assembly for a file
audio/AudioPlayer.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/audio/AudioPlayer.cpp.s
.PHONY : audio/AudioPlayer.cpp.s

audio/LocalFileHandler.o: audio/LocalFileHandler.cpp.o
.PHONY : audio/LocalFileHandler.o

# target to build an object file
audio/LocalFileHandler.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/audio/LocalFileHandler.cpp.o
.PHONY : audio/LocalFileHandler.cpp.o

audio/LocalFileHandler.i: audio/LocalFileHandler.cpp.i
.PHONY : audio/LocalFileHandler.i

# target to preprocess a source file
audio/LocalFileHandler.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/audio/LocalFileHandler.cpp.i
.PHONY : audio/LocalFileHandler.cpp.i

audio/LocalFileHandler.s: audio/LocalFileHandler.cpp.s
.PHONY : audio/LocalFileHandler.s

# target to generate assembly for a file
audio/LocalFileHandler.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/audio/LocalFileHandler.cpp.s
.PHONY : audio/LocalFileHandler.cpp.s

audio/PlaybackController.o: audio/PlaybackController.cpp.o
.PHONY : audio/PlaybackController.o

# target to build an object file
audio/PlaybackController.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/audio/PlaybackController.cpp.o
.PHONY : audio/PlaybackController.cpp.o

audio/PlaybackController.i: audio/PlaybackController.cpp.i
.PHONY : audio/PlaybackController.i

# target to preprocess a source file
audio/PlaybackController.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/audio/PlaybackController.cpp.i
.PHONY : audio/PlaybackController.cpp.i

audio/PlaybackController.s: audio/PlaybackController.cpp.s
.PHONY : audio/PlaybackController.s

# target to generate assembly for a file
audio/PlaybackController.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/audio/PlaybackController.cpp.s
.PHONY : audio/PlaybackController.cpp.s

audio/TrackWidget.o: audio/TrackWidget.cpp.o
.PHONY : audio/TrackWidget.o

# target to build an object file
audio/TrackWidget.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/audio/TrackWidget.cpp.o
.PHONY : audio/TrackWidget.cpp.o

audio/TrackWidget.i: audio/TrackWidget.cpp.i
.PHONY : audio/TrackWidget.i

# target to preprocess a source file
audio/TrackWidget.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/audio/TrackWidget.cpp.i
.PHONY : audio/TrackWidget.cpp.i

audio/TrackWidget.s: audio/TrackWidget.cpp.s
.PHONY : audio/TrackWidget.s

# target to generate assembly for a file
audio/TrackWidget.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/audio/TrackWidget.cpp.s
.PHONY : audio/TrackWidget.cpp.s

core/managers/PlaylistManager.o: core/managers/PlaylistManager.cpp.o
.PHONY : core/managers/PlaylistManager.o

# target to build an object file
core/managers/PlaylistManager.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/core/managers/PlaylistManager.cpp.o
.PHONY : core/managers/PlaylistManager.cpp.o

core/managers/PlaylistManager.i: core/managers/PlaylistManager.cpp.i
.PHONY : core/managers/PlaylistManager.i

# target to preprocess a source file
core/managers/PlaylistManager.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/core/managers/PlaylistManager.cpp.i
.PHONY : core/managers/PlaylistManager.cpp.i

core/managers/PlaylistManager.s: core/managers/PlaylistManager.cpp.s
.PHONY : core/managers/PlaylistManager.s

# target to generate assembly for a file
core/managers/PlaylistManager.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/core/managers/PlaylistManager.cpp.s
.PHONY : core/managers/PlaylistManager.cpp.s

core/managers/TrackManager.o: core/managers/TrackManager.cpp.o
.PHONY : core/managers/TrackManager.o

# target to build an object file
core/managers/TrackManager.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/core/managers/TrackManager.cpp.o
.PHONY : core/managers/TrackManager.cpp.o

core/managers/TrackManager.i: core/managers/TrackManager.cpp.i
.PHONY : core/managers/TrackManager.i

# target to preprocess a source file
core/managers/TrackManager.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/core/managers/TrackManager.cpp.i
.PHONY : core/managers/TrackManager.cpp.i

core/managers/TrackManager.s: core/managers/TrackManager.cpp.s
.PHONY : core/managers/TrackManager.s

# target to generate assembly for a file
core/managers/TrackManager.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/core/managers/TrackManager.cpp.s
.PHONY : core/managers/TrackManager.cpp.s

core/managers/UserManager.o: core/managers/UserManager.cpp.o
.PHONY : core/managers/UserManager.o

# target to build an object file
core/managers/UserManager.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/core/managers/UserManager.cpp.o
.PHONY : core/managers/UserManager.cpp.o

core/managers/UserManager.i: core/managers/UserManager.cpp.i
.PHONY : core/managers/UserManager.i

# target to preprocess a source file
core/managers/UserManager.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/core/managers/UserManager.cpp.i
.PHONY : core/managers/UserManager.cpp.i

core/managers/UserManager.s: core/managers/UserManager.cpp.s
.PHONY : core/managers/UserManager.s

# target to generate assembly for a file
core/managers/UserManager.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/core/managers/UserManager.cpp.s
.PHONY : core/managers/UserManager.cpp.s

database/DatabaseManager.o: database/DatabaseManager.cpp.o
.PHONY : database/DatabaseManager.o

# target to build an object file
database/DatabaseManager.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/database/DatabaseManager.cpp.o
.PHONY : database/DatabaseManager.cpp.o

database/DatabaseManager.i: database/DatabaseManager.cpp.i
.PHONY : database/DatabaseManager.i

# target to preprocess a source file
database/DatabaseManager.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/database/DatabaseManager.cpp.i
.PHONY : database/DatabaseManager.cpp.i

database/DatabaseManager.s: database/DatabaseManager.cpp.s
.PHONY : database/DatabaseManager.s

# target to generate assembly for a file
database/DatabaseManager.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/database/DatabaseManager.cpp.s
.PHONY : database/DatabaseManager.cpp.s

database/api/MusicAPIManager.o: database/api/MusicAPIManager.cpp.o
.PHONY : database/api/MusicAPIManager.o

# target to build an object file
database/api/MusicAPIManager.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/database/api/MusicAPIManager.cpp.o
.PHONY : database/api/MusicAPIManager.cpp.o

database/api/MusicAPIManager.i: database/api/MusicAPIManager.cpp.i
.PHONY : database/api/MusicAPIManager.i

# target to preprocess a source file
database/api/MusicAPIManager.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/database/api/MusicAPIManager.cpp.i
.PHONY : database/api/MusicAPIManager.cpp.i

database/api/MusicAPIManager.s: database/api/MusicAPIManager.cpp.s
.PHONY : database/api/MusicAPIManager.s

# target to generate assembly for a file
database/api/MusicAPIManager.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/database/api/MusicAPIManager.cpp.s
.PHONY : database/api/MusicAPIManager.cpp.s

gui/AuthWindow/AuthWindow.o: gui/AuthWindow/AuthWindow.cpp.o
.PHONY : gui/AuthWindow/AuthWindow.o

# target to build an object file
gui/AuthWindow/AuthWindow.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/AuthWindow/AuthWindow.cpp.o
.PHONY : gui/AuthWindow/AuthWindow.cpp.o

gui/AuthWindow/AuthWindow.i: gui/AuthWindow/AuthWindow.cpp.i
.PHONY : gui/AuthWindow/AuthWindow.i

# target to preprocess a source file
gui/AuthWindow/AuthWindow.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/AuthWindow/AuthWindow.cpp.i
.PHONY : gui/AuthWindow/AuthWindow.cpp.i

gui/AuthWindow/AuthWindow.s: gui/AuthWindow/AuthWindow.cpp.s
.PHONY : gui/AuthWindow/AuthWindow.s

# target to generate assembly for a file
gui/AuthWindow/AuthWindow.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/AuthWindow/AuthWindow.cpp.s
.PHONY : gui/AuthWindow/AuthWindow.cpp.s

gui/AuthWindow/widgets/LoginForm.o: gui/AuthWindow/widgets/LoginForm.cpp.o
.PHONY : gui/AuthWindow/widgets/LoginForm.o

# target to build an object file
gui/AuthWindow/widgets/LoginForm.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/AuthWindow/widgets/LoginForm.cpp.o
.PHONY : gui/AuthWindow/widgets/LoginForm.cpp.o

gui/AuthWindow/widgets/LoginForm.i: gui/AuthWindow/widgets/LoginForm.cpp.i
.PHONY : gui/AuthWindow/widgets/LoginForm.i

# target to preprocess a source file
gui/AuthWindow/widgets/LoginForm.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/AuthWindow/widgets/LoginForm.cpp.i
.PHONY : gui/AuthWindow/widgets/LoginForm.cpp.i

gui/AuthWindow/widgets/LoginForm.s: gui/AuthWindow/widgets/LoginForm.cpp.s
.PHONY : gui/AuthWindow/widgets/LoginForm.s

# target to generate assembly for a file
gui/AuthWindow/widgets/LoginForm.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/AuthWindow/widgets/LoginForm.cpp.s
.PHONY : gui/AuthWindow/widgets/LoginForm.cpp.s

gui/AuthWindow/widgets/RegisterForm.o: gui/AuthWindow/widgets/RegisterForm.cpp.o
.PHONY : gui/AuthWindow/widgets/RegisterForm.o

# target to build an object file
gui/AuthWindow/widgets/RegisterForm.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/AuthWindow/widgets/RegisterForm.cpp.o
.PHONY : gui/AuthWindow/widgets/RegisterForm.cpp.o

gui/AuthWindow/widgets/RegisterForm.i: gui/AuthWindow/widgets/RegisterForm.cpp.i
.PHONY : gui/AuthWindow/widgets/RegisterForm.i

# target to preprocess a source file
gui/AuthWindow/widgets/RegisterForm.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/AuthWindow/widgets/RegisterForm.cpp.i
.PHONY : gui/AuthWindow/widgets/RegisterForm.cpp.i

gui/AuthWindow/widgets/RegisterForm.s: gui/AuthWindow/widgets/RegisterForm.cpp.s
.PHONY : gui/AuthWindow/widgets/RegisterForm.s

# target to generate assembly for a file
gui/AuthWindow/widgets/RegisterForm.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/AuthWindow/widgets/RegisterForm.cpp.s
.PHONY : gui/AuthWindow/widgets/RegisterForm.cpp.s

gui/Frameless/FramelessWindow.o: gui/Frameless/FramelessWindow.cpp.o
.PHONY : gui/Frameless/FramelessWindow.o

# target to build an object file
gui/Frameless/FramelessWindow.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/Frameless/FramelessWindow.cpp.o
.PHONY : gui/Frameless/FramelessWindow.cpp.o

gui/Frameless/FramelessWindow.i: gui/Frameless/FramelessWindow.cpp.i
.PHONY : gui/Frameless/FramelessWindow.i

# target to preprocess a source file
gui/Frameless/FramelessWindow.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/Frameless/FramelessWindow.cpp.i
.PHONY : gui/Frameless/FramelessWindow.cpp.i

gui/Frameless/FramelessWindow.s: gui/Frameless/FramelessWindow.cpp.s
.PHONY : gui/Frameless/FramelessWindow.s

# target to generate assembly for a file
gui/Frameless/FramelessWindow.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/Frameless/FramelessWindow.cpp.s
.PHONY : gui/Frameless/FramelessWindow.cpp.s

gui/MainWindow/MainWindow.o: gui/MainWindow/MainWindow.cpp.o
.PHONY : gui/MainWindow/MainWindow.o

# target to build an object file
gui/MainWindow/MainWindow.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/MainWindow.cpp.o
.PHONY : gui/MainWindow/MainWindow.cpp.o

gui/MainWindow/MainWindow.i: gui/MainWindow/MainWindow.cpp.i
.PHONY : gui/MainWindow/MainWindow.i

# target to preprocess a source file
gui/MainWindow/MainWindow.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/MainWindow.cpp.i
.PHONY : gui/MainWindow/MainWindow.cpp.i

gui/MainWindow/MainWindow.s: gui/MainWindow/MainWindow.cpp.s
.PHONY : gui/MainWindow/MainWindow.s

# target to generate assembly for a file
gui/MainWindow/MainWindow.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/MainWindow.cpp.s
.PHONY : gui/MainWindow/MainWindow.cpp.s

gui/MainWindow/MainWindow_Avatar.o: gui/MainWindow/MainWindow_Avatar.cpp.o
.PHONY : gui/MainWindow/MainWindow_Avatar.o

# target to build an object file
gui/MainWindow/MainWindow_Avatar.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/MainWindow_Avatar.cpp.o
.PHONY : gui/MainWindow/MainWindow_Avatar.cpp.o

gui/MainWindow/MainWindow_Avatar.i: gui/MainWindow/MainWindow_Avatar.cpp.i
.PHONY : gui/MainWindow/MainWindow_Avatar.i

# target to preprocess a source file
gui/MainWindow/MainWindow_Avatar.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/MainWindow_Avatar.cpp.i
.PHONY : gui/MainWindow/MainWindow_Avatar.cpp.i

gui/MainWindow/MainWindow_Avatar.s: gui/MainWindow/MainWindow_Avatar.cpp.s
.PHONY : gui/MainWindow/MainWindow_Avatar.s

# target to generate assembly for a file
gui/MainWindow/MainWindow_Avatar.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/MainWindow_Avatar.cpp.s
.PHONY : gui/MainWindow/MainWindow_Avatar.cpp.s

gui/MainWindow/MainWindow_Pages.o: gui/MainWindow/MainWindow_Pages.cpp.o
.PHONY : gui/MainWindow/MainWindow_Pages.o

# target to build an object file
gui/MainWindow/MainWindow_Pages.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/MainWindow_Pages.cpp.o
.PHONY : gui/MainWindow/MainWindow_Pages.cpp.o

gui/MainWindow/MainWindow_Pages.i: gui/MainWindow/MainWindow_Pages.cpp.i
.PHONY : gui/MainWindow/MainWindow_Pages.i

# target to preprocess a source file
gui/MainWindow/MainWindow_Pages.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/MainWindow_Pages.cpp.i
.PHONY : gui/MainWindow/MainWindow_Pages.cpp.i

gui/MainWindow/MainWindow_Pages.s: gui/MainWindow/MainWindow_Pages.cpp.s
.PHONY : gui/MainWindow/MainWindow_Pages.s

# target to generate assembly for a file
gui/MainWindow/MainWindow_Pages.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/MainWindow_Pages.cpp.s
.PHONY : gui/MainWindow/MainWindow_Pages.cpp.s

gui/MainWindow/MainWindow_Slots.o: gui/MainWindow/MainWindow_Slots.cpp.o
.PHONY : gui/MainWindow/MainWindow_Slots.o

# target to build an object file
gui/MainWindow/MainWindow_Slots.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/MainWindow_Slots.cpp.o
.PHONY : gui/MainWindow/MainWindow_Slots.cpp.o

gui/MainWindow/MainWindow_Slots.i: gui/MainWindow/MainWindow_Slots.cpp.i
.PHONY : gui/MainWindow/MainWindow_Slots.i

# target to preprocess a source file
gui/MainWindow/MainWindow_Slots.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/MainWindow_Slots.cpp.i
.PHONY : gui/MainWindow/MainWindow_Slots.cpp.i

gui/MainWindow/MainWindow_Slots.s: gui/MainWindow/MainWindow_Slots.cpp.s
.PHONY : gui/MainWindow/MainWindow_Slots.s

# target to generate assembly for a file
gui/MainWindow/MainWindow_Slots.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/MainWindow_Slots.cpp.s
.PHONY : gui/MainWindow/MainWindow_Slots.cpp.s

gui/MainWindow/MainWindow_UI.o: gui/MainWindow/MainWindow_UI.cpp.o
.PHONY : gui/MainWindow/MainWindow_UI.o

# target to build an object file
gui/MainWindow/MainWindow_UI.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/MainWindow_UI.cpp.o
.PHONY : gui/MainWindow/MainWindow_UI.cpp.o

gui/MainWindow/MainWindow_UI.i: gui/MainWindow/MainWindow_UI.cpp.i
.PHONY : gui/MainWindow/MainWindow_UI.i

# target to preprocess a source file
gui/MainWindow/MainWindow_UI.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/MainWindow_UI.cpp.i
.PHONY : gui/MainWindow/MainWindow_UI.cpp.i

gui/MainWindow/MainWindow_UI.s: gui/MainWindow/MainWindow_UI.cpp.s
.PHONY : gui/MainWindow/MainWindow_UI.s

# target to generate assembly for a file
gui/MainWindow/MainWindow_UI.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/MainWindow_UI.cpp.s
.PHONY : gui/MainWindow/MainWindow_UI.cpp.s

gui/MainWindow/pages/FriendsPage.o: gui/MainWindow/pages/FriendsPage.cpp.o
.PHONY : gui/MainWindow/pages/FriendsPage.o

# target to build an object file
gui/MainWindow/pages/FriendsPage.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/pages/FriendsPage.cpp.o
.PHONY : gui/MainWindow/pages/FriendsPage.cpp.o

gui/MainWindow/pages/FriendsPage.i: gui/MainWindow/pages/FriendsPage.cpp.i
.PHONY : gui/MainWindow/pages/FriendsPage.i

# target to preprocess a source file
gui/MainWindow/pages/FriendsPage.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/pages/FriendsPage.cpp.i
.PHONY : gui/MainWindow/pages/FriendsPage.cpp.i

gui/MainWindow/pages/FriendsPage.s: gui/MainWindow/pages/FriendsPage.cpp.s
.PHONY : gui/MainWindow/pages/FriendsPage.s

# target to generate assembly for a file
gui/MainWindow/pages/FriendsPage.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/pages/FriendsPage.cpp.s
.PHONY : gui/MainWindow/pages/FriendsPage.cpp.s

gui/MainWindow/pages/MessagesPage.o: gui/MainWindow/pages/MessagesPage.cpp.o
.PHONY : gui/MainWindow/pages/MessagesPage.o

# target to build an object file
gui/MainWindow/pages/MessagesPage.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/pages/MessagesPage.cpp.o
.PHONY : gui/MainWindow/pages/MessagesPage.cpp.o

gui/MainWindow/pages/MessagesPage.i: gui/MainWindow/pages/MessagesPage.cpp.i
.PHONY : gui/MainWindow/pages/MessagesPage.i

# target to preprocess a source file
gui/MainWindow/pages/MessagesPage.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/pages/MessagesPage.cpp.i
.PHONY : gui/MainWindow/pages/MessagesPage.cpp.i

gui/MainWindow/pages/MessagesPage.s: gui/MainWindow/pages/MessagesPage.cpp.s
.PHONY : gui/MainWindow/pages/MessagesPage.s

# target to generate assembly for a file
gui/MainWindow/pages/MessagesPage.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/pages/MessagesPage.cpp.s
.PHONY : gui/MainWindow/pages/MessagesPage.cpp.s

gui/MainWindow/pages/MyMusicPage.o: gui/MainWindow/pages/MyMusicPage.cpp.o
.PHONY : gui/MainWindow/pages/MyMusicPage.o

# target to build an object file
gui/MainWindow/pages/MyMusicPage.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/pages/MyMusicPage.cpp.o
.PHONY : gui/MainWindow/pages/MyMusicPage.cpp.o

gui/MainWindow/pages/MyMusicPage.i: gui/MainWindow/pages/MyMusicPage.cpp.i
.PHONY : gui/MainWindow/pages/MyMusicPage.i

# target to preprocess a source file
gui/MainWindow/pages/MyMusicPage.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/pages/MyMusicPage.cpp.i
.PHONY : gui/MainWindow/pages/MyMusicPage.cpp.i

gui/MainWindow/pages/MyMusicPage.s: gui/MainWindow/pages/MyMusicPage.cpp.s
.PHONY : gui/MainWindow/pages/MyMusicPage.s

# target to generate assembly for a file
gui/MainWindow/pages/MyMusicPage.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/pages/MyMusicPage.cpp.s
.PHONY : gui/MainWindow/pages/MyMusicPage.cpp.s

gui/MainWindow/pages/RoomsPage.o: gui/MainWindow/pages/RoomsPage.cpp.o
.PHONY : gui/MainWindow/pages/RoomsPage.o

# target to build an object file
gui/MainWindow/pages/RoomsPage.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/pages/RoomsPage.cpp.o
.PHONY : gui/MainWindow/pages/RoomsPage.cpp.o

gui/MainWindow/pages/RoomsPage.i: gui/MainWindow/pages/RoomsPage.cpp.i
.PHONY : gui/MainWindow/pages/RoomsPage.i

# target to preprocess a source file
gui/MainWindow/pages/RoomsPage.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/pages/RoomsPage.cpp.i
.PHONY : gui/MainWindow/pages/RoomsPage.cpp.i

gui/MainWindow/pages/RoomsPage.s: gui/MainWindow/pages/RoomsPage.cpp.s
.PHONY : gui/MainWindow/pages/RoomsPage.s

# target to generate assembly for a file
gui/MainWindow/pages/RoomsPage.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/pages/RoomsPage.cpp.s
.PHONY : gui/MainWindow/pages/RoomsPage.cpp.s

gui/MainWindow/pages/SearchMusicPage.o: gui/MainWindow/pages/SearchMusicPage.cpp.o
.PHONY : gui/MainWindow/pages/SearchMusicPage.o

# target to build an object file
gui/MainWindow/pages/SearchMusicPage.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/pages/SearchMusicPage.cpp.o
.PHONY : gui/MainWindow/pages/SearchMusicPage.cpp.o

gui/MainWindow/pages/SearchMusicPage.i: gui/MainWindow/pages/SearchMusicPage.cpp.i
.PHONY : gui/MainWindow/pages/SearchMusicPage.i

# target to preprocess a source file
gui/MainWindow/pages/SearchMusicPage.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/pages/SearchMusicPage.cpp.i
.PHONY : gui/MainWindow/pages/SearchMusicPage.cpp.i

gui/MainWindow/pages/SearchMusicPage.s: gui/MainWindow/pages/SearchMusicPage.cpp.s
.PHONY : gui/MainWindow/pages/SearchMusicPage.s

# target to generate assembly for a file
gui/MainWindow/pages/SearchMusicPage.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/MainWindow/pages/SearchMusicPage.cpp.s
.PHONY : gui/MainWindow/pages/SearchMusicPage.cpp.s

gui/widgets/ChatWidget.o: gui/widgets/ChatWidget.cpp.o
.PHONY : gui/widgets/ChatWidget.o

# target to build an object file
gui/widgets/ChatWidget.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/ChatWidget.cpp.o
.PHONY : gui/widgets/ChatWidget.cpp.o

gui/widgets/ChatWidget.i: gui/widgets/ChatWidget.cpp.i
.PHONY : gui/widgets/ChatWidget.i

# target to preprocess a source file
gui/widgets/ChatWidget.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/ChatWidget.cpp.i
.PHONY : gui/widgets/ChatWidget.cpp.i

gui/widgets/ChatWidget.s: gui/widgets/ChatWidget.cpp.s
.PHONY : gui/widgets/ChatWidget.s

# target to generate assembly for a file
gui/widgets/ChatWidget.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/ChatWidget.cpp.s
.PHONY : gui/widgets/ChatWidget.cpp.s

gui/widgets/FriendCard.o: gui/widgets/FriendCard.cpp.o
.PHONY : gui/widgets/FriendCard.o

# target to build an object file
gui/widgets/FriendCard.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/FriendCard.cpp.o
.PHONY : gui/widgets/FriendCard.cpp.o

gui/widgets/FriendCard.i: gui/widgets/FriendCard.cpp.i
.PHONY : gui/widgets/FriendCard.i

# target to preprocess a source file
gui/widgets/FriendCard.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/FriendCard.cpp.i
.PHONY : gui/widgets/FriendCard.cpp.i

gui/widgets/FriendCard.s: gui/widgets/FriendCard.cpp.s
.PHONY : gui/widgets/FriendCard.s

# target to generate assembly for a file
gui/widgets/FriendCard.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/FriendCard.cpp.s
.PHONY : gui/widgets/FriendCard.cpp.s

gui/widgets/MessageBubble.o: gui/widgets/MessageBubble.cpp.o
.PHONY : gui/widgets/MessageBubble.o

# target to build an object file
gui/widgets/MessageBubble.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/MessageBubble.cpp.o
.PHONY : gui/widgets/MessageBubble.cpp.o

gui/widgets/MessageBubble.i: gui/widgets/MessageBubble.cpp.i
.PHONY : gui/widgets/MessageBubble.i

# target to preprocess a source file
gui/widgets/MessageBubble.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/MessageBubble.cpp.i
.PHONY : gui/widgets/MessageBubble.cpp.i

gui/widgets/MessageBubble.s: gui/widgets/MessageBubble.cpp.s
.PHONY : gui/widgets/MessageBubble.s

# target to generate assembly for a file
gui/widgets/MessageBubble.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/MessageBubble.cpp.s
.PHONY : gui/widgets/MessageBubble.cpp.s

gui/widgets/RoomCard.o: gui/widgets/RoomCard.cpp.o
.PHONY : gui/widgets/RoomCard.o

# target to build an object file
gui/widgets/RoomCard.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/RoomCard.cpp.o
.PHONY : gui/widgets/RoomCard.cpp.o

gui/widgets/RoomCard.i: gui/widgets/RoomCard.cpp.i
.PHONY : gui/widgets/RoomCard.i

# target to preprocess a source file
gui/widgets/RoomCard.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/RoomCard.cpp.i
.PHONY : gui/widgets/RoomCard.cpp.i

gui/widgets/RoomCard.s: gui/widgets/RoomCard.cpp.s
.PHONY : gui/widgets/RoomCard.s

# target to generate assembly for a file
gui/widgets/RoomCard.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/RoomCard.cpp.s
.PHONY : gui/widgets/RoomCard.cpp.s

gui/widgets/Sidebar.o: gui/widgets/Sidebar.cpp.o
.PHONY : gui/widgets/Sidebar.o

# target to build an object file
gui/widgets/Sidebar.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/Sidebar.cpp.o
.PHONY : gui/widgets/Sidebar.cpp.o

gui/widgets/Sidebar.i: gui/widgets/Sidebar.cpp.i
.PHONY : gui/widgets/Sidebar.i

# target to preprocess a source file
gui/widgets/Sidebar.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/Sidebar.cpp.i
.PHONY : gui/widgets/Sidebar.cpp.i

gui/widgets/Sidebar.s: gui/widgets/Sidebar.cpp.s
.PHONY : gui/widgets/Sidebar.s

# target to generate assembly for a file
gui/widgets/Sidebar.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/Sidebar.cpp.s
.PHONY : gui/widgets/Sidebar.cpp.s

gui/widgets/TrackListItem.o: gui/widgets/TrackListItem.cpp.o
.PHONY : gui/widgets/TrackListItem.o

# target to build an object file
gui/widgets/TrackListItem.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/TrackListItem.cpp.o
.PHONY : gui/widgets/TrackListItem.cpp.o

gui/widgets/TrackListItem.i: gui/widgets/TrackListItem.cpp.i
.PHONY : gui/widgets/TrackListItem.i

# target to preprocess a source file
gui/widgets/TrackListItem.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/TrackListItem.cpp.i
.PHONY : gui/widgets/TrackListItem.cpp.i

gui/widgets/TrackListItem.s: gui/widgets/TrackListItem.cpp.s
.PHONY : gui/widgets/TrackListItem.s

# target to generate assembly for a file
gui/widgets/TrackListItem.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/TrackListItem.cpp.s
.PHONY : gui/widgets/TrackListItem.cpp.s

gui/widgets/UserAvatar.o: gui/widgets/UserAvatar.cpp.o
.PHONY : gui/widgets/UserAvatar.o

# target to build an object file
gui/widgets/UserAvatar.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/UserAvatar.cpp.o
.PHONY : gui/widgets/UserAvatar.cpp.o

gui/widgets/UserAvatar.i: gui/widgets/UserAvatar.cpp.i
.PHONY : gui/widgets/UserAvatar.i

# target to preprocess a source file
gui/widgets/UserAvatar.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/UserAvatar.cpp.i
.PHONY : gui/widgets/UserAvatar.cpp.i

gui/widgets/UserAvatar.s: gui/widgets/UserAvatar.cpp.s
.PHONY : gui/widgets/UserAvatar.s

# target to generate assembly for a file
gui/widgets/UserAvatar.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/gui/widgets/UserAvatar.cpp.s
.PHONY : gui/widgets/UserAvatar.cpp.s

main.o: main.cpp.o
.PHONY : main.o

# target to build an object file
main.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/main.cpp.o
.PHONY : main.cpp.o

main.i: main.cpp.i
.PHONY : main.i

# target to preprocess a source file
main.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/main.cpp.i
.PHONY : main.cpp.i

main.s: main.cpp.s
.PHONY : main.s

# target to generate assembly for a file
main.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/main.cpp.s
.PHONY : main.cpp.s

network/ChatManager.o: network/ChatManager.cpp.o
.PHONY : network/ChatManager.o

# target to build an object file
network/ChatManager.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/network/ChatManager.cpp.o
.PHONY : network/ChatManager.cpp.o

network/ChatManager.i: network/ChatManager.cpp.i
.PHONY : network/ChatManager.i

# target to preprocess a source file
network/ChatManager.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/network/ChatManager.cpp.i
.PHONY : network/ChatManager.cpp.i

network/ChatManager.s: network/ChatManager.cpp.s
.PHONY : network/ChatManager.s

# target to generate assembly for a file
network/ChatManager.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/network/ChatManager.cpp.s
.PHONY : network/ChatManager.cpp.s

network/FriendManager.o: network/FriendManager.cpp.o
.PHONY : network/FriendManager.o

# target to build an object file
network/FriendManager.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/network/FriendManager.cpp.o
.PHONY : network/FriendManager.cpp.o

network/FriendManager.i: network/FriendManager.cpp.i
.PHONY : network/FriendManager.i

# target to preprocess a source file
network/FriendManager.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/network/FriendManager.cpp.i
.PHONY : network/FriendManager.cpp.i

network/FriendManager.s: network/FriendManager.cpp.s
.PHONY : network/FriendManager.s

# target to generate assembly for a file
network/FriendManager.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/network/FriendManager.cpp.s
.PHONY : network/FriendManager.cpp.s

network/RadioBrowserAPI.o: network/RadioBrowserAPI.cpp.o
.PHONY : network/RadioBrowserAPI.o

# target to build an object file
network/RadioBrowserAPI.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/network/RadioBrowserAPI.cpp.o
.PHONY : network/RadioBrowserAPI.cpp.o

network/RadioBrowserAPI.i: network/RadioBrowserAPI.cpp.i
.PHONY : network/RadioBrowserAPI.i

# target to preprocess a source file
network/RadioBrowserAPI.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/network/RadioBrowserAPI.cpp.i
.PHONY : network/RadioBrowserAPI.cpp.i

network/RadioBrowserAPI.s: network/RadioBrowserAPI.cpp.s
.PHONY : network/RadioBrowserAPI.s

# target to generate assembly for a file
network/RadioBrowserAPI.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/network/RadioBrowserAPI.cpp.s
.PHONY : network/RadioBrowserAPI.cpp.s

network/RoomManager.o: network/RoomManager.cpp.o
.PHONY : network/RoomManager.o

# target to build an object file
network/RoomManager.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/network/RoomManager.cpp.o
.PHONY : network/RoomManager.cpp.o

network/RoomManager.i: network/RoomManager.cpp.i
.PHONY : network/RoomManager.i

# target to preprocess a source file
network/RoomManager.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/network/RoomManager.cpp.i
.PHONY : network/RoomManager.cpp.i

network/RoomManager.s: network/RoomManager.cpp.s
.PHONY : network/RoomManager.s

# target to generate assembly for a file
network/RoomManager.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/network/RoomManager.cpp.s
.PHONY : network/RoomManager.cpp.s

network/WebSocketClient.o: network/WebSocketClient.cpp.o
.PHONY : network/WebSocketClient.o

# target to build an object file
network/WebSocketClient.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/network/WebSocketClient.cpp.o
.PHONY : network/WebSocketClient.cpp.o

network/WebSocketClient.i: network/WebSocketClient.cpp.i
.PHONY : network/WebSocketClient.i

# target to preprocess a source file
network/WebSocketClient.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/network/WebSocketClient.cpp.i
.PHONY : network/WebSocketClient.cpp.i

network/WebSocketClient.s: network/WebSocketClient.cpp.s
.PHONY : network/WebSocketClient.s

# target to generate assembly for a file
network/WebSocketClient.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/network/WebSocketClient.cpp.s
.PHONY : network/WebSocketClient.cpp.s

utils/Config.o: utils/Config.cpp.o
.PHONY : utils/Config.o

# target to build an object file
utils/Config.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/utils/Config.cpp.o
.PHONY : utils/Config.cpp.o

utils/Config.i: utils/Config.cpp.i
.PHONY : utils/Config.i

# target to preprocess a source file
utils/Config.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/utils/Config.cpp.i
.PHONY : utils/Config.cpp.i

utils/Config.s: utils/Config.cpp.s
.PHONY : utils/Config.s

# target to generate assembly for a file
utils/Config.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/utils/Config.cpp.s
.PHONY : utils/Config.cpp.s

utils/FileUtils.o: utils/FileUtils.cpp.o
.PHONY : utils/FileUtils.o

# target to build an object file
utils/FileUtils.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/utils/FileUtils.cpp.o
.PHONY : utils/FileUtils.cpp.o

utils/FileUtils.i: utils/FileUtils.cpp.i
.PHONY : utils/FileUtils.i

# target to preprocess a source file
utils/FileUtils.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/utils/FileUtils.cpp.i
.PHONY : utils/FileUtils.cpp.i

utils/FileUtils.s: utils/FileUtils.cpp.s
.PHONY : utils/FileUtils.s

# target to generate assembly for a file
utils/FileUtils.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/utils/FileUtils.cpp.s
.PHONY : utils/FileUtils.cpp.s

utils/ImageUtils.o: utils/ImageUtils.cpp.o
.PHONY : utils/ImageUtils.o

# target to build an object file
utils/ImageUtils.cpp.o:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/utils/ImageUtils.cpp.o
.PHONY : utils/ImageUtils.cpp.o

utils/ImageUtils.i: utils/ImageUtils.cpp.i
.PHONY : utils/ImageUtils.i

# target to preprocess a source file
utils/ImageUtils.cpp.i:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/utils/ImageUtils.cpp.i
.PHONY : utils/ImageUtils.cpp.i

utils/ImageUtils.s: utils/ImageUtils.cpp.s
.PHONY : utils/ImageUtils.s

# target to generate assembly for a file
utils/ImageUtils.cpp.s:
	$(MAKE) $(MAKESILENT) -f CMakeFiles/Chorus.dir/build.make CMakeFiles/Chorus.dir/utils/ImageUtils.cpp.s
.PHONY : utils/ImageUtils.cpp.s

# Help Target
help:
	@echo "The following are some of the valid targets for this Makefile:"
	@echo "... all (the default if no target is provided)"
	@echo "... clean"
	@echo "... depend"
	@echo "... edit_cache"
	@echo "... install"
	@echo "... install/local"
	@echo "... install/strip"
	@echo "... list_install_components"
	@echo "... rebuild_cache"
	@echo "... Chorus_autogen"
	@echo "... Chorus_autogen_timestamp_deps"
	@echo "... Chorus"
	@echo "... Chorus_autogen/mocs_compilation.o"
	@echo "... Chorus_autogen/mocs_compilation.i"
	@echo "... Chorus_autogen/mocs_compilation.s"
	@echo "... audio/AudioPlayer.o"
	@echo "... audio/AudioPlayer.i"
	@echo "... audio/AudioPlayer.s"
	@echo "... audio/LocalFileHandler.o"
	@echo "... audio/LocalFileHandler.i"
	@echo "... audio/LocalFileHandler.s"
	@echo "... audio/PlaybackController.o"
	@echo "... audio/PlaybackController.i"
	@echo "... audio/PlaybackController.s"
	@echo "... audio/TrackWidget.o"
	@echo "... audio/TrackWidget.i"
	@echo "... audio/TrackWidget.s"
	@echo "... core/managers/PlaylistManager.o"
	@echo "... core/managers/PlaylistManager.i"
	@echo "... core/managers/PlaylistManager.s"
	@echo "... core/managers/TrackManager.o"
	@echo "... core/managers/TrackManager.i"
	@echo "... core/managers/TrackManager.s"
	@echo "... core/managers/UserManager.o"
	@echo "... core/managers/UserManager.i"
	@echo "... core/managers/UserManager.s"
	@echo "... database/DatabaseManager.o"
	@echo "... database/DatabaseManager.i"
	@echo "... database/DatabaseManager.s"
	@echo "... database/api/MusicAPIManager.o"
	@echo "... database/api/MusicAPIManager.i"
	@echo "... database/api/MusicAPIManager.s"
	@echo "... gui/AuthWindow/AuthWindow.o"
	@echo "... gui/AuthWindow/AuthWindow.i"
	@echo "... gui/AuthWindow/AuthWindow.s"
	@echo "... gui/AuthWindow/widgets/LoginForm.o"
	@echo "... gui/AuthWindow/widgets/LoginForm.i"
	@echo "... gui/AuthWindow/widgets/LoginForm.s"
	@echo "... gui/AuthWindow/widgets/RegisterForm.o"
	@echo "... gui/AuthWindow/widgets/RegisterForm.i"
	@echo "... gui/AuthWindow/widgets/RegisterForm.s"
	@echo "... gui/Frameless/FramelessWindow.o"
	@echo "... gui/Frameless/FramelessWindow.i"
	@echo "... gui/Frameless/FramelessWindow.s"
	@echo "... gui/MainWindow/MainWindow.o"
	@echo "... gui/MainWindow/MainWindow.i"
	@echo "... gui/MainWindow/MainWindow.s"
	@echo "... gui/MainWindow/MainWindow_Avatar.o"
	@echo "... gui/MainWindow/MainWindow_Avatar.i"
	@echo "... gui/MainWindow/MainWindow_Avatar.s"
	@echo "... gui/MainWindow/MainWindow_Pages.o"
	@echo "... gui/MainWindow/MainWindow_Pages.i"
	@echo "... gui/MainWindow/MainWindow_Pages.s"
	@echo "... gui/MainWindow/MainWindow_Slots.o"
	@echo "... gui/MainWindow/MainWindow_Slots.i"
	@echo "... gui/MainWindow/MainWindow_Slots.s"
	@echo "... gui/MainWindow/MainWindow_UI.o"
	@echo "... gui/MainWindow/MainWindow_UI.i"
	@echo "... gui/MainWindow/MainWindow_UI.s"
	@echo "... gui/MainWindow/pages/FriendsPage.o"
	@echo "... gui/MainWindow/pages/FriendsPage.i"
	@echo "... gui/MainWindow/pages/FriendsPage.s"
	@echo "... gui/MainWindow/pages/MessagesPage.o"
	@echo "... gui/MainWindow/pages/MessagesPage.i"
	@echo "... gui/MainWindow/pages/MessagesPage.s"
	@echo "... gui/MainWindow/pages/MyMusicPage.o"
	@echo "... gui/MainWindow/pages/MyMusicPage.i"
	@echo "... gui/MainWindow/pages/MyMusicPage.s"
	@echo "... gui/MainWindow/pages/RoomsPage.o"
	@echo "... gui/MainWindow/pages/RoomsPage.i"
	@echo "... gui/MainWindow/pages/RoomsPage.s"
	@echo "... gui/MainWindow/pages/SearchMusicPage.o"
	@echo "... gui/MainWindow/pages/SearchMusicPage.i"
	@echo "... gui/MainWindow/pages/SearchMusicPage.s"
	@echo "... gui/widgets/ChatWidget.o"
	@echo "... gui/widgets/ChatWidget.i"
	@echo "... gui/widgets/ChatWidget.s"
	@echo "... gui/widgets/FriendCard.o"
	@echo "... gui/widgets/FriendCard.i"
	@echo "... gui/widgets/FriendCard.s"
	@echo "... gui/widgets/MessageBubble.o"
	@echo "... gui/widgets/MessageBubble.i"
	@echo "... gui/widgets/MessageBubble.s"
	@echo "... gui/widgets/RoomCard.o"
	@echo "... gui/widgets/RoomCard.i"
	@echo "... gui/widgets/RoomCard.s"
	@echo "... gui/widgets/Sidebar.o"
	@echo "... gui/widgets/Sidebar.i"
	@echo "... gui/widgets/Sidebar.s"
	@echo "... gui/widgets/TrackListItem.o"
	@echo "... gui/widgets/TrackListItem.i"
	@echo "... gui/widgets/TrackListItem.s"
	@echo "... gui/widgets/UserAvatar.o"
	@echo "... gui/widgets/UserAvatar.i"
	@echo "... gui/widgets/UserAvatar.s"
	@echo "... main.o"
	@echo "... main.i"
	@echo "... main.s"
	@echo "... network/ChatManager.o"
	@echo "... network/ChatManager.i"
	@echo "... network/ChatManager.s"
	@echo "... network/FriendManager.o"
	@echo "... network/FriendManager.i"
	@echo "... network/FriendManager.s"
	@echo "... network/RadioBrowserAPI.o"
	@echo "... network/RadioBrowserAPI.i"
	@echo "... network/RadioBrowserAPI.s"
	@echo "... network/RoomManager.o"
	@echo "... network/RoomManager.i"
	@echo "... network/RoomManager.s"
	@echo "... network/WebSocketClient.o"
	@echo "... network/WebSocketClient.i"
	@echo "... network/WebSocketClient.s"
	@echo "... utils/Config.o"
	@echo "... utils/Config.i"
	@echo "... utils/Config.s"
	@echo "... utils/FileUtils.o"
	@echo "... utils/FileUtils.i"
	@echo "... utils/FileUtils.s"
	@echo "... utils/ImageUtils.o"
	@echo "... utils/ImageUtils.i"
	@echo "... utils/ImageUtils.s"
.PHONY : help



#=============================================================================
# Special targets to cleanup operation of make.

# Special rule to run CMake to check the build system integrity.
# No rule that depends on this can have commands that come from listfiles
# because they might be regenerated.
cmake_check_build_system:
	$(CMAKE_COMMAND) -S$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 0
.PHONY : cmake_check_build_system



=== kursach/src/database/DatabaseManager.cpp ===
#include "DatabaseManager.h"
#include <QCryptographicHash>
#include <QDebug>
#include <QSqlError>
#include <QSqlQuery>
#include <QCoreApplication>
#include <QFileInfo>
#include <QDateTime>

QMutex DatabaseManager::m_mutex;

DatabaseManager& DatabaseManager::instance() {
    static DatabaseManager instance;
    return instance;
}

DatabaseManager::DatabaseManager(QObject *parent) 
    : QObject(parent), m_initialized(false) {}

DatabaseManager::~DatabaseManager() {
    if (m_db.isOpen()) {
        m_db.close();
    }
}

bool DatabaseManager::initialize() {
    QMutexLocker locker(&m_mutex);
    
    if (m_initialized && m_db.isOpen()) {
        return true;
    }
    
    return openConnection();
}

bool DatabaseManager::openConnection() {
    if (m_db.isOpen()) {
        m_db.close();
    }
    
    m_db = QSqlDatabase::addDatabase("QPSQL", "soundspace_connection");
    
    if (!m_db.isValid()) {
        qDebug() << "PostgreSQL driver unavailable";
        return false;
    }
    
    m_db.setHostName("turntable.proxy.rlwy.net");
    m_db.setPort(26533);
    m_db.setDatabaseName("railway");
    m_db.setUserName("postgres");
    m_db.setPassword("__REMOVED__");
    m_db.setConnectOptions("connect_timeout=10");
    
    if (!m_db.open()) {
        qDebug() << "Connection error:" << m_db.lastError().text();
        return false;
    }
    
    if (!createTables()) {
        qDebug() << "Table creation error";
        return false;
    }
    
    m_initialized = true;
    return true;
}

bool DatabaseManager::createTables() {
    if (!m_db.isOpen()) {
        return false;
    }
    
    bool success = true;
    
    QString createUsers = 
        "CREATE TABLE IF NOT EXISTS users ("
        "id SERIAL PRIMARY KEY, "
        "username VARCHAR(50) UNIQUE NOT NULL, "
        "password_hash VARCHAR(64) NOT NULL, "
        "email VARCHAR(100), "
        "avatar_path TEXT, "
        "status INTEGER DEFAULT 0, "
        "bio TEXT, "
        "last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP, "
        "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)";
    
    QSqlQuery query(m_db);
    if (!query.exec(createUsers)) {
        qDebug() << "users error:" << query.lastError().text();
        success = false;
    }
    
    QString createTracks = 
        "CREATE TABLE IF NOT EXISTS tracks ("
        "id SERIAL PRIMARY KEY, "
        "file_path TEXT NOT NULL, "
        "file_hash VARCHAR(64) NOT NULL, "
        "user_id INTEGER NOT NULL, "
        "title TEXT NOT NULL, "
        "artist TEXT NOT NULL, "
        "album TEXT, "
        "duration INTEGER DEFAULT 0, "
        "play_count INTEGER DEFAULT 0, "
        "added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, "
        "cover_url TEXT, "
        "genre TEXT, "
        "year INTEGER, "
        "bitrate INTEGER, "
        "sample_rate INTEGER)";

    if (!query.exec(createTracks)) {
        qDebug() << "tracks error:" << query.lastError().text();
        success = false;
    }
    
    QString createRadioStations = 
        "CREATE TABLE IF NOT EXISTS radio_stations ("
        "id SERIAL PRIMARY KEY, "
        "user_id INTEGER NOT NULL, "
        "name VARCHAR(255) NOT NULL, "
        "country VARCHAR(100), "
        "stream_url TEXT NOT NULL, "
        "genre VARCHAR(100), "
        "bitrate INTEGER DEFAULT 128, "
        "favicon TEXT, "
        "play_count INTEGER DEFAULT 0, "
        "is_favorite BOOLEAN DEFAULT false, "
        "added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)";
    
    if (!query.exec(createRadioStations)) {
        qDebug() << "radio_stations error:" << query.lastError().text();
        success = false;
    }
    
    QString createRadioShares = 
        "CREATE TABLE IF NOT EXISTS radio_shares ("
        "id SERIAL PRIMARY KEY, "
        "station_id INTEGER NOT NULL, "
        "shared_by INTEGER NOT NULL, "
        "shared_with INTEGER NOT NULL, "
        "shared_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)";
    
    if (!query.exec(createRadioShares)) {
        qDebug() << "radio_shares error:" << query.lastError().text();
        success = false;
    }
    
    QString createRadioStatus = 
        "CREATE TABLE IF NOT EXISTS radio_status ("
        "id SERIAL PRIMARY KEY, "
        "user_id INTEGER NOT NULL, "
        "station_id INTEGER NOT NULL, "
        "status_text TEXT, "
        "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)";
    
    if (!query.exec(createRadioStatus)) {
        qDebug() << "radio_status error:" << query.lastError().text();
        success = false;
    }
    
    QString createPlaylists = 
        "CREATE TABLE IF NOT EXISTS playlists ("
        "id SERIAL PRIMARY KEY, "
        "user_id INTEGER NOT NULL, "
        "name VARCHAR(100) NOT NULL, "
        "description TEXT, "
        "cover_url TEXT, "
        "is_public BOOLEAN DEFAULT false, "
        "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)";
    
    if (!query.exec(createPlaylists)) {
        qDebug() << "playlists error:" << query.lastError().text();
        success = false;
    }
    
    QString createPlaylistTracks = 
        "CREATE TABLE IF NOT EXISTS playlist_tracks ("
        "playlist_id INTEGER NOT NULL, "
        "track_id INTEGER NOT NULL, "
        "position INTEGER DEFAULT 0, "
        "added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, "
        "PRIMARY KEY (playlist_id, track_id))";
    
    if (!query.exec(createPlaylistTracks)) {
        qDebug() << "playlist_tracks error:" << query.lastError().text();
        success = false;
    }
    
    QString createFriendRequests = 
        "CREATE TABLE IF NOT EXISTS friend_requests ("
        "id SERIAL PRIMARY KEY, "
        "sender_id INTEGER NOT NULL, "
        "receiver_id INTEGER NOT NULL, "
        "status VARCHAR(20) DEFAULT 'pending', "
        "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, "
        "UNIQUE(sender_id, receiver_id))";
    
    if (!query.exec(createFriendRequests)) {
        qDebug() << "friend_requests error:" << query.lastError().text();
        success = false;
    }
    
    QString createFriendships = 
        "CREATE TABLE IF NOT EXISTS friendships ("
        "user_id INTEGER NOT NULL, "
        "friend_id INTEGER NOT NULL, "
        "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, "
        "PRIMARY KEY (user_id, friend_id))";
    
    if (!query.exec(createFriendships)) {
        qDebug() << "friendships error:" << query.lastError().text();
        success = false;
    }
    
    QString createMessages = 
        "CREATE TABLE IF NOT EXISTS messages ("
        "id SERIAL PRIMARY KEY, "
        "sender_id INTEGER NOT NULL, "
        "receiver_id INTEGER NOT NULL, "
        "content TEXT, "
        "type INTEGER DEFAULT 0, "
        "timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP, "
        "is_read BOOLEAN DEFAULT false, "
        "shared_track_id INTEGER, "
        "shared_station_id INTEGER)";
    
    if (!query.exec(createMessages)) {
        qDebug() << "messages error:" << query.lastError().text();
        success = false;
    }
    
    QString createRooms = 
        "CREATE TABLE IF NOT EXISTS rooms ("
        "id SERIAL PRIMARY KEY, "
        "name VARCHAR(100) NOT NULL, "
        "description TEXT, "
        "genre VARCHAR(50), "
        "host_id INTEGER NOT NULL, "
        "current_track_id INTEGER, "
        "current_station_id INTEGER, "
        "current_position BIGINT DEFAULT 0, "
        "is_playing BOOLEAN DEFAULT false, "
        "max_members INTEGER DEFAULT 10, "
        "is_private BOOLEAN DEFAULT false, "
        "password VARCHAR(64), "
        "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)";
    
    if (!query.exec(createRooms)) {
        qDebug() << "rooms error:" << query.lastError().text();
        success = false;
    }
    
    QString createRoomMembers = 
        "CREATE TABLE IF NOT EXISTS room_members ("
        "room_id INTEGER NOT NULL, "
        "user_id INTEGER NOT NULL, "
        "is_host BOOLEAN DEFAULT false, "
        "can_control BOOLEAN DEFAULT false, "
        "joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, "
        "PRIMARY KEY (room_id, user_id))";
    
    if (!query.exec(createRoomMembers)) {
        qDebug() << "room_members error:" << query.lastError().text();
        success = false;
    }
    
    query.exec("CREATE INDEX IF NOT EXISTS idx_tracks_user ON tracks(user_id)");
    query.exec("CREATE INDEX IF NOT EXISTS idx_radio_stations_user ON radio_stations(user_id)");
    query.exec("CREATE INDEX IF NOT EXISTS idx_messages_receiver ON messages(receiver_id, is_read)");
    query.exec("CREATE INDEX IF NOT EXISTS idx_friendships ON friendships(user_id)");
    query.exec("CREATE INDEX IF NOT EXISTS idx_room_members ON room_members(room_id)");
    
    if (success) {
        QString testPass = hashPassword("test123");
        query.prepare("INSERT INTO users (username, password_hash) "
                     "SELECT 'testuser', ? WHERE NOT EXISTS "
                     "(SELECT 1 FROM users WHERE username = 'testuser')");
        query.addBindValue(testPass);
        query.exec();
    }
    
    return success;
}

bool DatabaseManager::isConnected() const {
    return m_db.isOpen();
}

QString DatabaseManager::hashPassword(const QString& password) {
    return QCryptographicHash::hash(password.toUtf8(), 
                                   QCryptographicHash::Sha256).toHex();
}

QString DatabaseManager::generateFileHash(const QString& filePath) {
    QString uniqueString = QString("%1_%2").arg(filePath).arg(QDateTime::currentMSecsSinceEpoch());
    return QCryptographicHash::hash(uniqueString.toUtf8(), 
                                   QCryptographicHash::Md5).toHex();
}

bool DatabaseManager::registerUser(const QString& username, const QString& password) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return false;
    }
    
    if (username.isEmpty() || password.isEmpty() || username.length() < 3 || password.length() < 6) {
        return false;
    }
    
    QSqlQuery checkQuery(m_db);
    checkQuery.prepare("SELECT id FROM users WHERE username = ?");
    checkQuery.addBindValue(username);
    
    if (checkQuery.exec() && checkQuery.next()) {
        return false;
    }
    
    QSqlQuery insertQuery(m_db);
    insertQuery.prepare("INSERT INTO users (username, password_hash) VALUES (?, ?)");
    insertQuery.addBindValue(username);
    insertQuery.addBindValue(hashPassword(password));
    
    return insertQuery.exec();
}

bool DatabaseManager::authenticateUser(const QString& username, const QString& password) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return false;
    }
    
    QSqlQuery query(m_db);
    query.prepare("SELECT id, password_hash FROM users WHERE username = ?");
    query.addBindValue(username);
    
    if (!query.exec() || !query.next()) {
        return false;
    }
    
    QString storedHash = query.value("password_hash").toString();
    QString inputHash = hashPassword(password);
    
    return (storedHash == inputHash);
}

int DatabaseManager::getUserId(const QString& username) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return -1;
    }
    
    QSqlQuery query(m_db);
    query.prepare("SELECT id FROM users WHERE username = ?");
    query.addBindValue(username);
    
    if (query.exec() && query.next()) {
        return query.value("id").toInt();
    }
    
    return -1;
}

bool DatabaseManager::addTrack(const QString& filePath, const QString& title, 
                              const QString& artist, const QString& album, 
                              int duration, int userId) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return false;
    }
    
    QString fileHash = generateFileHash(filePath);
    
    QSqlQuery query(m_db);
    query.prepare(
        "INSERT INTO tracks (file_path, file_hash, user_id, title, artist, album, duration) "
        "VALUES (?, ?, ?, ?, ?, ?, ?)"
    );
    
    query.addBindValue(filePath);
    query.addBindValue(fileHash);
    query.addBindValue(userId);
    query.addBindValue(title);
    query.addBindValue(artist);
    query.addBindValue(album);
    query.addBindValue(duration);
    
    return query.exec();
}

QList<TrackData> DatabaseManager::getUserTracks(int userId) {
    QList<TrackData> tracks;
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return tracks;
    }
    
    QSqlQuery query(m_db);
    query.prepare(
        "SELECT id, file_path, file_hash, title, artist, album, duration, "
        "play_count, added_at "
        "FROM tracks WHERE user_id = ? ORDER BY added_at DESC"
    );
    query.addBindValue(userId);
    
    if (query.exec()) {
        while (query.next()) {
            TrackData track;
            track.id = query.value("id").toInt();
            track.filePath = query.value("file_path").toString();
            track.fileHash = query.value("file_hash").toString();
            track.title = query.value("title").toString();
            track.artist = query.value("artist").toString();
            track.album = query.value("album").toString();
            track.duration = query.value("duration").toInt();
            track.playCount = query.value("play_count").toInt();
            track.addedAt = query.value("added_at").toString();
            
            tracks.append(track);
        }
    }
    
    return tracks;
}

bool DatabaseManager::incrementPlayCount(int trackId) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return false;
    }
    
    QSqlQuery query(m_db);
    query.prepare("UPDATE tracks SET play_count = play_count + 1 WHERE id = ?");
    query.addBindValue(trackId);
    
    return query.exec();
}

bool DatabaseManager::deleteTrack(int trackId) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return false;
    }
    
    QSqlQuery deleteFromPlaylists(m_db);
    deleteFromPlaylists.prepare("DELETE FROM playlist_tracks WHERE track_id = ?");
    deleteFromPlaylists.addBindValue(trackId);
    deleteFromPlaylists.exec();
    
    QSqlQuery deleteTrackQuery(m_db);
    deleteTrackQuery.prepare("DELETE FROM tracks WHERE id = ?");
    deleteTrackQuery.addBindValue(trackId);
    
    return deleteTrackQuery.exec();
}

bool DatabaseManager::addRadioStation(int userId, const QString& name, const QString& country,
                                      const QString& streamUrl, const QString& genre, int bitrate)
{
    QMutexLocker locker(&m_mutex);

    if (!m_db.isOpen()) {
        if (!initialize()) return false;
    }

    QSqlQuery query(m_db);
    query.prepare(
        "INSERT INTO radio_stations (user_id, name, country, stream_url, genre, bitrate, added_at) "
        "VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)"
    );
    
    query.addBindValue(userId);
    query.addBindValue(name);
    query.addBindValue(country);
    query.addBindValue(streamUrl);
    query.addBindValue(genre);
    query.addBindValue(bitrate);

    if (!query.exec()) {
        qWarning() << "Add radio station error:" << query.lastError().text();
        return false;
    }
    return true;
}

QList<TrackData> DatabaseManager::getUserRadioStations(int userId) {
    QList<TrackData> stations;
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return stations;
    }
    
    QSqlQuery query(m_db);
    query.prepare(
        "SELECT id, name, country, stream_url, genre, bitrate, favicon, play_count, added_at "
        "FROM radio_stations WHERE user_id = ? ORDER BY added_at DESC"
    );
    query.addBindValue(userId);
    
    if (query.exec()) {
        while (query.next()) {
            TrackData station;
            station.id = query.value("id").toInt();
            station.title = query.value("name").toString();
            station.artist = query.value("country").toString();
            station.streamUrl = query.value("stream_url").toString();
            station.album = query.value("genre").toString();
            station.bitrate = query.value("bitrate").toInt();
            station.cover = query.value("favicon").toString();
            station.playCount = query.value("play_count").toInt();
            station.addedAt = query.value("added_at").toString();
            
            stations.append(station);
        }
    }
    
    return stations;
}

bool DatabaseManager::deleteRadioStation(int stationId) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return false;
    }
    
    QSqlQuery query(m_db);
    query.prepare("DELETE FROM radio_stations WHERE id = ?");
    query.addBindValue(stationId);
    
    return query.exec();
}

bool DatabaseManager::incrementRadioPlayCount(int stationId) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return false;
    }
    
    QSqlQuery query(m_db);
    query.prepare("UPDATE radio_stations SET play_count = play_count + 1 WHERE id = ?");
    query.addBindValue(stationId);
    
    return query.exec();
}

bool DatabaseManager::shareRadioStation(int userId, int stationId, const QStringList& friendIds) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return false;
    }
    
    QSqlQuery query(m_db);
    
    for (const QString& friendId : friendIds) {
        query.prepare(
            "INSERT INTO radio_shares (station_id, shared_by, shared_with, shared_at) "
            "VALUES (?, ?, ?, CURRENT_TIMESTAMP)"
        );
        query.addBindValue(stationId);
        query.addBindValue(userId);
        query.addBindValue(friendId.toInt());
        
        if (!query.exec()) {
            qWarning() << "Share radio station error:" << query.lastError().text();
            return false;
        }
    }
    
    return true;
}

bool DatabaseManager::addRadioToStatus(int userId, int stationId) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return false;
    }
    
    QSqlQuery query(m_db);
    query.prepare(
        "INSERT INTO radio_status (user_id, station_id, created_at) "
        "VALUES (?, ?, CURRENT_TIMESTAMP)"
    );
    query.addBindValue(userId);
    query.addBindValue(stationId);
    
    return query.exec();
}

QList<TrackData> DatabaseManager::getSharedRadioStations(int userId) {
    QList<TrackData> stations;
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return stations;
    }
    
    QSqlQuery query(m_db);
    query.prepare(
        "SELECT DISTINCT rs.id, rs.name, rs.country, rs.stream_url, rs.genre, rs.bitrate, rs.favicon, rs.play_count, rs.added_at "
        "FROM radio_stations rs "
        "INNER JOIN radio_shares share ON rs.id = share.station_id "
        "WHERE share.shared_with = ? "
        "ORDER BY rs.added_at DESC"
    );
    query.addBindValue(userId);
    
    if (query.exec()) {
        while (query.next()) {
            TrackData station;
            station.id = query.value("id").toInt();
            station.title = query.value("name").toString();
            station.artist = query.value("country").toString();
            station.streamUrl = query.value("stream_url").toString();
            station.album = query.value("genre").toString();
            station.bitrate = query.value("bitrate").toInt();
            station.cover = query.value("favicon").toString();
            station.playCount = query.value("play_count").toInt();
            station.addedAt = query.value("added_at").toString();
            
            stations.append(station);
        }
    }
    
    return stations;
}


=== kursach/src/database/DatabaseManager.h ===
#ifndef DATABASEMANAGER_H
#define DATABASEMANAGER_H

#include <QSqlDatabase>
#include <QString>
#include <QList>
#include <QMutex>
#include <QObject>
#include "core/models/Track.h"
#include "core/models/Playlist.h"

class DatabaseManager : public QObject
{
    Q_OBJECT

public:
    static DatabaseManager& instance();
    
    bool initialize();
    bool isConnected() const;
    QSqlDatabase database() { return m_db; }
    
    bool registerUser(const QString& username, const QString& password);
    bool authenticateUser(const QString& username, const QString& password);
    int getUserId(const QString& username);
    
    bool addTrack(const QString& filePath, const QString& title, 
                 const QString& artist, const QString& album, 
                 int duration, int userId);
    QList<TrackData> getUserTracks(int userId);
    bool incrementPlayCount(int trackId);
    bool deleteTrack(int trackId);
    
    bool addRadioStation(int userId, const QString& name, const QString& country,
                     const QString& streamUrl, const QString& genre, int bitrate);
    QList<TrackData> getUserRadioStations(int userId);
    bool deleteRadioStation(int stationId);
    bool incrementRadioPlayCount(int stationId);
    bool shareRadioStation(int userId, int stationId, const QStringList& friendIds);
    bool addRadioToStatus(int userId, int stationId);
    QList<TrackData> getSharedRadioStations(int userId);

private:
    DatabaseManager(QObject *parent = nullptr);
    ~DatabaseManager();
    DatabaseManager(const DatabaseManager&) = delete;
    DatabaseManager& operator=(const DatabaseManager&) = delete;
    
    bool openConnection();
    bool createTables();
    QString hashPassword(const QString& password);
    QString generateFileHash(const QString& filePath);
    
    QSqlDatabase m_db;
    static QMutex m_mutex;
    bool m_initialized;
};

#endif


=== kursach/src/database/api/MusicAPIManager.h ===
#ifndef MUSICAPIMANAGERH
#define MUSICAPIMANAGERH

#include <QObject>
#include <QVector>
#include <core/models/Track.h>
#include <network/RadioBrowserAPI.h>

class MusicAPIManager : public QObject
{
    Q_OBJECT

public:
    explicit MusicAPIManager(QObject *parent = nullptr);
    void searchStations(const QString &query, int userId);
    void getTopStations(int userId);
    void getStationsByGenre(const QString &genre, int userId);

signals:
    void stationsFound(const QVariantList &stations);
    void errorOccurred(const QString &error);

private slots:
    void onRadioBrowserStations(const QVariantList &stations);

private:
    RadioBrowserAPI *mradioBrowser;
};

#endif


=== kursach/src/database/api/MusicAPIManager.cpp ===
#include "MusicAPIManager.h"
#include <QVariantMap>

MusicAPIManager::MusicAPIManager(QObject *parent)
    : QObject(parent), mradioBrowser(new RadioBrowserAPI(this))
{
    connect(mradioBrowser, &RadioBrowserAPI::stationsReady,
            this, &MusicAPIManager::onRadioBrowserStations);
    connect(mradioBrowser, &RadioBrowserAPI::errorOccurred,
            this, &MusicAPIManager::errorOccurred);
}

void MusicAPIManager::searchStations(const QString &query, int userId)
{
    mradioBrowser->searchStations(query, 50);
}

void MusicAPIManager::getTopStations(int userId)
{
    mradioBrowser->getTopStations(50);
}

void MusicAPIManager::getStationsByGenre(const QString &genre, int userId)
{
    mradioBrowser->getStationsByGenre(genre, 50);
}

void MusicAPIManager::onRadioBrowserStations(const QVariantList &stations)
{
    emit stationsFound(stations);
}


=== kursach/src/Chorus_autogen/M7KQ2GL7XF/moc_DatabaseManager.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'DatabaseManager.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../database/DatabaseManager.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'DatabaseManager.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_DatabaseManager_t {
    QByteArrayData data[1];
    char stringdata0[16];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_DatabaseManager_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_DatabaseManager_t qt_meta_stringdata_DatabaseManager = {
    {
QT_MOC_LITERAL(0, 0, 15) // "DatabaseManager"

    },
    "DatabaseManager"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_DatabaseManager[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

void DatabaseManager::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

QT_INIT_METAOBJECT const QMetaObject DatabaseManager::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_DatabaseManager.data,
    qt_meta_data_DatabaseManager,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *DatabaseManager::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *DatabaseManager::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_DatabaseManager.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int DatabaseManager::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/KSTO76GMGS/moc_UserManager.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'UserManager.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../core/managers/UserManager.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'UserManager.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_UserManager_t {
    QByteArrayData data[7];
    char stringdata0[64];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_UserManager_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_UserManager_t qt_meta_stringdata_UserManager = {
    {
QT_MOC_LITERAL(0, 0, 11), // "UserManager"
QT_MOC_LITERAL(1, 12, 11), // "userUpdated"
QT_MOC_LITERAL(2, 24, 0), // ""
QT_MOC_LITERAL(3, 25, 6), // "userId"
QT_MOC_LITERAL(4, 32, 13), // "statusChanged"
QT_MOC_LITERAL(5, 46, 10), // "UserStatus"
QT_MOC_LITERAL(6, 57, 6) // "status"

    },
    "UserManager\0userUpdated\0\0userId\0"
    "statusChanged\0UserStatus\0status"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_UserManager[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       2,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       2,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    1,   24,    2, 0x06 /* Public */,
       4,    2,   27,    2, 0x06 /* Public */,

 // signals: parameters
    QMetaType::Void, QMetaType::Int,    3,
    QMetaType::Void, QMetaType::Int, 0x80000000 | 5,    3,    6,

       0        // eod
};

void UserManager::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<UserManager *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->userUpdated((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 1: _t->statusChanged((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< UserStatus(*)>(_a[2]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (UserManager::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&UserManager::userUpdated)) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (UserManager::*)(int , UserStatus );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&UserManager::statusChanged)) {
                *result = 1;
                return;
            }
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject UserManager::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_UserManager.data,
    qt_meta_data_UserManager,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *UserManager::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *UserManager::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_UserManager.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int UserManager::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 2)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 2;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 2)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 2;
    }
    return _id;
}

// SIGNAL 0
void UserManager::userUpdated(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}

// SIGNAL 1
void UserManager::statusChanged(int _t1, UserStatus _t2)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))) };
    QMetaObject::activate(this, &staticMetaObject, 1, _a);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/KSTO76GMGS/moc_TrackManager.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'TrackManager.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../core/managers/TrackManager.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'TrackManager.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_TrackManager_t {
    QByteArrayData data[6];
    char stringdata0[59];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_TrackManager_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_TrackManager_t qt_meta_stringdata_TrackManager = {
    {
QT_MOC_LITERAL(0, 0, 12), // "TrackManager"
QT_MOC_LITERAL(1, 13, 10), // "trackAdded"
QT_MOC_LITERAL(2, 24, 0), // ""
QT_MOC_LITERAL(3, 25, 7), // "trackId"
QT_MOC_LITERAL(4, 33, 12), // "trackDeleted"
QT_MOC_LITERAL(5, 46, 12) // "trackUpdated"

    },
    "TrackManager\0trackAdded\0\0trackId\0"
    "trackDeleted\0trackUpdated"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_TrackManager[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       3,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       3,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    1,   29,    2, 0x06 /* Public */,
       4,    1,   32,    2, 0x06 /* Public */,
       5,    1,   35,    2, 0x06 /* Public */,

 // signals: parameters
    QMetaType::Void, QMetaType::Int,    3,
    QMetaType::Void, QMetaType::Int,    3,
    QMetaType::Void, QMetaType::Int,    3,

       0        // eod
};

void TrackManager::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<TrackManager *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->trackAdded((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 1: _t->trackDeleted((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 2: _t->trackUpdated((*reinterpret_cast< int(*)>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (TrackManager::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&TrackManager::trackAdded)) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (TrackManager::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&TrackManager::trackDeleted)) {
                *result = 1;
                return;
            }
        }
        {
            using _t = void (TrackManager::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&TrackManager::trackUpdated)) {
                *result = 2;
                return;
            }
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject TrackManager::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_TrackManager.data,
    qt_meta_data_TrackManager,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *TrackManager::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *TrackManager::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_TrackManager.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int TrackManager::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 3)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 3;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 3)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 3;
    }
    return _id;
}

// SIGNAL 0
void TrackManager::trackAdded(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}

// SIGNAL 1
void TrackManager::trackDeleted(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 1, _a);
}

// SIGNAL 2
void TrackManager::trackUpdated(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 2, _a);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/KSTO76GMGS/moc_PlaylistManager.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'PlaylistManager.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../core/managers/PlaylistManager.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'PlaylistManager.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_PlaylistManager_t {
    QByteArrayData data[9];
    char stringdata0[108];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_PlaylistManager_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_PlaylistManager_t qt_meta_stringdata_PlaylistManager = {
    {
QT_MOC_LITERAL(0, 0, 15), // "PlaylistManager"
QT_MOC_LITERAL(1, 16, 15), // "playlistCreated"
QT_MOC_LITERAL(2, 32, 0), // ""
QT_MOC_LITERAL(3, 33, 10), // "playlistId"
QT_MOC_LITERAL(4, 44, 15), // "playlistDeleted"
QT_MOC_LITERAL(5, 60, 15), // "playlistUpdated"
QT_MOC_LITERAL(6, 76, 10), // "trackAdded"
QT_MOC_LITERAL(7, 87, 7), // "trackId"
QT_MOC_LITERAL(8, 95, 12) // "trackRemoved"

    },
    "PlaylistManager\0playlistCreated\0\0"
    "playlistId\0playlistDeleted\0playlistUpdated\0"
    "trackAdded\0trackId\0trackRemoved"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_PlaylistManager[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       5,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       5,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    1,   39,    2, 0x06 /* Public */,
       4,    1,   42,    2, 0x06 /* Public */,
       5,    1,   45,    2, 0x06 /* Public */,
       6,    2,   48,    2, 0x06 /* Public */,
       8,    2,   53,    2, 0x06 /* Public */,

 // signals: parameters
    QMetaType::Void, QMetaType::Int,    3,
    QMetaType::Void, QMetaType::Int,    3,
    QMetaType::Void, QMetaType::Int,    3,
    QMetaType::Void, QMetaType::Int, QMetaType::Int,    3,    7,
    QMetaType::Void, QMetaType::Int, QMetaType::Int,    3,    7,

       0        // eod
};

void PlaylistManager::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<PlaylistManager *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->playlistCreated((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 1: _t->playlistDeleted((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 2: _t->playlistUpdated((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 3: _t->trackAdded((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
        case 4: _t->trackRemoved((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (PlaylistManager::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&PlaylistManager::playlistCreated)) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (PlaylistManager::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&PlaylistManager::playlistDeleted)) {
                *result = 1;
                return;
            }
        }
        {
            using _t = void (PlaylistManager::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&PlaylistManager::playlistUpdated)) {
                *result = 2;
                return;
            }
        }
        {
            using _t = void (PlaylistManager::*)(int , int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&PlaylistManager::trackAdded)) {
                *result = 3;
                return;
            }
        }
        {
            using _t = void (PlaylistManager::*)(int , int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&PlaylistManager::trackRemoved)) {
                *result = 4;
                return;
            }
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject PlaylistManager::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_PlaylistManager.data,
    qt_meta_data_PlaylistManager,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *PlaylistManager::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *PlaylistManager::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_PlaylistManager.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int PlaylistManager::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 5)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 5;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 5)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 5;
    }
    return _id;
}

// SIGNAL 0
void PlaylistManager::playlistCreated(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}

// SIGNAL 1
void PlaylistManager::playlistDeleted(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 1, _a);
}

// SIGNAL 2
void PlaylistManager::playlistUpdated(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 2, _a);
}

// SIGNAL 3
void PlaylistManager::trackAdded(int _t1, int _t2)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))) };
    QMetaObject::activate(this, &staticMetaObject, 3, _a);
}

// SIGNAL 4
void PlaylistManager::trackRemoved(int _t1, int _t2)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))) };
    QMetaObject::activate(this, &staticMetaObject, 4, _a);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/moc_predefs.h ===
#define __DBL_MIN_EXP__ (-1021)
#define __cpp_nontype_template_parameter_auto 201606L
#define __UINT_LEAST16_MAX__ 0xffff
#define __FLT16_HAS_QUIET_NAN__ 1
#define __ATOMIC_ACQUIRE 2
#define __FLT128_MAX_10_EXP__ 4932
#define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F
#define __GCC_IEC_559_COMPLEX 2
#define __cpp_aggregate_nsdmi 201304L
#define __UINT_LEAST8_TYPE__ unsigned char
#define __SIZEOF_FLOAT80__ 16
#define __BFLT16_DENORM_MIN__ 9.18354961579912115600575419704879436e-41BF16
#define __INTMAX_C(c) c ## L
#define __CHAR_BIT__ 8
#define __UINT8_MAX__ 0xff
#define __SCHAR_WIDTH__ 8
#define __WINT_MAX__ 0xffffffffU
#define __FLT32_MIN_EXP__ (-125)
#define __cpp_static_assert 201411L
#define __BFLT16_MIN_10_EXP__ (-37)
#define QT_GUI_LIB 1
#define __ORDER_LITTLE_ENDIAN__ 1234
#define __WCHAR_MAX__ 0x7fffffff
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
#define __GCC_ATOMIC_CHAR_LOCK_FREE 2
#define __GCC_IEC_559 2
#define __FLT32X_DECIMAL_DIG__ 17
#define __FLT_EVAL_METHOD__ 0
#define __cpp_binary_literals 201304L
#define __FLT64_DECIMAL_DIG__ 17
#define __CET__ 3
#define __cpp_noexcept_function_type 201510L
#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2
#define __cpp_variadic_templates 200704L
#define __UINT_FAST64_MAX__ 0xffffffffffffffffUL
#define __SIG_ATOMIC_TYPE__ int
#define __DBL_MIN_10_EXP__ (-307)
#define __FINITE_MATH_ONLY__ 0
#define __cpp_variable_templates 201304L
#define __FLT32X_MAX_EXP__ 1024
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
#define __FLT32_HAS_DENORM__ 1
#define __UINT_FAST8_MAX__ 0xff
#define __cpp_rvalue_reference 200610L
#define __cpp_nested_namespace_definitions 201411L
#define __DEC64_MAX_EXP__ 385
#define __INT8_C(c) c
#define __LDBL_HAS_INFINITY__ 1
#define __INT_LEAST8_WIDTH__ 8
#define __cpp_variadic_using 201611L
#define __UINT_LEAST64_MAX__ 0xffffffffffffffffUL
#define __INT_LEAST8_MAX__ 0x7f
#define __cpp_attributes 200809L
#define __cpp_capture_star_this 201603L
#define __SHRT_MAX__ 0x7fff
#define __LDBL_MAX__ 1.18973149535723176502126385303097021e+4932L
#define __FLT64X_MAX_10_EXP__ 4932
#define __cpp_if_constexpr 201606L
#define __BFLT16_MAX_10_EXP__ 38
#define __BFLT16_MAX_EXP__ 128
#define __LDBL_IS_IEC_60559__ 1
#define QT_NO_DEBUG 1
#define __FLT64X_HAS_QUIET_NAN__ 1
#define __UINT_LEAST8_MAX__ 0xff
#define __GCC_ATOMIC_BOOL_LOCK_FREE 2
#define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128
#define __UINTMAX_TYPE__ long unsigned int
#define __cpp_nsdmi 200809L
#define __BFLT16_DECIMAL_DIG__ 4
#define __linux 1
#define __DEC32_EPSILON__ 1E-6DF
#define __FLT_EVAL_METHOD_TS_18661_3__ 0
#define __UINT32_MAX__ 0xffffffffU
#define __GXX_EXPERIMENTAL_CXX0X__ 1
#define __DBL_DENORM_MIN__ double(4.94065645841246544176568792868221372e-324L)
#define __FLT128_MIN_EXP__ (-16381)
#define __WINT_MIN__ 0U
#define __FLT128_MIN_10_EXP__ (-4931)
#define __FLT32X_IS_IEC_60559__ 1
#define __INT_LEAST16_WIDTH__ 16
#define __SCHAR_MAX__ 0x7f
#define __FLT128_MANT_DIG__ 113
#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)
#define __INT64_C(c) c ## L
#define __SSP_STRONG__ 3
#define __GCC_ATOMIC_POINTER_LOCK_FREE 2
#define __ATOMIC_SEQ_CST 5
#define __unix 1
#define __INT_LEAST64_MAX__ 0x7fffffffffffffffL
#define __FLT32X_MANT_DIG__ 53
#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2
#define __cpp_aligned_new 201606L
#define __FLT32_MAX_10_EXP__ 38
#define __FLT64X_EPSILON__ 1.08420217248550443400745280086994171e-19F64x
#define __STDC_HOSTED__ 1
#define __DEC64_MIN_EXP__ (-382)
#define __cpp_decltype_auto 201304L
#define __DBL_DIG__ 15
#define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F
#define __GXX_WEAK__ 1
#define __SHRT_WIDTH__ 16
#define __FLT32_IS_IEC_60559__ 1
#define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L
#define __DBL_IS_IEC_60559__ 1
#define __DEC32_MAX__ 9.999999E96DF
#define __cpp_threadsafe_static_init 200806L
#define __cpp_enumerator_attributes 201411L
#define __FLT64X_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951F64x
#define __FLT32X_HAS_INFINITY__ 1
#define __unix__ 1
#define __INT_WIDTH__ 32
#define __STDC_IEC_559__ 1
#define __STDC_ISO_10646__ 201706L
#define __DECIMAL_DIG__ 21
#define __STDC_IEC_559_COMPLEX__ 1
#define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64
#define __gnu_linux__ 1
#define __INT16_MAX__ 0x7fff
#define __FLT64_MIN_EXP__ (-1021)
#define __FLT64X_MIN_10_EXP__ (-4931)
#define __LDBL_HAS_QUIET_NAN__ 1
#define __cpp_return_type_deduction 201304L
#define __FLT16_MIN_EXP__ (-13)
#define __FLT64_MANT_DIG__ 53
#define __FLT64X_MANT_DIG__ 64
#define __BFLT16_DIG__ 2
#define __GNUC__ 13
#define __GXX_RTTI 1
#define __pie__ 2
#define __MMX__ 1
#define __FLT_HAS_DENORM__ 1
#define __SIZEOF_LONG_DOUBLE__ 16
#define __BIGGEST_ALIGNMENT__ 16
#define __STDC_UTF_16__ 1
#define __FLT64_MAX_10_EXP__ 308
#define __BFLT16_IS_IEC_60559__ 0
#define __FLT16_MAX_10_EXP__ 4
#define __cpp_delegating_constructors 200604L
#define __DBL_MAX__ double(1.79769313486231570814527423731704357e+308L)
#define __cpp_raw_strings 200710L
#define __INT_FAST32_MAX__ 0x7fffffffffffffffL
#define __DBL_HAS_INFINITY__ 1
#define __INT64_MAX__ 0x7fffffffffffffffL
#define __SIZEOF_FLOAT__ 4
#define __HAVE_SPECULATION_SAFE_VALUE 1
#define __cpp_fold_expressions 201603L
#define __DEC32_MIN_EXP__ (-94)
#define __INTPTR_WIDTH__ 64
#define __UINT_LEAST32_MAX__ 0xffffffffU
#define __FLT32X_HAS_DENORM__ 1
#define __INT_FAST16_TYPE__ long int
#define __MMX_WITH_SSE__ 1
#define __LDBL_HAS_DENORM__ 1
#define QT_WIDGETS_LIB 1
#define __SEG_GS 1
#define __BFLT16_EPSILON__ 7.81250000000000000000000000000000000e-3BF16
#define __cplusplus 201703L
#define __cpp_ref_qualifiers 200710L
#define __DEC32_MIN__ 1E-95DF
#define __DEPRECATED 1
#define __cpp_rvalue_references 200610L
#define __DBL_MAX_EXP__ 1024
#define __WCHAR_WIDTH__ 32
#define __FLT32_MAX__ 3.40282346638528859811704183484516925e+38F32
#define __DEC128_EPSILON__ 1E-33DL
#define __FLT16_DECIMAL_DIG__ 5
#define __SSE2_MATH__ 1
#define __ATOMIC_HLE_RELEASE 131072
#define __PTRDIFF_MAX__ 0x7fffffffffffffffL
#define __amd64 1
#define __ATOMIC_HLE_ACQUIRE 65536
#define __GNUG__ 13
#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL
#define __SIZEOF_SIZE_T__ 8
#define __BFLT16_HAS_INFINITY__ 1
#define __FLT64X_MIN_EXP__ (-16381)
#define __SIZEOF_WINT_T__ 4
#define __FLT32X_DIG__ 15
#define __LONG_LONG_WIDTH__ 64
#define __cpp_initializer_lists 200806L
#define __FLT32_MAX_EXP__ 128
#define ABI_ID "ELF"
#define __cpp_hex_float 201603L
#define __GXX_ABI_VERSION 1018
#define __FLT_MIN_EXP__ (-125)
#define __GCC_HAVE_DWARF2_CFI_ASM 1
#define __x86_64 1
#define __cpp_lambdas 200907L
#define __INT_FAST64_TYPE__ long int
#define __BFLT16_MAX__ 3.38953138925153547590470800371487867e+38BF16
#define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64
#define __cpp_template_auto 201606L
#define __FLT16_DENORM_MIN__ 5.96046447753906250000000000000000000e-8F16
#define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128
#define __FLT64X_NORM_MAX__ 1.18973149535723176502126385303097021e+4932F64x
#define __SIZEOF_POINTER__ 8
#define __SIZE_TYPE__ long unsigned int
#define __LP64__ 1
#define __DBL_HAS_QUIET_NAN__ 1
#define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x
#define __LDBL_MAX_EXP__ 16384
#define __DECIMAL_BID_FORMAT__ 1
#define __FLT64_MIN_10_EXP__ (-307)
#define __FLT16_MIN_10_EXP__ (-4)
#define __FLT64X_DECIMAL_DIG__ 21
#define __DEC128_MIN__ 1E-6143DL
#define __REGISTER_PREFIX__ 
#define __UINT16_MAX__ 0xffff
#define __FLT128_HAS_INFINITY__ 1
#define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32
#define __UINT8_TYPE__ unsigned char
#define __FLT_DIG__ 6
#define __NO_INLINE__ 1
#define __DEC_EVAL_METHOD__ 2
#define __FLT_MANT_DIG__ 24
#define __LDBL_DECIMAL_DIG__ 21
#define __VERSION__ "13.3.0"
#define __UINT64_C(c) c ## UL
#define __cpp_unicode_characters 201411L
#define _STDC_PREDEF_H 1
#define __INT_LEAST32_MAX__ 0x7fffffff
#define __GCC_ATOMIC_INT_LOCK_FREE 2
#define __FLT128_MAX_EXP__ 16384
#define __FLT32_MANT_DIG__ 24
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
#define SIZEOF_DPTR (sizeof(void*))
#define __FLT32X_MIN_EXP__ (-1021)
#define __STDC_IEC_60559_COMPLEX__ 201404L
#define __cpp_aggregate_bases 201603L
#define __BFLT16_MIN__ 1.17549435082228750796873653722224568e-38BF16
#define __FLT128_HAS_DENORM__ 1
#define __FLT32_DECIMAL_DIG__ 9
#define __FLT128_DIG__ 33
#define __INT32_C(c) c
#define __DEC64_EPSILON__ 1E-15DD
#define __ORDER_PDP_ENDIAN__ 3412
#define __DEC128_MIN_EXP__ (-6142)
#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
#define __INT_FAST32_TYPE__ long int
#define __UINT_LEAST16_TYPE__ short unsigned int
#define __DEC128_MAX_EXP__ 6145
#define unix 1
#define __DBL_HAS_DENORM__ 1
#define __cpp_rtti 199711L
#define __UINT64_MAX__ 0xffffffffffffffffUL
#define __FLT_IS_IEC_60559__ 1
#define __GNUC_WIDE_EXECUTION_CHARSET_NAME "UTF-32LE"
#define __FLT64X_DIG__ 18
#define __INT8_TYPE__ signed char
#define __cpp_digit_separators 201309L
#define __ELF__ 1
#define __GCC_ASM_FLAG_OUTPUTS__ 1
#define __UINT32_TYPE__ unsigned int
#define __BFLT16_HAS_QUIET_NAN__ 1
#define __FLT_RADIX__ 2
#define __INT_LEAST16_TYPE__ short int
#define __LDBL_EPSILON__ 1.08420217248550443400745280086994171e-19L
#define __UINTMAX_C(c) c ## UL
#define __FLT16_DIG__ 3
#define __k8 1
#define QT_MULTIMEDIA_LIB 1
#define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x
#define __SIG_ATOMIC_MAX__ 0x7fffffff
#define __cpp_constexpr 201603L
#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2
#define __USER_LABEL_PREFIX__ 
#define __STDC_IEC_60559_BFP__ 201404L
#define __SIZEOF_PTRDIFF_T__ 8
#define __FLT64X_HAS_INFINITY__ 1
#define __SIZEOF_LONG__ 8
#define __LDBL_DIG__ 18
#define __FLT64_IS_IEC_60559__ 1
#define __x86_64__ 1
#define __FLT16_IS_IEC_60559__ 1
#define __FLT16_MAX_EXP__ 16
#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF
#define __INT_FAST16_MAX__ 0x7fffffffffffffffL
#define __GCC_CONSTRUCTIVE_SIZE 64
#define __FLT64_DIG__ 15
#define __UINT_FAST32_MAX__ 0xffffffffffffffffUL
#define __UINT_LEAST64_TYPE__ long unsigned int
#define __FLT16_EPSILON__ 9.76562500000000000000000000000000000e-4F16
#define __FLT_HAS_QUIET_NAN__ 1
#define __FLT_MAX_10_EXP__ 38
#define __LONG_MAX__ 0x7fffffffffffffffL
#define __FLT64X_HAS_DENORM__ 1
#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL
#define __FLT_HAS_INFINITY__ 1
#define __GNUC_EXECUTION_CHARSET_NAME "UTF-8"
#define __cpp_unicode_literals 200710L
#define __UINT_FAST16_TYPE__ long unsigned int
#define __DEC64_MAX__ 9.999999999999999E384DD
#define __INT_FAST32_WIDTH__ 64
#define __CHAR16_TYPE__ short unsigned int
#define __PRAGMA_REDEFINE_EXTNAME 1
#define __SIZE_WIDTH__ 64
#define __SEG_FS 1
#define __INT_LEAST16_MAX__ 0x7fff
#define __FLT16_NORM_MAX__ 6.55040000000000000000000000000000000e+4F16
#define __DEC64_MANT_DIG__ 16
#define QT_NETWORK_LIB 1
#define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32
#define __SIG_ATOMIC_WIDTH__ 32
#define __INT_LEAST64_TYPE__ long int
#define __INT16_TYPE__ short int
#define __INT_LEAST8_TYPE__ signed char
#define __FLT16_MAX__ 6.55040000000000000000000000000000000e+4F16
#define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128
#define __cpp_structured_bindings 201606L
#define __SIZEOF_INT__ 4
#define __DEC32_MAX_EXP__ 97
#define __INT_FAST8_MAX__ 0x7f
#define __FLT128_MAX__ 1.18973149535723176508575932662800702e+4932F128
#define __INTPTR_MAX__ 0x7fffffffffffffffL
#define __cpp_sized_deallocation 201309L
#define __cpp_guaranteed_copy_elision 201606L
#define linux 1
#define __FLT64_HAS_QUIET_NAN__ 1
#define __FLT32_MIN_10_EXP__ (-37)
#define __EXCEPTIONS 1
#define __UINT16_C(c) c
#define __PTRDIFF_WIDTH__ 64
#define __LDBL_MANT_DIG__ 64
#define __cpp_range_based_for 201603L
#define __INT_FAST16_WIDTH__ 64
#define __FLT64_HAS_INFINITY__ 1
#define __FLT64X_MAX__ 1.18973149535723176502126385303097021e+4932F64x
#define __FLT16_HAS_INFINITY__ 1
#define __STDCPP_DEFAULT_NEW_ALIGNMENT__ 16
#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
#define __code_model_small__ 1
#define __GCC_ATOMIC_LONG_LOCK_FREE 2
#define __cpp_nontype_template_args 201411L
#define __DEC32_MANT_DIG__ 7
#define __k8__ 1
#define __INTPTR_TYPE__ long int
#define __UINT16_TYPE__ short unsigned int
#define __WCHAR_TYPE__ int
#define __pic__ 2
#define __UINTPTR_MAX__ 0xffffffffffffffffUL
#define __INT_FAST64_WIDTH__ 64
#define __cpp_decltype 200707L
#define __INT_FAST64_MAX__ 0x7fffffffffffffffL
#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1
#define __FLT_NORM_MAX__ 3.40282346638528859811704183484516925e+38F
#define __FLT32_HAS_INFINITY__ 1
#define __FLT64X_MAX_EXP__ 16384
#define __UINT_FAST64_TYPE__ long unsigned int
#define __cpp_inline_variables 201606L
#define QT_WEBSOCKETS_LIB 1
#define __BFLT16_MIN_EXP__ (-125)
#define __INT_MAX__ 0x7fffffff
#define __linux__ 1
#define __INT64_TYPE__ long int
#define __FLT_MAX_EXP__ 128
#define __ORDER_BIG_ENDIAN__ 4321
#define __DBL_MANT_DIG__ 53
#define __cpp_inheriting_constructors 201511L
#define QT_CORE_LIB 1
#define __SIZEOF_FLOAT128__ 16
#define __BFLT16_MANT_DIG__ 8
#define __DEC64_MIN__ 1E-383DD
#define __WINT_TYPE__ unsigned int
#define __UINT_LEAST32_TYPE__ unsigned int
#define __SIZEOF_SHORT__ 2
#define __FLT32_NORM_MAX__ 3.40282346638528859811704183484516925e+38F32
#define __SSE__ 1
#define __LDBL_MIN_EXP__ (-16381)
#define __FLT64_MAX__ 1.79769313486231570814527423731704357e+308F64
#define __amd64__ 1
#define __WINT_WIDTH__ 32
#define __INT_LEAST64_WIDTH__ 64
#define __FLT32X_MAX_10_EXP__ 308
#define __cpp_namespace_attributes 201411L
#define __SIZEOF_INT128__ 16
#define __FLT16_MIN__ 6.10351562500000000000000000000000000e-5F16
#define __FLT64X_IS_IEC_60559__ 1
#define __LDBL_MAX_10_EXP__ 4932
#define __ATOMIC_RELAXED 0
#define __DBL_EPSILON__ double(2.22044604925031308084726333618164062e-16L)
#define __INT_LEAST32_TYPE__ int
#define _LP64 1
#define __UINT8_C(c) c
#define __FLT64_MAX_EXP__ 1024
#define __SIZEOF_WCHAR_T__ 4
#define __GNUC_PATCHLEVEL__ 0
#define __FLT128_NORM_MAX__ 1.18973149535723176508575932662800702e+4932F128
#define __FLT64_NORM_MAX__ 1.79769313486231570814527423731704357e+308F64
#define __FLT128_HAS_QUIET_NAN__ 1
#define __INTMAX_MAX__ 0x7fffffffffffffffL
#define __INT_FAST8_TYPE__ signed char
#define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x
#define QT_SQL_LIB 1
#define __STDCPP_THREADS__ 1
#define __BFLT16_HAS_DENORM__ 1
#define __GNUC_STDC_INLINE__ 1
#define __FLT64_HAS_DENORM__ 1
#define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32
#define __FLT16_HAS_DENORM__ 1
#define __DBL_DECIMAL_DIG__ 17
#define __STDC_UTF_32__ 1
#define __INT_FAST8_WIDTH__ 8
#define __FXSR__ 1
#define __FLT32X_MAX__ 1.79769313486231570814527423731704357e+308F32x
#define __DBL_NORM_MAX__ double(1.79769313486231570814527423731704357e+308L)
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __GCC_DESTRUCTIVE_SIZE 64
#define __INTMAX_WIDTH__ 64
#define __cpp_runtime_arrays 198712L
#define __FLT32_DIG__ 6
#define __UINT64_TYPE__ long unsigned int
#define __UINT32_C(c) c ## U
#define __cpp_alias_templates 200704L
#define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F
#define __FLT128_IS_IEC_60559__ 1
#define __INT8_MAX__ 0x7f
#define __LONG_WIDTH__ 64
#define __DBL_MIN__ double(2.22507385850720138309023271733240406e-308L)
#define __PIC__ 2
#define __INT32_MAX__ 0x7fffffff
#define __UINT_FAST32_TYPE__ long unsigned int
#define __FLT16_MANT_DIG__ 11
#define __FLT32X_NORM_MAX__ 1.79769313486231570814527423731704357e+308F32x
#define __CHAR32_TYPE__ unsigned int
#define __FLT_MAX__ 3.40282346638528859811704183484516925e+38F
#define __SSE2__ 1
#define __cpp_deduction_guides 201703L
#define __BFLT16_NORM_MAX__ 3.38953138925153547590470800371487867e+38BF16
#define __INT32_TYPE__ int
#define __SIZEOF_DOUBLE__ 8
#define __cpp_exceptions 199711L
#define __FLT_MIN_10_EXP__ (-37)
#define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64
#define __INT_LEAST32_WIDTH__ 32
#define __INTMAX_TYPE__ long int
#define __GLIBCXX_BITSIZE_INT_N_0 128
#define __FLT32X_HAS_QUIET_NAN__ 1
#define __ATOMIC_CONSUME 1
#define __GNUC_MINOR__ 3
#define __GLIBCXX_TYPE_INT_N_0 __int128
#define __UINTMAX_MAX__ 0xffffffffffffffffUL
#define __PIE__ 2
#define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x
#define __cpp_template_template_args 201611L
#define __DBL_MAX_10_EXP__ 308
#define __LDBL_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951L
#define __INT16_C(c) c
#define __STDC__ 1
#define __PTRDIFF_TYPE__ long int
#define __FLT32X_MIN_10_EXP__ (-307)
#define __UINTPTR_TYPE__ long unsigned int
#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD
#define __DEC128_MANT_DIG__ 34
#define __LDBL_MIN_10_EXP__ (-4931)
#define __cpp_generic_lambdas 201304L
#define __SSE_MATH__ 1
#define __SIZEOF_LONG_LONG__ 8
#define __cpp_user_defined_literals 200809L
#define __FLT128_DECIMAL_DIG__ 36
#define __GCC_ATOMIC_LLONG_LOCK_FREE 2
#define __FLT32_HAS_QUIET_NAN__ 1
#define __FLT_DECIMAL_DIG__ 9
#define __UINT_FAST16_MAX__ 0xffffffffffffffffUL
#define __LDBL_NORM_MAX__ 1.18973149535723176502126385303097021e+4932L
#define __GCC_ATOMIC_SHORT_LOCK_FREE 2
#define __SIZE_MAX__ 0xffffffffffffffffUL
#define __UINT_FAST8_TYPE__ unsigned char
#define _GNU_SOURCE 1
#define __cpp_init_captures 201304L
#define __ATOMIC_ACQ_REL 4
#define __ATOMIC_RELEASE 3


=== kursach/src/Chorus_autogen/UFQQIFJZKK/moc_ChatManager.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'ChatManager.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../network/ChatManager.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'ChatManager.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_ChatManager_t {
    QByteArrayData data[7];
    char stringdata0[67];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_ChatManager_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_ChatManager_t qt_meta_stringdata_ChatManager = {
    {
QT_MOC_LITERAL(0, 0, 11), // "ChatManager"
QT_MOC_LITERAL(1, 12, 15), // "messageReceived"
QT_MOC_LITERAL(2, 28, 0), // ""
QT_MOC_LITERAL(3, 29, 7), // "Message"
QT_MOC_LITERAL(4, 37, 7), // "message"
QT_MOC_LITERAL(5, 45, 11), // "messageSent"
QT_MOC_LITERAL(6, 57, 9) // "messageId"

    },
    "ChatManager\0messageReceived\0\0Message\0"
    "message\0messageSent\0messageId"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_ChatManager[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       2,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       2,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    1,   24,    2, 0x06 /* Public */,
       5,    1,   27,    2, 0x06 /* Public */,

 // signals: parameters
    QMetaType::Void, 0x80000000 | 3,    4,
    QMetaType::Void, QMetaType::Int,    6,

       0        // eod
};

void ChatManager::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<ChatManager *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->messageReceived((*reinterpret_cast< const Message(*)>(_a[1]))); break;
        case 1: _t->messageSent((*reinterpret_cast< int(*)>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (ChatManager::*)(const Message & );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&ChatManager::messageReceived)) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (ChatManager::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&ChatManager::messageSent)) {
                *result = 1;
                return;
            }
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject ChatManager::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_ChatManager.data,
    qt_meta_data_ChatManager,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *ChatManager::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *ChatManager::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_ChatManager.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int ChatManager::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 2)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 2;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 2)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 2;
    }
    return _id;
}

// SIGNAL 0
void ChatManager::messageReceived(const Message & _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}

// SIGNAL 1
void ChatManager::messageSent(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 1, _a);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/UFQQIFJZKK/moc_RoomManager.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'RoomManager.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../network/RoomManager.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'RoomManager.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_RoomManager_t {
    QByteArrayData data[13];
    char stringdata0[125];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_RoomManager_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_RoomManager_t qt_meta_stringdata_RoomManager = {
    {
QT_MOC_LITERAL(0, 0, 11), // "RoomManager"
QT_MOC_LITERAL(1, 12, 11), // "roomCreated"
QT_MOC_LITERAL(2, 24, 0), // ""
QT_MOC_LITERAL(3, 25, 6), // "roomId"
QT_MOC_LITERAL(4, 32, 11), // "roomDeleted"
QT_MOC_LITERAL(5, 44, 10), // "roomJoined"
QT_MOC_LITERAL(6, 55, 8), // "roomLeft"
QT_MOC_LITERAL(7, 64, 11), // "roomUpdated"
QT_MOC_LITERAL(8, 76, 12), // "memberJoined"
QT_MOC_LITERAL(9, 89, 10), // "RoomMember"
QT_MOC_LITERAL(10, 100, 6), // "member"
QT_MOC_LITERAL(11, 107, 10), // "memberLeft"
QT_MOC_LITERAL(12, 118, 6) // "userId"

    },
    "RoomManager\0roomCreated\0\0roomId\0"
    "roomDeleted\0roomJoined\0roomLeft\0"
    "roomUpdated\0memberJoined\0RoomMember\0"
    "member\0memberLeft\0userId"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_RoomManager[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       7,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       7,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    1,   49,    2, 0x06 /* Public */,
       4,    1,   52,    2, 0x06 /* Public */,
       5,    1,   55,    2, 0x06 /* Public */,
       6,    1,   58,    2, 0x06 /* Public */,
       7,    1,   61,    2, 0x06 /* Public */,
       8,    2,   64,    2, 0x06 /* Public */,
      11,    2,   69,    2, 0x06 /* Public */,

 // signals: parameters
    QMetaType::Void, QMetaType::Int,    3,
    QMetaType::Void, QMetaType::Int,    3,
    QMetaType::Void, QMetaType::Int,    3,
    QMetaType::Void, QMetaType::Int,    3,
    QMetaType::Void, QMetaType::Int,    3,
    QMetaType::Void, QMetaType::Int, 0x80000000 | 9,    3,   10,
    QMetaType::Void, QMetaType::Int, QMetaType::Int,    3,   12,

       0        // eod
};

void RoomManager::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<RoomManager *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->roomCreated((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 1: _t->roomDeleted((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 2: _t->roomJoined((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 3: _t->roomLeft((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 4: _t->roomUpdated((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 5: _t->memberJoined((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< const RoomMember(*)>(_a[2]))); break;
        case 6: _t->memberLeft((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (RoomManager::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&RoomManager::roomCreated)) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (RoomManager::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&RoomManager::roomDeleted)) {
                *result = 1;
                return;
            }
        }
        {
            using _t = void (RoomManager::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&RoomManager::roomJoined)) {
                *result = 2;
                return;
            }
        }
        {
            using _t = void (RoomManager::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&RoomManager::roomLeft)) {
                *result = 3;
                return;
            }
        }
        {
            using _t = void (RoomManager::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&RoomManager::roomUpdated)) {
                *result = 4;
                return;
            }
        }
        {
            using _t = void (RoomManager::*)(int , const RoomMember & );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&RoomManager::memberJoined)) {
                *result = 5;
                return;
            }
        }
        {
            using _t = void (RoomManager::*)(int , int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&RoomManager::memberLeft)) {
                *result = 6;
                return;
            }
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject RoomManager::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_RoomManager.data,
    qt_meta_data_RoomManager,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *RoomManager::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *RoomManager::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_RoomManager.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int RoomManager::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 7)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 7;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 7)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 7;
    }
    return _id;
}

// SIGNAL 0
void RoomManager::roomCreated(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}

// SIGNAL 1
void RoomManager::roomDeleted(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 1, _a);
}

// SIGNAL 2
void RoomManager::roomJoined(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 2, _a);
}

// SIGNAL 3
void RoomManager::roomLeft(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 3, _a);
}

// SIGNAL 4
void RoomManager::roomUpdated(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 4, _a);
}

// SIGNAL 5
void RoomManager::memberJoined(int _t1, const RoomMember & _t2)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))) };
    QMetaObject::activate(this, &staticMetaObject, 5, _a);
}

// SIGNAL 6
void RoomManager::memberLeft(int _t1, int _t2)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))) };
    QMetaObject::activate(this, &staticMetaObject, 6, _a);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/UFQQIFJZKK/moc_RadioBrowserAPI.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'RadioBrowserAPI.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../network/RadioBrowserAPI.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'RadioBrowserAPI.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_RadioBrowserAPI_t {
    QByteArrayData data[7];
    char stringdata0[77];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_RadioBrowserAPI_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_RadioBrowserAPI_t qt_meta_stringdata_RadioBrowserAPI = {
    {
QT_MOC_LITERAL(0, 0, 15), // "RadioBrowserAPI"
QT_MOC_LITERAL(1, 16, 13), // "stationsReady"
QT_MOC_LITERAL(2, 30, 0), // ""
QT_MOC_LITERAL(3, 31, 8), // "stations"
QT_MOC_LITERAL(4, 40, 13), // "errorOccurred"
QT_MOC_LITERAL(5, 54, 5), // "error"
QT_MOC_LITERAL(6, 60, 16) // "onSearchFinished"

    },
    "RadioBrowserAPI\0stationsReady\0\0stations\0"
    "errorOccurred\0error\0onSearchFinished"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_RadioBrowserAPI[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       3,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       2,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    1,   29,    2, 0x06 /* Public */,
       4,    1,   32,    2, 0x06 /* Public */,

 // slots: name, argc, parameters, tag, flags
       6,    0,   35,    2, 0x08 /* Private */,

 // signals: parameters
    QMetaType::Void, QMetaType::QVariantList,    3,
    QMetaType::Void, QMetaType::QString,    5,

 // slots: parameters
    QMetaType::Void,

       0        // eod
};

void RadioBrowserAPI::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<RadioBrowserAPI *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->stationsReady((*reinterpret_cast< const QVariantList(*)>(_a[1]))); break;
        case 1: _t->errorOccurred((*reinterpret_cast< const QString(*)>(_a[1]))); break;
        case 2: _t->onSearchFinished(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (RadioBrowserAPI::*)(const QVariantList & );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&RadioBrowserAPI::stationsReady)) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (RadioBrowserAPI::*)(const QString & );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&RadioBrowserAPI::errorOccurred)) {
                *result = 1;
                return;
            }
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject RadioBrowserAPI::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_RadioBrowserAPI.data,
    qt_meta_data_RadioBrowserAPI,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *RadioBrowserAPI::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *RadioBrowserAPI::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_RadioBrowserAPI.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int RadioBrowserAPI::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 3)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 3;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 3)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 3;
    }
    return _id;
}

// SIGNAL 0
void RadioBrowserAPI::stationsReady(const QVariantList & _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}

// SIGNAL 1
void RadioBrowserAPI::errorOccurred(const QString & _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 1, _a);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/UFQQIFJZKK/moc_FriendManager.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'FriendManager.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../network/FriendManager.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'FriendManager.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_FriendManager_t {
    QByteArrayData data[11];
    char stringdata0[118];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_FriendManager_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_FriendManager_t qt_meta_stringdata_FriendManager = {
    {
QT_MOC_LITERAL(0, 0, 13), // "FriendManager"
QT_MOC_LITERAL(1, 14, 21), // "friendRequestReceived"
QT_MOC_LITERAL(2, 36, 0), // ""
QT_MOC_LITERAL(3, 37, 4), // "User"
QT_MOC_LITERAL(4, 42, 4), // "user"
QT_MOC_LITERAL(5, 47, 11), // "friendAdded"
QT_MOC_LITERAL(6, 59, 13), // "friendRemoved"
QT_MOC_LITERAL(7, 73, 6), // "userId"
QT_MOC_LITERAL(8, 80, 19), // "friendStatusChanged"
QT_MOC_LITERAL(9, 100, 10), // "UserStatus"
QT_MOC_LITERAL(10, 111, 6) // "status"

    },
    "FriendManager\0friendRequestReceived\0"
    "\0User\0user\0friendAdded\0friendRemoved\0"
    "userId\0friendStatusChanged\0UserStatus\0"
    "status"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_FriendManager[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       4,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       4,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    1,   34,    2, 0x06 /* Public */,
       5,    1,   37,    2, 0x06 /* Public */,
       6,    1,   40,    2, 0x06 /* Public */,
       8,    2,   43,    2, 0x06 /* Public */,

 // signals: parameters
    QMetaType::Void, 0x80000000 | 3,    4,
    QMetaType::Void, 0x80000000 | 3,    4,
    QMetaType::Void, QMetaType::Int,    7,
    QMetaType::Void, QMetaType::Int, 0x80000000 | 9,    7,   10,

       0        // eod
};

void FriendManager::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<FriendManager *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->friendRequestReceived((*reinterpret_cast< const User(*)>(_a[1]))); break;
        case 1: _t->friendAdded((*reinterpret_cast< const User(*)>(_a[1]))); break;
        case 2: _t->friendRemoved((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 3: _t->friendStatusChanged((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< UserStatus(*)>(_a[2]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (FriendManager::*)(const User & );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&FriendManager::friendRequestReceived)) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (FriendManager::*)(const User & );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&FriendManager::friendAdded)) {
                *result = 1;
                return;
            }
        }
        {
            using _t = void (FriendManager::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&FriendManager::friendRemoved)) {
                *result = 2;
                return;
            }
        }
        {
            using _t = void (FriendManager::*)(int , UserStatus );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&FriendManager::friendStatusChanged)) {
                *result = 3;
                return;
            }
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject FriendManager::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_FriendManager.data,
    qt_meta_data_FriendManager,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *FriendManager::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *FriendManager::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_FriendManager.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int FriendManager::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 4)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 4;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 4)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 4;
    }
    return _id;
}

// SIGNAL 0
void FriendManager::friendRequestReceived(const User & _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}

// SIGNAL 1
void FriendManager::friendAdded(const User & _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 1, _a);
}

// SIGNAL 2
void FriendManager::friendRemoved(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 2, _a);
}

// SIGNAL 3
void FriendManager::friendStatusChanged(int _t1, UserStatus _t2)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))) };
    QMetaObject::activate(this, &staticMetaObject, 3, _a);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/UFQQIFJZKK/moc_WebSocketClient.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'WebSocketClient.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../network/WebSocketClient.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'WebSocketClient.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_WebSocketClient_t {
    QByteArrayData data[20];
    char stringdata0[235];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_WebSocketClient_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_WebSocketClient_t qt_meta_stringdata_WebSocketClient = {
    {
QT_MOC_LITERAL(0, 0, 15), // "WebSocketClient"
QT_MOC_LITERAL(1, 16, 9), // "connected"
QT_MOC_LITERAL(2, 26, 0), // ""
QT_MOC_LITERAL(3, 27, 12), // "disconnected"
QT_MOC_LITERAL(4, 40, 15), // "messageReceived"
QT_MOC_LITERAL(5, 56, 7), // "message"
QT_MOC_LITERAL(6, 64, 16), // "roomStateUpdated"
QT_MOC_LITERAL(7, 81, 6), // "roomId"
QT_MOC_LITERAL(8, 88, 9), // "isPlaying"
QT_MOC_LITERAL(9, 98, 8), // "position"
QT_MOC_LITERAL(10, 107, 10), // "userJoined"
QT_MOC_LITERAL(11, 118, 6), // "userId"
QT_MOC_LITERAL(12, 125, 8), // "username"
QT_MOC_LITERAL(13, 134, 8), // "userLeft"
QT_MOC_LITERAL(14, 143, 11), // "onConnected"
QT_MOC_LITERAL(15, 155, 14), // "onDisconnected"
QT_MOC_LITERAL(16, 170, 21), // "onTextMessageReceived"
QT_MOC_LITERAL(17, 192, 7), // "onError"
QT_MOC_LITERAL(18, 200, 28), // "QAbstractSocket::SocketError"
QT_MOC_LITERAL(19, 229, 5) // "error"

    },
    "WebSocketClient\0connected\0\0disconnected\0"
    "messageReceived\0message\0roomStateUpdated\0"
    "roomId\0isPlaying\0position\0userJoined\0"
    "userId\0username\0userLeft\0onConnected\0"
    "onDisconnected\0onTextMessageReceived\0"
    "onError\0QAbstractSocket::SocketError\0"
    "error"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_WebSocketClient[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
      10,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       6,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    0,   64,    2, 0x06 /* Public */,
       3,    0,   65,    2, 0x06 /* Public */,
       4,    1,   66,    2, 0x06 /* Public */,
       6,    3,   69,    2, 0x06 /* Public */,
      10,    3,   76,    2, 0x06 /* Public */,
      13,    2,   83,    2, 0x06 /* Public */,

 // slots: name, argc, parameters, tag, flags
      14,    0,   88,    2, 0x08 /* Private */,
      15,    0,   89,    2, 0x08 /* Private */,
      16,    1,   90,    2, 0x08 /* Private */,
      17,    1,   93,    2, 0x08 /* Private */,

 // signals: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::QJsonObject,    5,
    QMetaType::Void, QMetaType::Int, QMetaType::Bool, QMetaType::LongLong,    7,    8,    9,
    QMetaType::Void, QMetaType::Int, QMetaType::Int, QMetaType::QString,    7,   11,   12,
    QMetaType::Void, QMetaType::Int, QMetaType::Int,    7,   11,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::QString,    5,
    QMetaType::Void, 0x80000000 | 18,   19,

       0        // eod
};

void WebSocketClient::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<WebSocketClient *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->connected(); break;
        case 1: _t->disconnected(); break;
        case 2: _t->messageReceived((*reinterpret_cast< const QJsonObject(*)>(_a[1]))); break;
        case 3: _t->roomStateUpdated((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2])),(*reinterpret_cast< qint64(*)>(_a[3]))); break;
        case 4: _t->userJoined((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2])),(*reinterpret_cast< const QString(*)>(_a[3]))); break;
        case 5: _t->userLeft((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
        case 6: _t->onConnected(); break;
        case 7: _t->onDisconnected(); break;
        case 8: _t->onTextMessageReceived((*reinterpret_cast< const QString(*)>(_a[1]))); break;
        case 9: _t->onError((*reinterpret_cast< QAbstractSocket::SocketError(*)>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        switch (_id) {
        default: *reinterpret_cast<int*>(_a[0]) = -1; break;
        case 9:
            switch (*reinterpret_cast<int*>(_a[1])) {
            default: *reinterpret_cast<int*>(_a[0]) = -1; break;
            case 0:
                *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QAbstractSocket::SocketError >(); break;
            }
            break;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (WebSocketClient::*)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&WebSocketClient::connected)) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (WebSocketClient::*)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&WebSocketClient::disconnected)) {
                *result = 1;
                return;
            }
        }
        {
            using _t = void (WebSocketClient::*)(const QJsonObject & );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&WebSocketClient::messageReceived)) {
                *result = 2;
                return;
            }
        }
        {
            using _t = void (WebSocketClient::*)(int , bool , qint64 );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&WebSocketClient::roomStateUpdated)) {
                *result = 3;
                return;
            }
        }
        {
            using _t = void (WebSocketClient::*)(int , int , const QString & );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&WebSocketClient::userJoined)) {
                *result = 4;
                return;
            }
        }
        {
            using _t = void (WebSocketClient::*)(int , int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&WebSocketClient::userLeft)) {
                *result = 5;
                return;
            }
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject WebSocketClient::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_WebSocketClient.data,
    qt_meta_data_WebSocketClient,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *WebSocketClient::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *WebSocketClient::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_WebSocketClient.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int WebSocketClient::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 10)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 10;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 10)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 10;
    }
    return _id;
}

// SIGNAL 0
void WebSocketClient::connected()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}

// SIGNAL 1
void WebSocketClient::disconnected()
{
    QMetaObject::activate(this, &staticMetaObject, 1, nullptr);
}

// SIGNAL 2
void WebSocketClient::messageReceived(const QJsonObject & _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 2, _a);
}

// SIGNAL 3
void WebSocketClient::roomStateUpdated(int _t1, bool _t2, qint64 _t3)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t3))) };
    QMetaObject::activate(this, &staticMetaObject, 3, _a);
}

// SIGNAL 4
void WebSocketClient::userJoined(int _t1, int _t2, const QString & _t3)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t3))) };
    QMetaObject::activate(this, &staticMetaObject, 4, _a);
}

// SIGNAL 5
void WebSocketClient::userLeft(int _t1, int _t2)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))) };
    QMetaObject::activate(this, &staticMetaObject, 5, _a);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/OMUT2NUK4C/moc_MusicAPIManager.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'MusicAPIManager.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../database/api/MusicAPIManager.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'MusicAPIManager.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_MusicAPIManager_t {
    QByteArrayData data[7];
    char stringdata0[83];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_MusicAPIManager_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_MusicAPIManager_t qt_meta_stringdata_MusicAPIManager = {
    {
QT_MOC_LITERAL(0, 0, 15), // "MusicAPIManager"
QT_MOC_LITERAL(1, 16, 13), // "stationsFound"
QT_MOC_LITERAL(2, 30, 0), // ""
QT_MOC_LITERAL(3, 31, 8), // "stations"
QT_MOC_LITERAL(4, 40, 13), // "errorOccurred"
QT_MOC_LITERAL(5, 54, 5), // "error"
QT_MOC_LITERAL(6, 60, 22) // "onRadioBrowserStations"

    },
    "MusicAPIManager\0stationsFound\0\0stations\0"
    "errorOccurred\0error\0onRadioBrowserStations"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_MusicAPIManager[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       3,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       2,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    1,   29,    2, 0x06 /* Public */,
       4,    1,   32,    2, 0x06 /* Public */,

 // slots: name, argc, parameters, tag, flags
       6,    1,   35,    2, 0x08 /* Private */,

 // signals: parameters
    QMetaType::Void, QMetaType::QVariantList,    3,
    QMetaType::Void, QMetaType::QString,    5,

 // slots: parameters
    QMetaType::Void, QMetaType::QVariantList,    3,

       0        // eod
};

void MusicAPIManager::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<MusicAPIManager *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->stationsFound((*reinterpret_cast< const QVariantList(*)>(_a[1]))); break;
        case 1: _t->errorOccurred((*reinterpret_cast< const QString(*)>(_a[1]))); break;
        case 2: _t->onRadioBrowserStations((*reinterpret_cast< const QVariantList(*)>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (MusicAPIManager::*)(const QVariantList & );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&MusicAPIManager::stationsFound)) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (MusicAPIManager::*)(const QString & );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&MusicAPIManager::errorOccurred)) {
                *result = 1;
                return;
            }
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject MusicAPIManager::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_MusicAPIManager.data,
    qt_meta_data_MusicAPIManager,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *MusicAPIManager::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *MusicAPIManager::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_MusicAPIManager.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int MusicAPIManager::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 3)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 3;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 3)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 3;
    }
    return _id;
}

// SIGNAL 0
void MusicAPIManager::stationsFound(const QVariantList & _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}

// SIGNAL 1
void MusicAPIManager::errorOccurred(const QString & _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 1, _a);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/RG5RW67LIN/moc_LoginForm.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'LoginForm.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../gui/AuthWindow/widgets/LoginForm.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'LoginForm.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_LoginForm_t {
    QByteArrayData data[7];
    char stringdata0[72];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_LoginForm_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_LoginForm_t qt_meta_stringdata_LoginForm = {
    {
QT_MOC_LITERAL(0, 0, 9), // "LoginForm"
QT_MOC_LITERAL(1, 10, 12), // "loginSuccess"
QT_MOC_LITERAL(2, 23, 0), // ""
QT_MOC_LITERAL(3, 24, 8), // "username"
QT_MOC_LITERAL(4, 33, 6), // "userId"
QT_MOC_LITERAL(5, 40, 16), // "switchToRegister"
QT_MOC_LITERAL(6, 57, 14) // "onLoginClicked"

    },
    "LoginForm\0loginSuccess\0\0username\0"
    "userId\0switchToRegister\0onLoginClicked"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_LoginForm[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       3,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       2,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    2,   29,    2, 0x06 /* Public */,
       5,    0,   34,    2, 0x06 /* Public */,

 // slots: name, argc, parameters, tag, flags
       6,    0,   35,    2, 0x08 /* Private */,

 // signals: parameters
    QMetaType::Void, QMetaType::QString, QMetaType::Int,    3,    4,
    QMetaType::Void,

 // slots: parameters
    QMetaType::Void,

       0        // eod
};

void LoginForm::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<LoginForm *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->loginSuccess((*reinterpret_cast< const QString(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
        case 1: _t->switchToRegister(); break;
        case 2: _t->onLoginClicked(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (LoginForm::*)(const QString & , int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&LoginForm::loginSuccess)) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (LoginForm::*)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&LoginForm::switchToRegister)) {
                *result = 1;
                return;
            }
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject LoginForm::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_LoginForm.data,
    qt_meta_data_LoginForm,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *LoginForm::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *LoginForm::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_LoginForm.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int LoginForm::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 3)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 3;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 3)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 3;
    }
    return _id;
}

// SIGNAL 0
void LoginForm::loginSuccess(const QString & _t1, int _t2)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}

// SIGNAL 1
void LoginForm::switchToRegister()
{
    QMetaObject::activate(this, &staticMetaObject, 1, nullptr);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/RG5RW67LIN/moc_RegisterForm.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'RegisterForm.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../gui/AuthWindow/widgets/RegisterForm.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'RegisterForm.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_RegisterForm_t {
    QByteArrayData data[5];
    char stringdata0[62];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_RegisterForm_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_RegisterForm_t qt_meta_stringdata_RegisterForm = {
    {
QT_MOC_LITERAL(0, 0, 12), // "RegisterForm"
QT_MOC_LITERAL(1, 13, 15), // "registerSuccess"
QT_MOC_LITERAL(2, 29, 0), // ""
QT_MOC_LITERAL(3, 30, 13), // "switchToLogin"
QT_MOC_LITERAL(4, 44, 17) // "onRegisterClicked"

    },
    "RegisterForm\0registerSuccess\0\0"
    "switchToLogin\0onRegisterClicked"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_RegisterForm[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       3,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       2,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    0,   29,    2, 0x06 /* Public */,
       3,    0,   30,    2, 0x06 /* Public */,

 // slots: name, argc, parameters, tag, flags
       4,    0,   31,    2, 0x08 /* Private */,

 // signals: parameters
    QMetaType::Void,
    QMetaType::Void,

 // slots: parameters
    QMetaType::Void,

       0        // eod
};

void RegisterForm::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<RegisterForm *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->registerSuccess(); break;
        case 1: _t->switchToLogin(); break;
        case 2: _t->onRegisterClicked(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (RegisterForm::*)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&RegisterForm::registerSuccess)) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (RegisterForm::*)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&RegisterForm::switchToLogin)) {
                *result = 1;
                return;
            }
        }
    }
    (void)_a;
}

QT_INIT_METAOBJECT const QMetaObject RegisterForm::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_RegisterForm.data,
    qt_meta_data_RegisterForm,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *RegisterForm::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *RegisterForm::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_RegisterForm.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int RegisterForm::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 3)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 3;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 3)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 3;
    }
    return _id;
}

// SIGNAL 0
void RegisterForm::registerSuccess()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}

// SIGNAL 1
void RegisterForm::switchToLogin()
{
    QMetaObject::activate(this, &staticMetaObject, 1, nullptr);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/MYYQ2Y7GGF/moc_TrackWidget.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'TrackWidget.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../audio/TrackWidget.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'TrackWidget.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_TrackWidget_t {
    QByteArrayData data[6];
    char stringdata0[74];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_TrackWidget_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_TrackWidget_t qt_meta_stringdata_TrackWidget = {
    {
QT_MOC_LITERAL(0, 0, 11), // "TrackWidget"
QT_MOC_LITERAL(1, 12, 13), // "playRequested"
QT_MOC_LITERAL(2, 26, 0), // ""
QT_MOC_LITERAL(3, 27, 7), // "trackId"
QT_MOC_LITERAL(4, 35, 22), // "addToPlaylistRequested"
QT_MOC_LITERAL(5, 58, 15) // "deleteRequested"

    },
    "TrackWidget\0playRequested\0\0trackId\0"
    "addToPlaylistRequested\0deleteRequested"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_TrackWidget[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       3,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       3,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    1,   29,    2, 0x06 /* Public */,
       4,    1,   32,    2, 0x06 /* Public */,
       5,    1,   35,    2, 0x06 /* Public */,

 // signals: parameters
    QMetaType::Void, QMetaType::Int,    3,
    QMetaType::Void, QMetaType::Int,    3,
    QMetaType::Void, QMetaType::Int,    3,

       0        // eod
};

void TrackWidget::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<TrackWidget *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->playRequested((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 1: _t->addToPlaylistRequested((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 2: _t->deleteRequested((*reinterpret_cast< int(*)>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (TrackWidget::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&TrackWidget::playRequested)) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (TrackWidget::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&TrackWidget::addToPlaylistRequested)) {
                *result = 1;
                return;
            }
        }
        {
            using _t = void (TrackWidget::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&TrackWidget::deleteRequested)) {
                *result = 2;
                return;
            }
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject TrackWidget::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_TrackWidget.data,
    qt_meta_data_TrackWidget,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *TrackWidget::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *TrackWidget::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_TrackWidget.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int TrackWidget::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 3)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 3;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 3)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 3;
    }
    return _id;
}

// SIGNAL 0
void TrackWidget::playRequested(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}

// SIGNAL 1
void TrackWidget::addToPlaylistRequested(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 1, _a);
}

// SIGNAL 2
void TrackWidget::deleteRequested(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 2, _a);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/MYYQ2Y7GGF/moc_PlaybackController.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'PlaybackController.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../audio/PlaybackController.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'PlaybackController.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_PlaybackController_t {
    QByteArrayData data[14];
    char stringdata0[159];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_PlaybackController_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_PlaybackController_t qt_meta_stringdata_PlaybackController = {
    {
QT_MOC_LITERAL(0, 0, 18), // "PlaybackController"
QT_MOC_LITERAL(1, 19, 12), // "trackChanged"
QT_MOC_LITERAL(2, 32, 0), // ""
QT_MOC_LITERAL(3, 33, 9), // "TrackData"
QT_MOC_LITERAL(4, 43, 5), // "track"
QT_MOC_LITERAL(5, 49, 12), // "stateChanged"
QT_MOC_LITERAL(6, 62, 19), // "QMediaPlayer::State"
QT_MOC_LITERAL(7, 82, 5), // "state"
QT_MOC_LITERAL(8, 88, 15), // "positionChanged"
QT_MOC_LITERAL(9, 104, 8), // "position"
QT_MOC_LITERAL(10, 113, 15), // "durationChanged"
QT_MOC_LITERAL(11, 129, 8), // "duration"
QT_MOC_LITERAL(12, 138, 13), // "volumeChanged"
QT_MOC_LITERAL(13, 152, 6) // "volume"

    },
    "PlaybackController\0trackChanged\0\0"
    "TrackData\0track\0stateChanged\0"
    "QMediaPlayer::State\0state\0positionChanged\0"
    "position\0durationChanged\0duration\0"
    "volumeChanged\0volume"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_PlaybackController[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       5,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       5,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    1,   39,    2, 0x06 /* Public */,
       5,    1,   42,    2, 0x06 /* Public */,
       8,    1,   45,    2, 0x06 /* Public */,
      10,    1,   48,    2, 0x06 /* Public */,
      12,    1,   51,    2, 0x06 /* Public */,

 // signals: parameters
    QMetaType::Void, 0x80000000 | 3,    4,
    QMetaType::Void, 0x80000000 | 6,    7,
    QMetaType::Void, QMetaType::LongLong,    9,
    QMetaType::Void, QMetaType::LongLong,   11,
    QMetaType::Void, QMetaType::Int,   13,

       0        // eod
};

void PlaybackController::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<PlaybackController *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->trackChanged((*reinterpret_cast< const TrackData(*)>(_a[1]))); break;
        case 1: _t->stateChanged((*reinterpret_cast< QMediaPlayer::State(*)>(_a[1]))); break;
        case 2: _t->positionChanged((*reinterpret_cast< qint64(*)>(_a[1]))); break;
        case 3: _t->durationChanged((*reinterpret_cast< qint64(*)>(_a[1]))); break;
        case 4: _t->volumeChanged((*reinterpret_cast< int(*)>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        switch (_id) {
        default: *reinterpret_cast<int*>(_a[0]) = -1; break;
        case 0:
            switch (*reinterpret_cast<int*>(_a[1])) {
            default: *reinterpret_cast<int*>(_a[0]) = -1; break;
            case 0:
                *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< TrackData >(); break;
            }
            break;
        case 1:
            switch (*reinterpret_cast<int*>(_a[1])) {
            default: *reinterpret_cast<int*>(_a[0]) = -1; break;
            case 0:
                *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QMediaPlayer::State >(); break;
            }
            break;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (PlaybackController::*)(const TrackData & );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&PlaybackController::trackChanged)) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (PlaybackController::*)(QMediaPlayer::State );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&PlaybackController::stateChanged)) {
                *result = 1;
                return;
            }
        }
        {
            using _t = void (PlaybackController::*)(qint64 );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&PlaybackController::positionChanged)) {
                *result = 2;
                return;
            }
        }
        {
            using _t = void (PlaybackController::*)(qint64 );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&PlaybackController::durationChanged)) {
                *result = 3;
                return;
            }
        }
        {
            using _t = void (PlaybackController::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&PlaybackController::volumeChanged)) {
                *result = 4;
                return;
            }
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject PlaybackController::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_PlaybackController.data,
    qt_meta_data_PlaybackController,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *PlaybackController::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *PlaybackController::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_PlaybackController.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int PlaybackController::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 5)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 5;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 5)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 5;
    }
    return _id;
}

// SIGNAL 0
void PlaybackController::trackChanged(const TrackData & _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}

// SIGNAL 1
void PlaybackController::stateChanged(QMediaPlayer::State _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 1, _a);
}

// SIGNAL 2
void PlaybackController::positionChanged(qint64 _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 2, _a);
}

// SIGNAL 3
void PlaybackController::durationChanged(qint64 _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 3, _a);
}

// SIGNAL 4
void PlaybackController::volumeChanged(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 4, _a);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/MYYQ2Y7GGF/moc_LocalFileHandler.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'LocalFileHandler.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../audio/LocalFileHandler.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'LocalFileHandler.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_LocalFileHandler_t {
    QByteArrayData data[1];
    char stringdata0[17];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_LocalFileHandler_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_LocalFileHandler_t qt_meta_stringdata_LocalFileHandler = {
    {
QT_MOC_LITERAL(0, 0, 16) // "LocalFileHandler"

    },
    "LocalFileHandler"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_LocalFileHandler[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

void LocalFileHandler::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

QT_INIT_METAOBJECT const QMetaObject LocalFileHandler::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_LocalFileHandler.data,
    qt_meta_data_LocalFileHandler,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *LocalFileHandler::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *LocalFileHandler::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_LocalFileHandler.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int LocalFileHandler::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/MYYQ2Y7GGF/moc_AudioPlayer.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'AudioPlayer.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../audio/AudioPlayer.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'AudioPlayer.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_AudioPlayer_t {
    QByteArrayData data[14];
    char stringdata0[183];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_AudioPlayer_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_AudioPlayer_t qt_meta_stringdata_AudioPlayer = {
    {
QT_MOC_LITERAL(0, 0, 11), // "AudioPlayer"
QT_MOC_LITERAL(1, 12, 13), // "trackFinished"
QT_MOC_LITERAL(2, 26, 0), // ""
QT_MOC_LITERAL(3, 27, 17), // "playSelectedTrack"
QT_MOC_LITERAL(4, 45, 17), // "onPositionChanged"
QT_MOC_LITERAL(5, 63, 8), // "position"
QT_MOC_LITERAL(6, 72, 17), // "onDurationChanged"
QT_MOC_LITERAL(7, 90, 8), // "duration"
QT_MOC_LITERAL(8, 99, 9), // "seekTrack"
QT_MOC_LITERAL(9, 109, 22), // "onPlaybackStateChanged"
QT_MOC_LITERAL(10, 132, 21), // "updatePlaybackButtons"
QT_MOC_LITERAL(11, 154, 15), // "updateTrackInfo"
QT_MOC_LITERAL(12, 170, 5), // "title"
QT_MOC_LITERAL(13, 176, 6) // "artist"

    },
    "AudioPlayer\0trackFinished\0\0playSelectedTrack\0"
    "onPositionChanged\0position\0onDurationChanged\0"
    "duration\0seekTrack\0onPlaybackStateChanged\0"
    "updatePlaybackButtons\0updateTrackInfo\0"
    "title\0artist"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_AudioPlayer[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       8,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    0,   54,    2, 0x06 /* Public */,

 // slots: name, argc, parameters, tag, flags
       3,    0,   55,    2, 0x0a /* Public */,
       4,    1,   56,    2, 0x0a /* Public */,
       6,    1,   59,    2, 0x0a /* Public */,
       8,    1,   62,    2, 0x0a /* Public */,
       9,    0,   65,    2, 0x0a /* Public */,
      10,    0,   66,    2, 0x0a /* Public */,
      11,    2,   67,    2, 0x0a /* Public */,

 // signals: parameters
    QMetaType::Void,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void, QMetaType::LongLong,    5,
    QMetaType::Void, QMetaType::LongLong,    7,
    QMetaType::Void, QMetaType::Int,    5,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::QString, QMetaType::QString,   12,   13,

       0        // eod
};

void AudioPlayer::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<AudioPlayer *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->trackFinished(); break;
        case 1: _t->playSelectedTrack(); break;
        case 2: _t->onPositionChanged((*reinterpret_cast< qint64(*)>(_a[1]))); break;
        case 3: _t->onDurationChanged((*reinterpret_cast< qint64(*)>(_a[1]))); break;
        case 4: _t->seekTrack((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 5: _t->onPlaybackStateChanged(); break;
        case 6: _t->updatePlaybackButtons(); break;
        case 7: _t->updateTrackInfo((*reinterpret_cast< const QString(*)>(_a[1])),(*reinterpret_cast< const QString(*)>(_a[2]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (AudioPlayer::*)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&AudioPlayer::trackFinished)) {
                *result = 0;
                return;
            }
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject AudioPlayer::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_AudioPlayer.data,
    qt_meta_data_AudioPlayer,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *AudioPlayer::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *AudioPlayer::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_AudioPlayer.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int AudioPlayer::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 8)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 8;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 8)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 8;
    }
    return _id;
}

// SIGNAL 0
void AudioPlayer::trackFinished()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/mocs_compilation.cpp ===
// This file is autogenerated. Changes will be overwritten.
#include "MYYQ2Y7GGF/moc_AudioPlayer.cpp"
#include "MYYQ2Y7GGF/moc_LocalFileHandler.cpp"
#include "MYYQ2Y7GGF/moc_PlaybackController.cpp"
#include "MYYQ2Y7GGF/moc_TrackWidget.cpp"
#include "KSTO76GMGS/moc_PlaylistManager.cpp"
#include "KSTO76GMGS/moc_TrackManager.cpp"
#include "KSTO76GMGS/moc_UserManager.cpp"
#include "M7KQ2GL7XF/moc_DatabaseManager.cpp"
#include "OMUT2NUK4C/moc_MusicAPIManager.cpp"
#include "6F7CO4SI5M/moc_AuthWindow.cpp"
#include "RG5RW67LIN/moc_LoginForm.cpp"
#include "RG5RW67LIN/moc_RegisterForm.cpp"
#include "3I2UB5RNYX/moc_FramelessWindow.cpp"
#include "JV3FWA2OM2/moc_MainWindow.cpp"
#include "MSET4BVZOU/moc_FriendsPage.cpp"
#include "MSET4BVZOU/moc_MessagesPage.cpp"
#include "MSET4BVZOU/moc_MyMusicPage.cpp"
#include "MSET4BVZOU/moc_RoomsPage.cpp"
#include "MSET4BVZOU/moc_SearchMusicPage.cpp"
#include "5LFZYOI4EH/moc_ChatWidget.cpp"
#include "5LFZYOI4EH/moc_FriendCard.cpp"
#include "5LFZYOI4EH/moc_MessageBubble.cpp"
#include "5LFZYOI4EH/moc_RoomCard.cpp"
#include "5LFZYOI4EH/moc_Sidebar.cpp"
#include "5LFZYOI4EH/moc_TrackListItem.cpp"
#include "5LFZYOI4EH/moc_UserAvatar.cpp"
#include "UFQQIFJZKK/moc_ChatManager.cpp"
#include "UFQQIFJZKK/moc_FriendManager.cpp"
#include "UFQQIFJZKK/moc_RadioBrowserAPI.cpp"
#include "UFQQIFJZKK/moc_RoomManager.cpp"
#include "UFQQIFJZKK/moc_WebSocketClient.cpp"


=== kursach/src/Chorus_autogen/5LFZYOI4EH/moc_UserAvatar.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'UserAvatar.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../gui/widgets/UserAvatar.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'UserAvatar.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_UserAvatar_t {
    QByteArrayData data[1];
    char stringdata0[11];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_UserAvatar_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_UserAvatar_t qt_meta_stringdata_UserAvatar = {
    {
QT_MOC_LITERAL(0, 0, 10) // "UserAvatar"

    },
    "UserAvatar"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_UserAvatar[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

void UserAvatar::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

QT_INIT_METAOBJECT const QMetaObject UserAvatar::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_UserAvatar.data,
    qt_meta_data_UserAvatar,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *UserAvatar::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *UserAvatar::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_UserAvatar.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int UserAvatar::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/5LFZYOI4EH/moc_TrackListItem.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'TrackListItem.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../gui/widgets/TrackListItem.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'TrackListItem.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_TrackListItem_t {
    QByteArrayData data[6];
    char stringdata0[51];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_TrackListItem_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_TrackListItem_t qt_meta_stringdata_TrackListItem = {
    {
QT_MOC_LITERAL(0, 0, 13), // "TrackListItem"
QT_MOC_LITERAL(1, 14, 11), // "playClicked"
QT_MOC_LITERAL(2, 26, 0), // ""
QT_MOC_LITERAL(3, 27, 7), // "trackId"
QT_MOC_LITERAL(4, 35, 11), // "moreClicked"
QT_MOC_LITERAL(5, 47, 3) // "pos"

    },
    "TrackListItem\0playClicked\0\0trackId\0"
    "moreClicked\0pos"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_TrackListItem[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       2,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       2,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    1,   24,    2, 0x06 /* Public */,
       4,    2,   27,    2, 0x06 /* Public */,

 // signals: parameters
    QMetaType::Void, QMetaType::Int,    3,
    QMetaType::Void, QMetaType::Int, QMetaType::QPoint,    3,    5,

       0        // eod
};

void TrackListItem::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<TrackListItem *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->playClicked((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 1: _t->moreClicked((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< const QPoint(*)>(_a[2]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (TrackListItem::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&TrackListItem::playClicked)) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (TrackListItem::*)(int , const QPoint & );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&TrackListItem::moreClicked)) {
                *result = 1;
                return;
            }
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject TrackListItem::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_TrackListItem.data,
    qt_meta_data_TrackListItem,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *TrackListItem::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *TrackListItem::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_TrackListItem.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int TrackListItem::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 2)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 2;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 2)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 2;
    }
    return _id;
}

// SIGNAL 0
void TrackListItem::playClicked(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}

// SIGNAL 1
void TrackListItem::moreClicked(int _t1, const QPoint & _t2)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))) };
    QMetaObject::activate(this, &staticMetaObject, 1, _a);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/5LFZYOI4EH/moc_ChatWidget.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'ChatWidget.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../gui/widgets/ChatWidget.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'ChatWidget.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_ChatWidget_t {
    QByteArrayData data[4];
    char stringdata0[38];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_ChatWidget_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_ChatWidget_t qt_meta_stringdata_ChatWidget = {
    {
QT_MOC_LITERAL(0, 0, 10), // "ChatWidget"
QT_MOC_LITERAL(1, 11, 11), // "backClicked"
QT_MOC_LITERAL(2, 23, 0), // ""
QT_MOC_LITERAL(3, 24, 13) // "onSendMessage"

    },
    "ChatWidget\0backClicked\0\0onSendMessage"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_ChatWidget[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       2,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    0,   24,    2, 0x06 /* Public */,

 // slots: name, argc, parameters, tag, flags
       3,    0,   25,    2, 0x08 /* Private */,

 // signals: parameters
    QMetaType::Void,

 // slots: parameters
    QMetaType::Void,

       0        // eod
};

void ChatWidget::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<ChatWidget *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->backClicked(); break;
        case 1: _t->onSendMessage(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (ChatWidget::*)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&ChatWidget::backClicked)) {
                *result = 0;
                return;
            }
        }
    }
    (void)_a;
}

QT_INIT_METAOBJECT const QMetaObject ChatWidget::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_ChatWidget.data,
    qt_meta_data_ChatWidget,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *ChatWidget::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *ChatWidget::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_ChatWidget.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int ChatWidget::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 2)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 2;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 2)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 2;
    }
    return _id;
}

// SIGNAL 0
void ChatWidget::backClicked()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/5LFZYOI4EH/moc_FriendCard.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'FriendCard.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../gui/widgets/FriendCard.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'FriendCard.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_FriendCard_t {
    QByteArrayData data[7];
    char stringdata0[86];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_FriendCard_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_FriendCard_t qt_meta_stringdata_FriendCard = {
    {
QT_MOC_LITERAL(0, 0, 10), // "FriendCard"
QT_MOC_LITERAL(1, 11, 13), // "acceptClicked"
QT_MOC_LITERAL(2, 25, 0), // ""
QT_MOC_LITERAL(3, 26, 13), // "rejectClicked"
QT_MOC_LITERAL(4, 40, 13), // "removeClicked"
QT_MOC_LITERAL(5, 54, 14), // "messageClicked"
QT_MOC_LITERAL(6, 69, 16) // "addFriendClicked"

    },
    "FriendCard\0acceptClicked\0\0rejectClicked\0"
    "removeClicked\0messageClicked\0"
    "addFriendClicked"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_FriendCard[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       5,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       5,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    0,   39,    2, 0x06 /* Public */,
       3,    0,   40,    2, 0x06 /* Public */,
       4,    0,   41,    2, 0x06 /* Public */,
       5,    0,   42,    2, 0x06 /* Public */,
       6,    0,   43,    2, 0x06 /* Public */,

 // signals: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};

void FriendCard::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<FriendCard *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->acceptClicked(); break;
        case 1: _t->rejectClicked(); break;
        case 2: _t->removeClicked(); break;
        case 3: _t->messageClicked(); break;
        case 4: _t->addFriendClicked(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (FriendCard::*)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&FriendCard::acceptClicked)) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (FriendCard::*)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&FriendCard::rejectClicked)) {
                *result = 1;
                return;
            }
        }
        {
            using _t = void (FriendCard::*)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&FriendCard::removeClicked)) {
                *result = 2;
                return;
            }
        }
        {
            using _t = void (FriendCard::*)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&FriendCard::messageClicked)) {
                *result = 3;
                return;
            }
        }
        {
            using _t = void (FriendCard::*)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&FriendCard::addFriendClicked)) {
                *result = 4;
                return;
            }
        }
    }
    (void)_a;
}

QT_INIT_METAOBJECT const QMetaObject FriendCard::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_FriendCard.data,
    qt_meta_data_FriendCard,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *FriendCard::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *FriendCard::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_FriendCard.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int FriendCard::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 5)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 5;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 5)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 5;
    }
    return _id;
}

// SIGNAL 0
void FriendCard::acceptClicked()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}

// SIGNAL 1
void FriendCard::rejectClicked()
{
    QMetaObject::activate(this, &staticMetaObject, 1, nullptr);
}

// SIGNAL 2
void FriendCard::removeClicked()
{
    QMetaObject::activate(this, &staticMetaObject, 2, nullptr);
}

// SIGNAL 3
void FriendCard::messageClicked()
{
    QMetaObject::activate(this, &staticMetaObject, 3, nullptr);
}

// SIGNAL 4
void FriendCard::addFriendClicked()
{
    QMetaObject::activate(this, &staticMetaObject, 4, nullptr);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/5LFZYOI4EH/moc_Sidebar.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'Sidebar.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../gui/widgets/Sidebar.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'Sidebar.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_Sidebar_t {
    QByteArrayData data[5];
    char stringdata0[43];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_Sidebar_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_Sidebar_t qt_meta_stringdata_Sidebar = {
    {
QT_MOC_LITERAL(0, 0, 7), // "Sidebar"
QT_MOC_LITERAL(1, 8, 11), // "pageChanged"
QT_MOC_LITERAL(2, 20, 0), // ""
QT_MOC_LITERAL(3, 21, 5), // "index"
QT_MOC_LITERAL(4, 27, 15) // "logoutRequested"

    },
    "Sidebar\0pageChanged\0\0index\0logoutRequested"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_Sidebar[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       2,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       2,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    1,   24,    2, 0x06 /* Public */,
       4,    0,   27,    2, 0x06 /* Public */,

 // signals: parameters
    QMetaType::Void, QMetaType::Int,    3,
    QMetaType::Void,

       0        // eod
};

void Sidebar::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<Sidebar *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->pageChanged((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 1: _t->logoutRequested(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (Sidebar::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Sidebar::pageChanged)) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (Sidebar::*)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Sidebar::logoutRequested)) {
                *result = 1;
                return;
            }
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject Sidebar::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_Sidebar.data,
    qt_meta_data_Sidebar,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *Sidebar::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *Sidebar::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_Sidebar.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int Sidebar::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 2)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 2;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 2)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 2;
    }
    return _id;
}

// SIGNAL 0
void Sidebar::pageChanged(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}

// SIGNAL 1
void Sidebar::logoutRequested()
{
    QMetaObject::activate(this, &staticMetaObject, 1, nullptr);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/5LFZYOI4EH/moc_MessageBubble.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'MessageBubble.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../gui/widgets/MessageBubble.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'MessageBubble.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_MessageBubble_t {
    QByteArrayData data[1];
    char stringdata0[14];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_MessageBubble_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_MessageBubble_t qt_meta_stringdata_MessageBubble = {
    {
QT_MOC_LITERAL(0, 0, 13) // "MessageBubble"

    },
    "MessageBubble"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_MessageBubble[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

void MessageBubble::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

QT_INIT_METAOBJECT const QMetaObject MessageBubble::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_MessageBubble.data,
    qt_meta_data_MessageBubble,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *MessageBubble::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *MessageBubble::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_MessageBubble.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int MessageBubble::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/5LFZYOI4EH/moc_RoomCard.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'RoomCard.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../gui/widgets/RoomCard.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'RoomCard.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_RoomCard_t {
    QByteArrayData data[4];
    char stringdata0[29];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_RoomCard_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_RoomCard_t qt_meta_stringdata_RoomCard = {
    {
QT_MOC_LITERAL(0, 0, 8), // "RoomCard"
QT_MOC_LITERAL(1, 9, 11), // "joinClicked"
QT_MOC_LITERAL(2, 21, 0), // ""
QT_MOC_LITERAL(3, 22, 6) // "roomId"

    },
    "RoomCard\0joinClicked\0\0roomId"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_RoomCard[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    1,   19,    2, 0x06 /* Public */,

 // signals: parameters
    QMetaType::Void, QMetaType::Int,    3,

       0        // eod
};

void RoomCard::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<RoomCard *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->joinClicked((*reinterpret_cast< int(*)>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (RoomCard::*)(int );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&RoomCard::joinClicked)) {
                *result = 0;
                return;
            }
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject RoomCard::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_RoomCard.data,
    qt_meta_data_RoomCard,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *RoomCard::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *RoomCard::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_RoomCard.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int RoomCard::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 1;
    }
    return _id;
}

// SIGNAL 0
void RoomCard::joinClicked(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/3I2UB5RNYX/moc_FramelessWindow.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'FramelessWindow.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../gui/Frameless/FramelessWindow.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'FramelessWindow.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_FramelessWindow_t {
    QByteArrayData data[1];
    char stringdata0[16];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_FramelessWindow_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_FramelessWindow_t qt_meta_stringdata_FramelessWindow = {
    {
QT_MOC_LITERAL(0, 0, 15) // "FramelessWindow"

    },
    "FramelessWindow"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_FramelessWindow[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

void FramelessWindow::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

QT_INIT_METAOBJECT const QMetaObject FramelessWindow::staticMetaObject = { {
    QMetaObject::SuperData::link<QMainWindow::staticMetaObject>(),
    qt_meta_stringdata_FramelessWindow.data,
    qt_meta_data_FramelessWindow,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *FramelessWindow::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *FramelessWindow::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_FramelessWindow.stringdata0))
        return static_cast<void*>(this);
    return QMainWindow::qt_metacast(_clname);
}

int FramelessWindow::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QMainWindow::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/MSET4BVZOU/moc_FriendsPage.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'FriendsPage.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../gui/MainWindow/pages/FriendsPage.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'FriendsPage.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_FriendsPage_t {
    QByteArrayData data[14];
    char stringdata0[179];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_FriendsPage_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_FriendsPage_t qt_meta_stringdata_FriendsPage = {
    {
QT_MOC_LITERAL(0, 0, 11), // "FriendsPage"
QT_MOC_LITERAL(1, 12, 18), // "openChatWithFriend"
QT_MOC_LITERAL(2, 31, 0), // ""
QT_MOC_LITERAL(3, 32, 8), // "friendId"
QT_MOC_LITERAL(4, 41, 10), // "friendName"
QT_MOC_LITERAL(5, 52, 15), // "onSearchClicked"
QT_MOC_LITERAL(6, 68, 13), // "onShowFriends"
QT_MOC_LITERAL(7, 82, 14), // "onShowRequests"
QT_MOC_LITERAL(8, 97, 11), // "onAddFriend"
QT_MOC_LITERAL(9, 109, 6), // "userId"
QT_MOC_LITERAL(10, 116, 15), // "onAcceptRequest"
QT_MOC_LITERAL(11, 132, 15), // "onRejectRequest"
QT_MOC_LITERAL(12, 148, 14), // "onRemoveFriend"
QT_MOC_LITERAL(13, 163, 15) // "onMessageFriend"

    },
    "FriendsPage\0openChatWithFriend\0\0"
    "friendId\0friendName\0onSearchClicked\0"
    "onShowFriends\0onShowRequests\0onAddFriend\0"
    "userId\0onAcceptRequest\0onRejectRequest\0"
    "onRemoveFriend\0onMessageFriend"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_FriendsPage[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       9,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    2,   59,    2, 0x06 /* Public */,

 // slots: name, argc, parameters, tag, flags
       5,    0,   64,    2, 0x08 /* Private */,
       6,    0,   65,    2, 0x08 /* Private */,
       7,    0,   66,    2, 0x08 /* Private */,
       8,    1,   67,    2, 0x08 /* Private */,
      10,    1,   70,    2, 0x08 /* Private */,
      11,    1,   73,    2, 0x08 /* Private */,
      12,    1,   76,    2, 0x08 /* Private */,
      13,    1,   79,    2, 0x08 /* Private */,

 // signals: parameters
    QMetaType::Void, QMetaType::Int, QMetaType::QString,    3,    4,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::Int,    9,
    QMetaType::Void, QMetaType::Int,    9,
    QMetaType::Void, QMetaType::Int,    9,
    QMetaType::Void, QMetaType::Int,    9,
    QMetaType::Void, QMetaType::Int,    9,

       0        // eod
};

void FriendsPage::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<FriendsPage *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->openChatWithFriend((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< const QString(*)>(_a[2]))); break;
        case 1: _t->onSearchClicked(); break;
        case 2: _t->onShowFriends(); break;
        case 3: _t->onShowRequests(); break;
        case 4: _t->onAddFriend((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 5: _t->onAcceptRequest((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 6: _t->onRejectRequest((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 7: _t->onRemoveFriend((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 8: _t->onMessageFriend((*reinterpret_cast< int(*)>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (FriendsPage::*)(int , const QString & );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&FriendsPage::openChatWithFriend)) {
                *result = 0;
                return;
            }
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject FriendsPage::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_FriendsPage.data,
    qt_meta_data_FriendsPage,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *FriendsPage::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *FriendsPage::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_FriendsPage.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int FriendsPage::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 9)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 9;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 9)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 9;
    }
    return _id;
}

// SIGNAL 0
void FriendsPage::openChatWithFriend(int _t1, const QString & _t2)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/MSET4BVZOU/moc_MessagesPage.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'MessagesPage.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../gui/MainWindow/pages/MessagesPage.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'MessagesPage.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_MessagesPage_t {
    QByteArrayData data[6];
    char stringdata0[64];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_MessagesPage_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_MessagesPage_t qt_meta_stringdata_MessagesPage = {
    {
QT_MOC_LITERAL(0, 0, 12), // "MessagesPage"
QT_MOC_LITERAL(1, 13, 14), // "onChatSelected"
QT_MOC_LITERAL(2, 28, 0), // ""
QT_MOC_LITERAL(3, 29, 16), // "QListWidgetItem*"
QT_MOC_LITERAL(4, 46, 4), // "item"
QT_MOC_LITERAL(5, 51, 12) // "onBackToList"

    },
    "MessagesPage\0onChatSelected\0\0"
    "QListWidgetItem*\0item\0onBackToList"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_MessagesPage[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       2,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags
       1,    1,   24,    2, 0x08 /* Private */,
       5,    0,   27,    2, 0x08 /* Private */,

 // slots: parameters
    QMetaType::Void, 0x80000000 | 3,    4,
    QMetaType::Void,

       0        // eod
};

void MessagesPage::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<MessagesPage *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->onChatSelected((*reinterpret_cast< QListWidgetItem*(*)>(_a[1]))); break;
        case 1: _t->onBackToList(); break;
        default: ;
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject MessagesPage::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_MessagesPage.data,
    qt_meta_data_MessagesPage,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *MessagesPage::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *MessagesPage::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_MessagesPage.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int MessagesPage::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 2)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 2;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 2)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 2;
    }
    return _id;
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/MSET4BVZOU/moc_RoomsPage.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'RoomsPage.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../gui/MainWindow/pages/RoomsPage.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'RoomsPage.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_RoomsPage_t {
    QByteArrayData data[8];
    char stringdata0[74];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_RoomsPage_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_RoomsPage_t qt_meta_stringdata_RoomsPage = {
    {
QT_MOC_LITERAL(0, 0, 9), // "RoomsPage"
QT_MOC_LITERAL(1, 10, 12), // "onCreateRoom"
QT_MOC_LITERAL(2, 23, 0), // ""
QT_MOC_LITERAL(3, 24, 10), // "onJoinRoom"
QT_MOC_LITERAL(4, 35, 6), // "roomId"
QT_MOC_LITERAL(5, 42, 11), // "onLeaveRoom"
QT_MOC_LITERAL(6, 54, 13), // "onSearchRooms"
QT_MOC_LITERAL(7, 68, 5) // "query"

    },
    "RoomsPage\0onCreateRoom\0\0onJoinRoom\0"
    "roomId\0onLeaveRoom\0onSearchRooms\0query"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_RoomsPage[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       4,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags
       1,    0,   34,    2, 0x08 /* Private */,
       3,    1,   35,    2, 0x08 /* Private */,
       5,    0,   38,    2, 0x08 /* Private */,
       6,    1,   39,    2, 0x08 /* Private */,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void, QMetaType::Int,    4,
    QMetaType::Void,
    QMetaType::Void, QMetaType::QString,    7,

       0        // eod
};

void RoomsPage::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<RoomsPage *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->onCreateRoom(); break;
        case 1: _t->onJoinRoom((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 2: _t->onLeaveRoom(); break;
        case 3: _t->onSearchRooms((*reinterpret_cast< const QString(*)>(_a[1]))); break;
        default: ;
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject RoomsPage::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_RoomsPage.data,
    qt_meta_data_RoomsPage,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *RoomsPage::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *RoomsPage::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_RoomsPage.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int RoomsPage::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 4)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 4;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 4)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 4;
    }
    return _id;
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/MSET4BVZOU/moc_MyMusicPage.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'MyMusicPage.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../gui/MainWindow/pages/MyMusicPage.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'MyMusicPage.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_MyMusicPage_t {
    QByteArrayData data[20];
    char stringdata0[252];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_MyMusicPage_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_MyMusicPage_t qt_meta_stringdata_MyMusicPage = {
    {
QT_MOC_LITERAL(0, 0, 11), // "MyMusicPage"
QT_MOC_LITERAL(1, 12, 18), // "playTrackRequested"
QT_MOC_LITERAL(2, 31, 0), // ""
QT_MOC_LITERAL(3, 32, 9), // "TrackData"
QT_MOC_LITERAL(4, 42, 5), // "track"
QT_MOC_LITERAL(5, 48, 20), // "onTrackDoubleClicked"
QT_MOC_LITERAL(6, 69, 16), // "QListWidgetItem*"
QT_MOC_LITERAL(7, 86, 4), // "item"
QT_MOC_LITERAL(8, 91, 15), // "onSearchChanged"
QT_MOC_LITERAL(9, 107, 4), // "text"
QT_MOC_LITERAL(10, 112, 18), // "onTrackContextMenu"
QT_MOC_LITERAL(11, 131, 3), // "pos"
QT_MOC_LITERAL(12, 135, 13), // "onDeleteTrack"
QT_MOC_LITERAL(13, 149, 7), // "trackId"
QT_MOC_LITERAL(14, 157, 16), // "onRefreshClicked"
QT_MOC_LITERAL(15, 174, 18), // "onPlayRadioClicked"
QT_MOC_LITERAL(16, 193, 22), // "onRadioListContextMenu"
QT_MOC_LITERAL(17, 216, 11), // "onPlayRadio"
QT_MOC_LITERAL(18, 228, 9), // "stationId"
QT_MOC_LITERAL(19, 238, 13) // "onDeleteRadio"

    },
    "MyMusicPage\0playTrackRequested\0\0"
    "TrackData\0track\0onTrackDoubleClicked\0"
    "QListWidgetItem*\0item\0onSearchChanged\0"
    "text\0onTrackContextMenu\0pos\0onDeleteTrack\0"
    "trackId\0onRefreshClicked\0onPlayRadioClicked\0"
    "onRadioListContextMenu\0onPlayRadio\0"
    "stationId\0onDeleteRadio"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_MyMusicPage[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
      10,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    1,   64,    2, 0x06 /* Public */,

 // slots: name, argc, parameters, tag, flags
       5,    1,   67,    2, 0x08 /* Private */,
       8,    1,   70,    2, 0x08 /* Private */,
      10,    1,   73,    2, 0x08 /* Private */,
      12,    1,   76,    2, 0x08 /* Private */,
      14,    0,   79,    2, 0x08 /* Private */,
      15,    0,   80,    2, 0x08 /* Private */,
      16,    1,   81,    2, 0x08 /* Private */,
      17,    1,   84,    2, 0x08 /* Private */,
      19,    1,   87,    2, 0x08 /* Private */,

 // signals: parameters
    QMetaType::Void, 0x80000000 | 3,    4,

 // slots: parameters
    QMetaType::Void, 0x80000000 | 6,    7,
    QMetaType::Void, QMetaType::QString,    9,
    QMetaType::Void, QMetaType::QPoint,   11,
    QMetaType::Void, QMetaType::Int,   13,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::QPoint,   11,
    QMetaType::Void, QMetaType::Int,   18,
    QMetaType::Void, QMetaType::Int,   18,

       0        // eod
};

void MyMusicPage::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<MyMusicPage *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->playTrackRequested((*reinterpret_cast< const TrackData(*)>(_a[1]))); break;
        case 1: _t->onTrackDoubleClicked((*reinterpret_cast< QListWidgetItem*(*)>(_a[1]))); break;
        case 2: _t->onSearchChanged((*reinterpret_cast< const QString(*)>(_a[1]))); break;
        case 3: _t->onTrackContextMenu((*reinterpret_cast< const QPoint(*)>(_a[1]))); break;
        case 4: _t->onDeleteTrack((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 5: _t->onRefreshClicked(); break;
        case 6: _t->onPlayRadioClicked(); break;
        case 7: _t->onRadioListContextMenu((*reinterpret_cast< const QPoint(*)>(_a[1]))); break;
        case 8: _t->onPlayRadio((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 9: _t->onDeleteRadio((*reinterpret_cast< int(*)>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        switch (_id) {
        default: *reinterpret_cast<int*>(_a[0]) = -1; break;
        case 0:
            switch (*reinterpret_cast<int*>(_a[1])) {
            default: *reinterpret_cast<int*>(_a[0]) = -1; break;
            case 0:
                *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< TrackData >(); break;
            }
            break;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (MyMusicPage::*)(const TrackData & );
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&MyMusicPage::playTrackRequested)) {
                *result = 0;
                return;
            }
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject MyMusicPage::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_MyMusicPage.data,
    qt_meta_data_MyMusicPage,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *MyMusicPage::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *MyMusicPage::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_MyMusicPage.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int MyMusicPage::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 10)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 10;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 10)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 10;
    }
    return _id;
}

// SIGNAL 0
void MyMusicPage::playTrackRequested(const TrackData & _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/MSET4BVZOU/moc_SearchMusicPage.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'SearchMusicPage.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../gui/MainWindow/pages/SearchMusicPage.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'SearchMusicPage.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_SearchMusicPage_t {
    QByteArrayData data[18];
    char stringdata0[238];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_SearchMusicPage_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_SearchMusicPage_t qt_meta_stringdata_SearchMusicPage = {
    {
QT_MOC_LITERAL(0, 0, 15), // "SearchMusicPage"
QT_MOC_LITERAL(1, 16, 12), // "stationAdded"
QT_MOC_LITERAL(2, 29, 0), // ""
QT_MOC_LITERAL(3, 30, 15), // "onSearchClicked"
QT_MOC_LITERAL(4, 46, 20), // "onTopStationsClicked"
QT_MOC_LITERAL(5, 67, 14), // "onGenreChanged"
QT_MOC_LITERAL(6, 82, 5), // "genre"
QT_MOC_LITERAL(7, 88, 15), // "onStationsFound"
QT_MOC_LITERAL(8, 104, 8), // "stations"
QT_MOC_LITERAL(9, 113, 17), // "onStationSelected"
QT_MOC_LITERAL(10, 131, 16), // "QListWidgetItem*"
QT_MOC_LITERAL(11, 148, 4), // "item"
QT_MOC_LITERAL(12, 153, 20), // "onStationContextMenu"
QT_MOC_LITERAL(13, 174, 3), // "pos"
QT_MOC_LITERAL(14, 178, 14), // "onNetworkError"
QT_MOC_LITERAL(15, 193, 5), // "error"
QT_MOC_LITERAL(16, 199, 19), // "playSelectedStation"
QT_MOC_LITERAL(17, 219, 18) // "addSelectedStation"

    },
    "SearchMusicPage\0stationAdded\0\0"
    "onSearchClicked\0onTopStationsClicked\0"
    "onGenreChanged\0genre\0onStationsFound\0"
    "stations\0onStationSelected\0QListWidgetItem*\0"
    "item\0onStationContextMenu\0pos\0"
    "onNetworkError\0error\0playSelectedStation\0"
    "addSelectedStation"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_SearchMusicPage[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
      10,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    0,   64,    2, 0x06 /* Public */,

 // slots: name, argc, parameters, tag, flags
       3,    0,   65,    2, 0x08 /* Private */,
       4,    0,   66,    2, 0x08 /* Private */,
       5,    1,   67,    2, 0x08 /* Private */,
       7,    1,   70,    2, 0x08 /* Private */,
       9,    1,   73,    2, 0x08 /* Private */,
      12,    1,   76,    2, 0x08 /* Private */,
      14,    1,   79,    2, 0x08 /* Private */,
      16,    0,   82,    2, 0x08 /* Private */,
      17,    0,   83,    2, 0x08 /* Private */,

 // signals: parameters
    QMetaType::Void,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::QString,    6,
    QMetaType::Void, QMetaType::QVariantList,    8,
    QMetaType::Void, 0x80000000 | 10,   11,
    QMetaType::Void, QMetaType::QPoint,   13,
    QMetaType::Void, QMetaType::QString,   15,
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};

void SearchMusicPage::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<SearchMusicPage *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->stationAdded(); break;
        case 1: _t->onSearchClicked(); break;
        case 2: _t->onTopStationsClicked(); break;
        case 3: _t->onGenreChanged((*reinterpret_cast< const QString(*)>(_a[1]))); break;
        case 4: _t->onStationsFound((*reinterpret_cast< const QVariantList(*)>(_a[1]))); break;
        case 5: _t->onStationSelected((*reinterpret_cast< QListWidgetItem*(*)>(_a[1]))); break;
        case 6: _t->onStationContextMenu((*reinterpret_cast< const QPoint(*)>(_a[1]))); break;
        case 7: _t->onNetworkError((*reinterpret_cast< const QString(*)>(_a[1]))); break;
        case 8: _t->playSelectedStation(); break;
        case 9: _t->addSelectedStation(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (SearchMusicPage::*)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&SearchMusicPage::stationAdded)) {
                *result = 0;
                return;
            }
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject SearchMusicPage::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_SearchMusicPage.data,
    qt_meta_data_SearchMusicPage,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *SearchMusicPage::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *SearchMusicPage::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_SearchMusicPage.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int SearchMusicPage::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 10)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 10;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 10)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 10;
    }
    return _id;
}

// SIGNAL 0
void SearchMusicPage::stationAdded()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/6F7CO4SI5M/moc_AuthWindow.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'AuthWindow.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../gui/AuthWindow/AuthWindow.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'AuthWindow.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_AuthWindow_t {
    QByteArrayData data[8];
    char stringdata0[92];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_AuthWindow_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_AuthWindow_t qt_meta_stringdata_AuthWindow = {
    {
QT_MOC_LITERAL(0, 0, 10), // "AuthWindow"
QT_MOC_LITERAL(1, 11, 14), // "onLoginSuccess"
QT_MOC_LITERAL(2, 26, 0), // ""
QT_MOC_LITERAL(3, 27, 8), // "username"
QT_MOC_LITERAL(4, 36, 6), // "userId"
QT_MOC_LITERAL(5, 43, 17), // "onRegisterSuccess"
QT_MOC_LITERAL(6, 61, 13), // "switchToLogin"
QT_MOC_LITERAL(7, 75, 16) // "switchToRegister"

    },
    "AuthWindow\0onLoginSuccess\0\0username\0"
    "userId\0onRegisterSuccess\0switchToLogin\0"
    "switchToRegister"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_AuthWindow[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       4,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags
       1,    2,   34,    2, 0x08 /* Private */,
       5,    0,   39,    2, 0x08 /* Private */,
       6,    0,   40,    2, 0x08 /* Private */,
       7,    0,   41,    2, 0x08 /* Private */,

 // slots: parameters
    QMetaType::Void, QMetaType::QString, QMetaType::Int,    3,    4,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};

void AuthWindow::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<AuthWindow *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->onLoginSuccess((*reinterpret_cast< const QString(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
        case 1: _t->onRegisterSuccess(); break;
        case 2: _t->switchToLogin(); break;
        case 3: _t->switchToRegister(); break;
        default: ;
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject AuthWindow::staticMetaObject = { {
    QMetaObject::SuperData::link<QMainWindow::staticMetaObject>(),
    qt_meta_stringdata_AuthWindow.data,
    qt_meta_data_AuthWindow,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *AuthWindow::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *AuthWindow::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_AuthWindow.stringdata0))
        return static_cast<void*>(this);
    return QMainWindow::qt_metacast(_clname);
}

int AuthWindow::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QMainWindow::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 4)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 4;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 4)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 4;
    }
    return _id;
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/Chorus_autogen/JV3FWA2OM2/moc_MainWindow.cpp ===
/****************************************************************************
** Meta object code from reading C++ file 'MainWindow.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.13)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "../../gui/MainWindow/MainWindow.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'MainWindow.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.13. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_MainWindow_t {
    QByteArrayData data[18];
    char stringdata0[263];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_MainWindow_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_MainWindow_t qt_meta_stringdata_MainWindow = {
    {
QT_MOC_LITERAL(0, 0, 10), // "MainWindow"
QT_MOC_LITERAL(1, 11, 16), // "setupConnections"
QT_MOC_LITERAL(2, 28, 0), // ""
QT_MOC_LITERAL(3, 29, 9), // "playRadio"
QT_MOC_LITERAL(4, 39, 7), // "radioId"
QT_MOC_LITERAL(5, 47, 21), // "onPlaylistItemClicked"
QT_MOC_LITERAL(6, 69, 16), // "QListWidgetItem*"
QT_MOC_LITERAL(7, 86, 4), // "item"
QT_MOC_LITERAL(8, 91, 22), // "onRadioDeleteRequested"
QT_MOC_LITERAL(9, 114, 13), // "loadUserRadio"
QT_MOC_LITERAL(10, 128, 15), // "showProfilePage"
QT_MOC_LITERAL(11, 144, 16), // "showMessagesPage"
QT_MOC_LITERAL(12, 161, 15), // "showFriendsPage"
QT_MOC_LITERAL(13, 177, 21), // "showNotificationsPage"
QT_MOC_LITERAL(14, 199, 16), // "showPlaylistPage"
QT_MOC_LITERAL(15, 216, 13), // "showRoomsPage"
QT_MOC_LITERAL(16, 230, 12), // "changeAvatar"
QT_MOC_LITERAL(17, 243, 19) // "onRadioStationAdded"

    },
    "MainWindow\0setupConnections\0\0playRadio\0"
    "radioId\0onPlaylistItemClicked\0"
    "QListWidgetItem*\0item\0onRadioDeleteRequested\0"
    "loadUserRadio\0showProfilePage\0"
    "showMessagesPage\0showFriendsPage\0"
    "showNotificationsPage\0showPlaylistPage\0"
    "showRoomsPage\0changeAvatar\0"
    "onRadioStationAdded"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_MainWindow[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
      13,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags
       1,    0,   79,    2, 0x08 /* Private */,
       3,    1,   80,    2, 0x08 /* Private */,
       5,    1,   83,    2, 0x08 /* Private */,
       8,    1,   86,    2, 0x08 /* Private */,
       9,    0,   89,    2, 0x08 /* Private */,
      10,    0,   90,    2, 0x08 /* Private */,
      11,    0,   91,    2, 0x08 /* Private */,
      12,    0,   92,    2, 0x08 /* Private */,
      13,    0,   93,    2, 0x08 /* Private */,
      14,    0,   94,    2, 0x08 /* Private */,
      15,    0,   95,    2, 0x08 /* Private */,
      16,    0,   96,    2, 0x08 /* Private */,
      17,    0,   97,    2, 0x08 /* Private */,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void, QMetaType::Int,    4,
    QMetaType::Void, 0x80000000 | 6,    7,
    QMetaType::Void, QMetaType::Int,    4,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};

void MainWindow::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<MainWindow *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->setupConnections(); break;
        case 1: _t->playRadio((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 2: _t->onPlaylistItemClicked((*reinterpret_cast< QListWidgetItem*(*)>(_a[1]))); break;
        case 3: _t->onRadioDeleteRequested((*reinterpret_cast< int(*)>(_a[1]))); break;
        case 4: _t->loadUserRadio(); break;
        case 5: _t->showProfilePage(); break;
        case 6: _t->showMessagesPage(); break;
        case 7: _t->showFriendsPage(); break;
        case 8: _t->showNotificationsPage(); break;
        case 9: _t->showPlaylistPage(); break;
        case 10: _t->showRoomsPage(); break;
        case 11: _t->changeAvatar(); break;
        case 12: _t->onRadioStationAdded(); break;
        default: ;
        }
    }
}

QT_INIT_METAOBJECT const QMetaObject MainWindow::staticMetaObject = { {
    QMetaObject::SuperData::link<FramelessWindow::staticMetaObject>(),
    qt_meta_stringdata_MainWindow.data,
    qt_meta_data_MainWindow,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *MainWindow::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *MainWindow::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_MainWindow.stringdata0))
        return static_cast<void*>(this);
    return FramelessWindow::qt_metacast(_clname);
}

int MainWindow::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = FramelessWindow::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 13)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 13;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 13)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 13;
    }
    return _id;
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE


=== kursach/src/network/RadioBrowserAPI.h ===
#ifndef RADIOBROWSERAPIH
#define RADIOBROWSERAPIH

#include <QObject>
#include <QNetworkAccessManager>
#include <QNetworkReply>
#include <QVariant>
#include <core/models/Track.h>

class RadioBrowserAPI : public QObject
{
    Q_OBJECT

public:
    explicit RadioBrowserAPI(QObject *parent = nullptr);
    void searchStations(const QString &query, int limit = 50);
    void getTopStations(int limit = 50);
    void getStationsByGenre(const QString &genre, int limit = 50);

signals:
    void stationsReady(const QVariantList &stations);
    void errorOccurred(const QString &error);

private slots:
    void onSearchFinished();

private:
    TrackData parseStation(const QJsonObject &obj);
    QNetworkAccessManager mnetwork;
};

#endif


=== kursach/src/network/WebSocketClient.cpp ===
#include "WebSocketClient.h"
#include <QJsonDocument>
#include <QDebug>

WebSocketClient::WebSocketClient(int userId, QObject *parent)
    : QObject(parent)
    , m_webSocket(new QWebSocket())
    , m_userId(userId)
    , m_isConnected(false)
{
    connect(m_webSocket, &QWebSocket::connected, this, &WebSocketClient::onConnected);
    connect(m_webSocket, &QWebSocket::disconnected, this, &WebSocketClient::onDisconnected);
    connect(m_webSocket, &QWebSocket::textMessageReceived, this, &WebSocketClient::onTextMessageReceived);
    connect(m_webSocket, QOverload<QAbstractSocket::SocketError>::of(&QWebSocket::error), 
            this, &WebSocketClient::onError);
}

WebSocketClient::~WebSocketClient()
{
    if (m_isConnected) {
        m_webSocket->close();
    }
    delete m_webSocket;
}

void WebSocketClient::connectToServer(const QString& url)
{
    if (m_isConnected) {
        return;
    }
    
    m_webSocket->open(QUrl(url));
}

void WebSocketClient::disconnect()
{
    if (m_isConnected) {
        m_webSocket->close();
    }
}

void WebSocketClient::joinRoom(int roomId)
{
    QJsonObject json;
    json["type"] = "join_room";
    json["userId"] = m_userId;
    json["roomId"] = roomId;
    
    sendJson(json);
}

void WebSocketClient::leaveRoom(int roomId)
{
    QJsonObject json;
    json["type"] = "leave_room";
    json["userId"] = m_userId;
    json["roomId"] = roomId;
    
    sendJson(json);
}

void WebSocketClient::sendMessage(int roomId, const QString& message)
{
    QJsonObject json;
    json["type"] = "chat_message";
    json["userId"] = m_userId;
    json["roomId"] = roomId;
    json["message"] = message;
    
    sendJson(json);
}

void WebSocketClient::updatePlaybackState(int roomId, bool isPlaying, qint64 position)
{
    QJsonObject json;
    json["type"] = "playback_state";
    json["userId"] = m_userId;
    json["roomId"] = roomId;
    json["isPlaying"] = isPlaying;
    json["position"] = position;
    
    sendJson(json);
}

void WebSocketClient::onConnected()
{
    m_isConnected = true;
    
    QJsonObject authJson;
    authJson["type"] = "authenticate";
    authJson["userId"] = m_userId;
    
    sendJson(authJson);
    
    emit connected();
}

void WebSocketClient::onDisconnected()
{
    m_isConnected = false;
    emit disconnected();
}

void WebSocketClient::onTextMessageReceived(const QString& message)
{
    QJsonDocument doc = QJsonDocument::fromJson(message.toUtf8());
    
    if (!doc.isObject()) {
        return;
    }
    
    QJsonObject json = doc.object();
    QString type = json["type"].toString();
    
    if (type == "playback_state") {
        int roomId = json["roomId"].toInt();
        bool isPlaying = json["isPlaying"].toBool();
        qint64 position = json["position"].toVariant().toLongLong();
        
        emit roomStateUpdated(roomId, isPlaying, position);
    }
    else if (type == "user_joined") {
        int roomId = json["roomId"].toInt();
        int userId = json["userId"].toInt();
        QString username = json["username"].toString();
        
        emit userJoined(roomId, userId, username);
    }
    else if (type == "user_left") {
        int roomId = json["roomId"].toInt();
        int userId = json["userId"].toInt();
        
        emit userLeft(roomId, userId);
    }
    
    emit messageReceived(json);
}

void WebSocketClient::onError(QAbstractSocket::SocketError error)
{
    qDebug() << "WebSocket error:" << error << m_webSocket->errorString();
}

void WebSocketClient::sendJson(const QJsonObject& json)
{
    if (!m_isConnected) {
        return;
    }
    
    QJsonDocument doc(json);
    m_webSocket->sendTextMessage(doc.toJson(QJsonDocument::Compact));
}


=== kursach/src/network/FriendManager.h ===
#ifndef FRIENDMANAGER_H
#define FRIENDMANAGER_H

#include <QObject>
#include <QVector>
#include "core/models/User.h"

class FriendManager : public QObject
{
    Q_OBJECT

public:
    explicit FriendManager(int userId, QObject *parent = nullptr);
    
    bool sendFriendRequest(int targetUserId);
    bool acceptFriendRequest(int requesterId);
    bool rejectFriendRequest(int requesterId);
    bool removeFriend(int friendId);
    QVector<User> getFriends();
    QVector<User> getPendingRequests();
    QVector<User> searchUsers(const QString& query);

signals:
    void friendRequestReceived(const User& user);
    void friendAdded(const User& user);
    void friendRemoved(int userId);
    void friendStatusChanged(int userId, UserStatus status);

private:
    int m_currentUserId;
};

#endif


=== kursach/src/network/ChatManager.cpp ===
#include "ChatManager.h"
#include "database/DatabaseManager.h"
#include <QSqlQuery>
#include <QDebug>

ChatManager::ChatManager(int userId, QObject *parent)
    : QObject(parent), m_currentUserId(userId)
{
}

bool ChatManager::sendMessage(int receiverId, const QString& content, MessageType type)
{
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "INSERT INTO messages (sender_id, receiver_id, content, type, timestamp, is_read) "
        "VALUES (?, ?, ?, ?, NOW(), false) RETURNING id"
    );
    query.addBindValue(m_currentUserId);
    query.addBindValue(receiverId);
    query.addBindValue(content);
    query.addBindValue(static_cast<int>(type));
    
    if (query.exec() && query.next()) {
        int messageId = query.value(0).toInt();
        emit messageSent(messageId);
        return true;
    }
    
    return false;
}

bool ChatManager::shareTrack(int receiverId, int trackId)
{
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "INSERT INTO messages (sender_id, receiver_id, type, shared_track_id, timestamp, is_read) "
        "VALUES (?, ?, ?, ?, NOW(), false)"
    );
    query.addBindValue(m_currentUserId);
    query.addBindValue(receiverId);
    query.addBindValue(static_cast<int>(MessageType::TrackShare));
    query.addBindValue(trackId);
    
    return query.exec();
}

QVector<Message> ChatManager::getMessages(int otherUserId, int limit)
{
    QVector<Message> messages;
    
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "SELECT m.id, m.sender_id, m.receiver_id, u.username, u.avatar_path, "
        "m.content, m.type, m.timestamp, m.is_read, m.shared_track_id, "
        "t.title, t.artist "
        "FROM messages m "
        "INNER JOIN users u ON u.id = m.sender_id "
        "LEFT JOIN tracks t ON t.id = m.shared_track_id "
        "WHERE (m.sender_id = ? AND m.receiver_id = ?) "
        "OR (m.sender_id = ? AND m.receiver_id = ?) "
        "ORDER BY m.timestamp DESC LIMIT ?"
    );
    query.addBindValue(m_currentUserId);
    query.addBindValue(otherUserId);
    query.addBindValue(otherUserId);
    query.addBindValue(m_currentUserId);
    query.addBindValue(limit);
    
    if (query.exec()) {
        while (query.next()) {
            Message msg;
            msg.id = query.value(0).toInt();
            msg.senderId = query.value(1).toInt();
            msg.receiverId = query.value(2).toInt();
            msg.senderUsername = query.value(3).toString();
            msg.senderAvatarPath = query.value(4).toString();
            msg.content = query.value(5).toString();
            msg.type = static_cast<MessageType>(query.value(6).toInt());
            msg.timestamp = query.value(7).toDateTime();
            msg.isRead = query.value(8).toBool();
            msg.sharedTrackId = query.value(9).toInt();
            msg.trackTitle = query.value(10).toString();
            msg.trackArtist = query.value(11).toString();
            
            messages.append(msg);
        }
    }
    
    return messages;
}

QVector<Message> ChatManager::getUnreadMessages()
{
    QVector<Message> messages;
    
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "SELECT m.id, m.sender_id, m.receiver_id, u.username, u.avatar_path, "
        "m.content, m.type, m.timestamp, m.shared_track_id, t.title, t.artist "
        "FROM messages m "
        "INNER JOIN users u ON u.id = m.sender_id "
        "LEFT JOIN tracks t ON t.id = m.shared_track_id "
        "WHERE m.receiver_id = ? AND m.is_read = false "
        "ORDER BY m.timestamp DESC"
    );
    query.addBindValue(m_currentUserId);
    
    if (query.exec()) {
        while (query.next()) {
            Message msg;
            msg.id = query.value(0).toInt();
            msg.senderId = query.value(1).toInt();
            msg.receiverId = query.value(2).toInt();
            msg.senderUsername = query.value(3).toString();
            msg.senderAvatarPath = query.value(4).toString();
            msg.content = query.value(5).toString();
            msg.type = static_cast<MessageType>(query.value(6).toInt());
            msg.timestamp = query.value(7).toDateTime();
            msg.sharedTrackId = query.value(8).toInt();
            msg.trackTitle = query.value(9).toString();
            msg.trackArtist = query.value(10).toString();
            msg.isRead = false;
            
            messages.append(msg);
        }
    }
    
    return messages;
}

bool ChatManager::markAsRead(int messageId)
{
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare("UPDATE messages SET is_read = true WHERE id = ? AND receiver_id = ?");
    query.addBindValue(messageId);
    query.addBindValue(m_currentUserId);
    
    return query.exec();
}

QVector<ChatPreview> ChatManager::getChatList()
{
    QVector<ChatPreview> chats;
    
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "WITH last_messages AS ( "
        "    SELECT DISTINCT ON (LEAST(sender_id, receiver_id), GREATEST(sender_id, receiver_id)) "
        "           CASE WHEN sender_id = ? THEN receiver_id ELSE sender_id END as other_user_id, "
        "           content, timestamp, is_read "
        "    FROM messages "
        "    WHERE sender_id = ? OR receiver_id = ? "
        "    ORDER BY LEAST(sender_id, receiver_id), GREATEST(sender_id, receiver_id), timestamp DESC "
        ") "
        "SELECT u.id, u.username, u.avatar_path, lm.content, lm.timestamp, "
        "       COUNT(m.id) FILTER (WHERE m.receiver_id = ? AND m.is_read = false) as unread, "
        "       u.status "
        "FROM last_messages lm "
        "INNER JOIN users u ON u.id = lm.other_user_id "
        "LEFT JOIN messages m ON (m.sender_id = u.id AND m.receiver_id = ?) OR (m.receiver_id = u.id AND m.sender_id = ?) "
        "GROUP BY u.id, u.username, u.avatar_path, lm.content, lm.timestamp, u.status "
        "ORDER BY lm.timestamp DESC"
    );
    query.addBindValue(m_currentUserId);
    query.addBindValue(m_currentUserId);
    query.addBindValue(m_currentUserId);
    query.addBindValue(m_currentUserId);
    query.addBindValue(m_currentUserId);
    query.addBindValue(m_currentUserId);
    
    if (query.exec()) {
        while (query.next()) {
            ChatPreview chat;
            chat.userId = query.value(0).toInt();
            chat.username = query.value(1).toString();
            chat.avatarPath = query.value(2).toString();
            chat.lastMessage = query.value(3).toString();
            chat.lastMessageTime = query.value(4).toDateTime();
            chat.unreadCount = query.value(5).toInt();
            chat.isOnline = query.value(6).toInt() == 0;
            
            chats.append(chat);
        }
    }
    
    return chats;
}

int ChatManager::getUnreadCount()
{
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare("SELECT COUNT(*) FROM messages WHERE receiver_id = ? AND is_read = false");
    query.addBindValue(m_currentUserId);
    
    if (query.exec() && query.next()) {
        return query.value(0).toInt();
    }
    
    return 0;
}


=== kursach/src/network/RoomManager.cpp ===
#include "RoomManager.h"
#include "database/DatabaseManager.h"
#include <QSqlQuery>
#include <QSqlError>
#include <QDebug>

RoomManager::RoomManager(int userId, QObject *parent)
    : QObject(parent), m_userId(userId)
{
}

int RoomManager::createRoom(const QString& name, const QString& description, 
                           const QString& genre, int maxMembers, bool isPrivate)
{
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "INSERT INTO rooms (name, description, genre, host_id, max_members, is_private, created_at) "
        "VALUES (?, ?, ?, ?, ?, ?, NOW()) RETURNING id"
    );
    query.addBindValue(name);
    query.addBindValue(description);
    query.addBindValue(genre);
    query.addBindValue(m_userId);
    query.addBindValue(maxMembers);
    query.addBindValue(isPrivate);
    
    if (query.exec() && query.next()) {
        int roomId = query.value(0).toInt();
        
        QSqlQuery memberQuery(DatabaseManager::instance().database());
        memberQuery.prepare(
            "INSERT INTO room_members (room_id, user_id, is_host, joined_at) "
            "VALUES (?, ?, true, NOW())"
        );
        memberQuery.addBindValue(roomId);
        memberQuery.addBindValue(m_userId);
        memberQuery.exec();
        
        emit roomCreated(roomId);
        return roomId;
    }
    
    return -1;
}

bool RoomManager::deleteRoom(int roomId)
{
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare("DELETE FROM rooms WHERE id = ? AND host_id = ?");
    query.addBindValue(roomId);
    query.addBindValue(m_userId);
    
    if (query.exec()) {
        emit roomDeleted(roomId);
        return true;
    }
    
    return false;
}

bool RoomManager::joinRoom(int roomId)
{
    QSqlQuery checkQuery(DatabaseManager::instance().database());
    checkQuery.prepare(
        "SELECT COUNT(*) FROM room_members WHERE room_id = ?"
    );
    checkQuery.addBindValue(roomId);
    
    if (!checkQuery.exec() || !checkQuery.next()) {
        return false;
    }
    
    int currentMembers = checkQuery.value(0).toInt();
    
    QSqlQuery roomQuery(DatabaseManager::instance().database());
    roomQuery.prepare("SELECT max_members FROM rooms WHERE id = ?");
    roomQuery.addBindValue(roomId);
    
    if (!roomQuery.exec() || !roomQuery.next()) {
        return false;
    }
    
    int maxMembers = roomQuery.value(0).toInt();
    
    if (currentMembers >= maxMembers) {
        return false;
    }
    
    QSqlQuery insertQuery(DatabaseManager::instance().database());
    insertQuery.prepare(
        "INSERT INTO room_members (room_id, user_id, is_host, joined_at) "
        "VALUES (?, ?, false, NOW()) ON CONFLICT (room_id, user_id) DO NOTHING"
    );
    insertQuery.addBindValue(roomId);
    insertQuery.addBindValue(m_userId);
    
    if (insertQuery.exec()) {
        emit roomJoined(roomId);
        return true;
    }
    
    return false;
}

bool RoomManager::leaveRoom(int roomId)
{
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare("DELETE FROM room_members WHERE room_id = ? AND user_id = ?");
    query.addBindValue(roomId);
    query.addBindValue(m_userId);
    
    if (query.exec()) {
        emit roomLeft(roomId);
        return true;
    }
    
    return false;
}

QVector<Room> RoomManager::getPublicRooms()
{
    QVector<Room> rooms;
    
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "SELECT r.id, r.name, r.description, r.genre, r.host_id, "
        "r.current_track_id, r.current_position, r.is_playing, r.max_members, "
        "r.created_at, t.title, t.artist, "
        "(SELECT COUNT(*) FROM room_members WHERE room_id = r.id) as member_count "
        "FROM rooms r "
        "LEFT JOIN tracks t ON t.id = r.current_track_id "
        "WHERE r.is_private = false "
        "ORDER BY r.created_at DESC"
    );
    
    if (query.exec()) {
        while (query.next()) {
            Room room;
            room.id = query.value(0).toInt();
            room.name = query.value(1).toString();
            room.description = query.value(2).toString();
            room.genre = query.value(3).toString();
            room.hostId = query.value(4).toInt();
            room.currentTrackId = query.value(5).toInt();
            room.currentPosition = query.value(6).toLongLong();
            room.isPlaying = query.value(7).toBool();
            room.maxMembers = query.value(8).toInt();
            room.createdAt = query.value(9).toDateTime();
            room.currentTrackTitle = query.value(10).toString();
            room.currentTrackArtist = query.value(11).toString();
            
            int memberCount = query.value(12).toInt();
            room.members.resize(memberCount);
            
            rooms.append(room);
        }
    }
    
    return rooms;
}

Room RoomManager::getRoomDetails(int roomId)
{
    Room room;
    room.id = -1;
    
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "SELECT id, name, description, genre, host_id, current_track_id, "
        "current_position, is_playing, max_members, created_at "
        "FROM rooms WHERE id = ?"
    );
    query.addBindValue(roomId);
    
    if (query.exec() && query.next()) {
        room.id = query.value(0).toInt();
        room.name = query.value(1).toString();
        room.description = query.value(2).toString();
        room.genre = query.value(3).toString();
        room.hostId = query.value(4).toInt();
        room.currentTrackId = query.value(5).toInt();
        room.currentPosition = query.value(6).toLongLong();
        room.isPlaying = query.value(7).toBool();
        room.maxMembers = query.value(8).toInt();
        room.createdAt = query.value(9).toDateTime();
    }
    
    return room;
}

QVector<RoomMember> RoomManager::getRoomMembers(int roomId)
{
    QVector<RoomMember> members;
    
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "SELECT u.id, u.username, u.avatar_path, rm.is_host, rm.joined_at "
        "FROM room_members rm "
        "INNER JOIN users u ON u.id = rm.user_id "
        "WHERE rm.room_id = ? "
        "ORDER BY rm.is_host DESC, rm.joined_at"
    );
    query.addBindValue(roomId);
    
    if (query.exec()) {
        while (query.next()) {
            RoomMember member;
            member.userId = query.value(0).toInt();
            member.username = query.value(1).toString();
            member.avatarPath = query.value(2).toString();
            member.isHost = query.value(3).toBool();
            member.joinedAt = query.value(4).toDateTime();
            
            members.append(member);
        }
    }
    
    return members;
}

bool RoomManager::updateRoomTrack(int roomId, int trackId)
{
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "UPDATE rooms SET current_track_id = ?, current_position = 0 "
        "WHERE id = ? AND host_id = ?"
    );
    query.addBindValue(trackId);
    query.addBindValue(roomId);
    query.addBindValue(m_userId);
    
    if (query.exec()) {
        emit roomUpdated(roomId);
        return true;
    }
    
    return false;
}

bool RoomManager::updatePlaybackState(int roomId, bool isPlaying, qint64 position)
{
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "UPDATE rooms SET is_playing = ?, current_position = ? "
        "WHERE id = ? AND host_id = ?"
    );
    query.addBindValue(isPlaying);
    query.addBindValue(position);
    query.addBindValue(roomId);
    query.addBindValue(m_userId);
    
    return query.exec();
}


=== kursach/src/network/RadioBrowserAPI.cpp ===
#include "RadioBrowserAPI.h"
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonArray>
#include <QNetworkRequest>
#include <QUrl>
#include <QUrlQuery>
#include <QDebug>

RadioBrowserAPI::RadioBrowserAPI(QObject *parent)
    : QObject(parent)
{
}

void RadioBrowserAPI::searchStations(const QString &query, int limit)
{
    QUrl url("https://de1.api.radio-browser.info/json/stations/search");
    QUrlQuery q;
    q.addQueryItem("name", query);
    q.addQueryItem("limit", QString::number(limit));
    q.addQueryItem("order", "votes");
    q.addQueryItem("reverse", "true");
    url.setQuery(q);

    qDebug() << "RadioBrowserAPI::searchStations URL:" << url.toString();
    QNetworkReply *reply = mnetwork.get(QNetworkRequest(url));
    connect(reply, &QNetworkReply::finished, this, &RadioBrowserAPI::onSearchFinished);
}

void RadioBrowserAPI::getTopStations(int limit)
{
    QUrl url("https://de1.api.radio-browser.info/json/stations/topclick");
    QUrlQuery q;
    q.addQueryItem("limit", QString::number(limit));
    url.setQuery(q);

    qDebug() << "RadioBrowserAPI::getTopStations URL:" << url.toString();
    QNetworkReply *reply = mnetwork.get(QNetworkRequest(url));
    connect(reply, &QNetworkReply::finished, this, &RadioBrowserAPI::onSearchFinished);
}

void RadioBrowserAPI::getStationsByGenre(const QString &genre, int limit)
{
    QString genreLower = genre.toLower();
    QUrl url("https://de1.api.radio-browser.info/json/stations/search");
    QUrlQuery q;
    q.addQueryItem("tag", genreLower);
    q.addQueryItem("limit", QString::number(limit));
    q.addQueryItem("order", "votes");
    q.addQueryItem("reverse", "true");
    url.setQuery(q);

    qDebug() << "RadioBrowserAPI::getStationsByGenre URL:" << url.toString();
    QNetworkReply *reply = mnetwork.get(QNetworkRequest(url));
    connect(reply, &QNetworkReply::finished, this, &RadioBrowserAPI::onSearchFinished);
}

void RadioBrowserAPI::onSearchFinished()
{
    QNetworkReply *reply = qobject_cast<QNetworkReply*>(sender());
    if (!reply) return;

    if (reply->error() != QNetworkReply::NoError) {
        qDebug() << "RadioBrowserAPI::onSearchFinished error:" << reply->errorString();
        emit errorOccurred(reply->errorString());
        reply->deleteLater();
        return;
    }

    QByteArray data = reply->readAll();
    reply->deleteLater();

    QJsonDocument doc = QJsonDocument::fromJson(data);
    QJsonArray arr = doc.array();
    QVariantList stations;

    qDebug() << "RadioBrowserAPI::onSearchFinished - Stations count:" << arr.size();

    for (const QJsonValue &v : arr) {
        TrackData station = parseStation(v.toObject());
        if (!station.title.isEmpty() && !station.streamUrl.isEmpty()) {
            QVariantMap m;
            m["title"] = station.title;
            m["artist"] = station.artist;
            m["streamUrl"] = station.streamUrl;
            m["genre"] = station.album;
            m["bitrate"] = station.bitrate;
            m["favicon"] = station.cover;
            m["id"] = station.id;
            stations.append(m);
        }
    }

    qDebug() << "RadioBrowserAPI::onSearchFinished - Valid stations:" << stations.count();
    emit stationsReady(stations);
}

TrackData RadioBrowserAPI::parseStation(const QJsonObject &obj)
{
    TrackData station;
    station.title = obj.value("name").toString();
    station.artist = obj.value("country").toString();
    station.streamUrl = obj.value("url").toString();
    station.album = obj.value("tags").toString();
    station.bitrate = obj.value("bitrate").toInt();
    station.source = "radiobrowser";
    station.isFromCloud = true;
    station.id = qHash(station.streamUrl);

    QString favicon = obj.value("favicon").toString();
    if (!favicon.isEmpty()) {
        station.cover = favicon;
    }

    return station;
}

=== kursach/src/network/FriendManager.cpp ===
#include "FriendManager.h"
#include "database/DatabaseManager.h"
#include <QSqlQuery>
#include <QSqlError>
#include <QDebug>

FriendManager::FriendManager(int userId, QObject *parent)
    : QObject(parent), m_currentUserId(userId)
{
}

static QString esc(QString s) { return s.replace("'", "''"); }

bool FriendManager::sendFriendRequest(int targetUserId)
{
    QSqlQuery q(DatabaseManager::instance().database());
    QString sql = QString(
        "INSERT INTO friend_requests (sender_id, receiver_id, status, created_at) "
        "VALUES (%1, %2, 'pending', NOW()) "
        "ON CONFLICT (sender_id, receiver_id) DO NOTHING"
    ).arg(m_currentUserId).arg(targetUserId);

    if (!q.exec(sql)) { qDebug() << q.lastError().text() << sql; return false; }
    return true;
}

bool FriendManager::acceptFriendRequest(int requesterId)
{
    QSqlDatabase db = DatabaseManager::instance().database();
    if (!db.transaction()) return false;

    QSqlQuery q(db);
    QString sql1 = QString(
        "UPDATE friend_requests SET status='accepted' "
        "WHERE sender_id=%1 AND receiver_id=%2 AND status='pending'"
    ).arg(requesterId).arg(m_currentUserId);

    if (!q.exec(sql1)) { qDebug() << q.lastError().text() << sql1; db.rollback(); return false; }

    QString sql2 = QString(
        "INSERT INTO friendships (user_id, friend_id, created_at) "
        "VALUES (%1,%2,NOW()),(%2,%1,NOW())"
    ).arg(m_currentUserId).arg(requesterId);

    if (!q.exec(sql2)) { qDebug() << q.lastError().text() << sql2; db.rollback(); return false; }

    return db.commit();
}

bool FriendManager::rejectFriendRequest(int requesterId)
{
    QSqlQuery q(DatabaseManager::instance().database());
    QString sql = QString(
        "UPDATE friend_requests SET status='rejected' "
        "WHERE sender_id=%1 AND receiver_id=%2"
    ).arg(requesterId).arg(m_currentUserId);

    if (!q.exec(sql)) { qDebug() << q.lastError().text() << sql; return false; }
    return true;
}

bool FriendManager::removeFriend(int friendId)
{
    QSqlDatabase db = DatabaseManager::instance().database();
    if (!db.transaction()) return false;

    QSqlQuery q(db);
    QString sql = QString(
        "DELETE FROM friendships "
        "WHERE (user_id=%1 AND friend_id=%2) OR (user_id=%2 AND friend_id=%1)"
    ).arg(m_currentUserId).arg(friendId);

    if (!q.exec(sql)) { qDebug() << q.lastError().text() << sql; db.rollback(); return false; }
    if (!db.commit()) return false;

    emit friendRemoved(friendId);
    return true;
}

QVector<User> FriendManager::getFriends()
{
    QVector<User> friends;
    QSqlQuery q(DatabaseManager::instance().database());

    QString sql = QString(
        "SELECT u.id, u.username, u.avatar_path "
        "FROM users u "
        "INNER JOIN friendships f ON f.friend_id=u.id "
        "WHERE f.user_id=%1 "
        "ORDER BY u.username"
    ).arg(m_currentUserId);

    if (!q.exec(sql)) { qDebug() << "getFriends:" << q.lastError().text() << sql; return friends; }

    while (q.next()) {
        User u;
        u.id = q.value(0).toInt();
        u.username = q.value(1).toString();
        u.avatarPath = q.value(2).toString();
        u.isFriend = true;
        friends.push_back(u);
    }
    return friends;
}

QVector<User> FriendManager::getPendingRequests()
{
    QVector<User> req;
    QSqlQuery q(DatabaseManager::instance().database());

    QString sql = QString(
        "SELECT u.id, u.username, u.avatar_path "
        "FROM users u "
        "INNER JOIN friend_requests fr ON fr.sender_id=u.id "
        "WHERE fr.receiver_id=%1 AND fr.status='pending' "
        "ORDER BY fr.created_at DESC"
    ).arg(m_currentUserId);

    if (!q.exec(sql)) { qDebug() << "getPendingRequests:" << q.lastError().text() << sql; return req; }

    while (q.next()) {
        User u;
        u.id = q.value(0).toInt();
        u.username = q.value(1).toString();
        u.avatarPath = q.value(2).toString();
        u.friendRequestReceived = true;
        req.push_back(u);
    }
    return req;
}

QVector<User> FriendManager::searchUsers(const QString& queryText)
{
    QVector<User> users;
    QSqlQuery q(DatabaseManager::instance().database());

    QString pat = "%" + esc(queryText.trimmed().toLower()) + "%";
    QString sql = QString(
        "SELECT id, username, avatar_path "
        "FROM users "
        "WHERE LOWER(username) LIKE '%1' AND id<>%2 "
        "ORDER BY username "
        "LIMIT 20"
    ).arg(pat).arg(m_currentUserId);

    qDebug() << "SQL(search):" << sql;

    if (!q.exec(sql)) { qDebug() << "searchUsers:" << q.lastError().text(); return users; }

    while (q.next()) {
        User u;
        u.id = q.value(0).toInt();
        u.username = q.value(1).toString();
        u.avatarPath = q.value(2).toString();
        users.push_back(u);
    }
    return users;
}


=== kursach/src/network/WebSocketClient.h ===
#ifndef WEBSOCKETCLIENT_H
#define WEBSOCKETCLIENT_H

#include <QObject>
#include <QWebSocket>
#include <QJsonDocument>
#include <QJsonObject>

class WebSocketClient : public QObject
{
    Q_OBJECT

public:
    explicit WebSocketClient(int userId, QObject *parent = nullptr);
    ~WebSocketClient();
    
    void connectToServer(const QString& url);
    void disconnect();
    
    void joinRoom(int roomId);
    void leaveRoom(int roomId);
    void sendMessage(int roomId, const QString& message);
    void updatePlaybackState(int roomId, bool isPlaying, qint64 position);

signals:
    void connected();
    void disconnected();
    void messageReceived(const QJsonObject& message);
    void roomStateUpdated(int roomId, bool isPlaying, qint64 position);
    void userJoined(int roomId, int userId, const QString& username);
    void userLeft(int roomId, int userId);

private slots:
    void onConnected();
    void onDisconnected();
    void onTextMessageReceived(const QString& message);
    void onError(QAbstractSocket::SocketError error);

private:
    void sendJson(const QJsonObject& json);
    
    QWebSocket* m_webSocket;
    int m_userId;
    bool m_isConnected;
};

#endif


=== kursach/src/network/RoomManager.h ===
#ifndef ROOMMANAGER_H
#define ROOMMANAGER_H

#include <QObject>
#include <QVector>
#include "core/models/Room.h"

class RoomManager : public QObject
{
    Q_OBJECT

public:
    explicit RoomManager(int userId, QObject *parent = nullptr);
    
    int createRoom(const QString& name, const QString& description, 
                   const QString& genre, int maxMembers, bool isPrivate);
    bool deleteRoom(int roomId);
    bool joinRoom(int roomId);
    bool leaveRoom(int roomId);
    
    QVector<Room> getPublicRooms();
    Room getRoomDetails(int roomId);
    QVector<RoomMember> getRoomMembers(int roomId);
    
    bool updateRoomTrack(int roomId, int trackId);
    bool updatePlaybackState(int roomId, bool isPlaying, qint64 position);

signals:
    void roomCreated(int roomId);
    void roomDeleted(int roomId);
    void roomJoined(int roomId);
    void roomLeft(int roomId);
    void roomUpdated(int roomId);
    void memberJoined(int roomId, const RoomMember& member);
    void memberLeft(int roomId, int userId);

private:
    int m_userId;
};

#endif


=== kursach/src/network/ChatManager.h ===
#ifndef CHATMANAGER_H
#define CHATMANAGER_H

#include <QObject>
#include <QVector>
#include "core/models/Message.h"

class ChatManager : public QObject
{
    Q_OBJECT

public:
    explicit ChatManager(int userId, QObject *parent = nullptr);
    
    bool sendMessage(int receiverId, const QString& content, MessageType type = MessageType::Text);
    bool shareTrack(int receiverId, int trackId);
    QVector<Message> getMessages(int otherUserId, int limit = 50);
    QVector<Message> getUnreadMessages();
    bool markAsRead(int messageId);
    QVector<ChatPreview> getChatList();
    int getUnreadCount();

signals:
    void messageReceived(const Message& message);
    void messageSent(int messageId);

private:
    int m_currentUserId;
};

#endif


=== kursach/src/main.cpp ===
#include <QApplication>
#include <QFile>
#include "gui/AuthWindow/AuthWindow.h"
#include "database/DatabaseManager.h"
#include "utils/Config.h"
#include <QDebug>

void loadStyleSheet(QApplication& app)
{
    QString styleSheet = R"(
        * {
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        
        QMainWindow {
            background: qlineargradient(x1:0, y1:0, x2:1, y2:1,
                stop:0 #0F0F14, stop:1 #1A1A21);
        }
        
        QScrollBar:vertical {
            background: rgba(255, 255, 255, 0.05);
            width: 10px;
            border-radius: 5px;
            margin: 0px;
        }
        
        QScrollBar::handle:vertical {
            background: rgba(138, 43, 226, 0.5);
            border-radius: 5px;
            min-height: 30px;
        }
        
        QScrollBar::handle:vertical:hover {
            background: rgba(138, 43, 226, 0.7);
        }
        
        QScrollBar::add-line:vertical,
        QScrollBar::sub-line:vertical {
            height: 0px;
        }
        
        QToolTip {
            background: #1A1A21;
            color: white;
            border: 1px solid rgba(138, 43, 226, 0.5);
            border-radius: 4px;
            padding: 5px;
        }
    )";
    
    app.setStyleSheet(styleSheet);
}

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    
    app.setApplicationName("Chorus");
    app.setApplicationVersion("1.0.0");
    app.setOrganizationName("Chorus");
    
    loadStyleSheet(app);
    
    if (!DatabaseManager::instance().initialize()) {
        qCritical() << "Failed to initialize database";
        return 1;
    }
    
    AuthWindow authWindow;
    authWindow.show();
    
    return app.exec();
}


