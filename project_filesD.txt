=== DanilKurs/src/utils/ImageUtils.cpp ===
#include "ImageUtils.h"
#include <QPainter>
#include <QPainterPath>
#include <QGraphicsBlurEffect>
#include <QGraphicsScene>
#include <QGraphicsPixmapItem>

QPixmap ImageUtils::loadImage(const QString& path, int width, int height)
{
    QPixmap pixmap(path);
    
    if (pixmap.isNull()) {
        return QPixmap();
    }
    
    if (width > 0 && height > 0) {
        return pixmap.scaled(width, height, Qt::KeepAspectRatio, Qt::SmoothTransformation);
    } else if (width > 0) {
        return pixmap.scaledToWidth(width, Qt::SmoothTransformation);
    } else if (height > 0) {
        return pixmap.scaledToHeight(height, Qt::SmoothTransformation);
    }
    
    return pixmap;
}

QPixmap ImageUtils::createCircularImage(const QPixmap& source)
{
    int size = qMin(source.width(), source.height());
    QPixmap result(size, size);
    result.fill(Qt::transparent);
    
    QPainter painter(&result);
    painter.setRenderHint(QPainter::Antialiasing);
    
    QPainterPath path;
    path.addEllipse(0, 0, size, size);
    painter.setClipPath(path);
    
    QPixmap scaled = source.scaled(size, size, Qt::KeepAspectRatioByExpanding, Qt::SmoothTransformation);
    painter.drawPixmap(0, 0, scaled);
    
    return result;
}

QPixmap ImageUtils::createRoundedImage(const QPixmap& source, int radius)
{
    QPixmap result(source.size());
    result.fill(Qt::transparent);
    
    QPainter painter(&result);
    painter.setRenderHint(QPainter::Antialiasing);
    
    QPainterPath path;
    path.addRoundedRect(0, 0, source.width(), source.height(), radius, radius);
    painter.setClipPath(path);
    
    painter.drawPixmap(0, 0, source);
    
    return result;
}

QPixmap ImageUtils::applyBlur(const QPixmap& source, int radius)
{
    QGraphicsScene scene;
    QGraphicsPixmapItem item;
    item.setPixmap(source);
    
    QGraphicsBlurEffect* blur = new QGraphicsBlurEffect;
    blur->setBlurRadius(radius);
    item.setGraphicsEffect(blur);
    
    scene.addItem(&item);
    
    QPixmap result(source.size());
    result.fill(Qt::transparent);
    
    QPainter painter(&result);
    scene.render(&painter);
    
    return result;
}

QPixmap ImageUtils::createThumbnail(const QPixmap& source, int size)
{
    return source.scaled(size, size, Qt::KeepAspectRatio, Qt::SmoothTransformation);
}

bool ImageUtils::saveImage(const QPixmap& pixmap, const QString& path, const QString& format)
{
    return pixmap.save(path, format.toUtf8().constData());
}

QPixmap ImageUtils::resizeImage(const QPixmap& source, int width, int height, Qt::AspectRatioMode mode)
{
    return source.scaled(width, height, mode, Qt::SmoothTransformation);
}

QPixmap ImageUtils::createGradientBackground(int width, int height, const QColor& color1, const QColor& color2)
{
    QPixmap pixmap(width, height);
    
    QPainter painter(&pixmap);
    QLinearGradient gradient(0, 0, 0, height);
    gradient.setColorAt(0, color1);
    gradient.setColorAt(1, color2);
    
    painter.fillRect(0, 0, width, height, gradient);
    
    return pixmap;
}

QPixmap ImageUtils::overlayImages(const QPixmap& background, const QPixmap& foreground, int x, int y)
{
    QPixmap result = background.copy();
    
    QPainter painter(&result);
    painter.drawPixmap(x, y, foreground);
    
    return result;
}

QString ImageUtils::extractDominantColor(const QPixmap& pixmap)
{
    QImage image = pixmap.toImage().scaled(50, 50, Qt::IgnoreAspectRatio, Qt::FastTransformation);
    
    int r = 0, g = 0, b = 0;
    int pixelCount = 0;
    
    for (int y = 0; y < image.height(); ++y) {
        for (int x = 0; x < image.width(); ++x) {
            QRgb pixel = image.pixel(x, y);
            r += qRed(pixel);
            g += qGreen(pixel);
            b += qBlue(pixel);
            pixelCount++;
        }
    }
    
    r /= pixelCount;
    g /= pixelCount;
    b /= pixelCount;
    
    return QString("#%1%2%3")
        .arg(r, 2, 16, QChar('0'))
        .arg(g, 2, 16, QChar('0'))
        .arg(b, 2, 16, QChar('0'));
}

QImage ImageUtils::convertToGrayscale(const QImage& image)
{
    QImage result = image.convertToFormat(QImage::Format_Grayscale8);
    return result;
}


=== DanilKurs/src/utils/ImageUtils.h ===
#ifndef IMAGEUTILS_H
#define IMAGEUTILS_H

#include <QPixmap>
#include <QImage>
#include <QString>

class ImageUtils
{
public:
    static QPixmap loadImage(const QString& path, int width = 0, int height = 0);
    static QPixmap createCircularImage(const QPixmap& source);
    static QPixmap createRoundedImage(const QPixmap& source, int radius);
    static QPixmap applyBlur(const QPixmap& source, int radius);
    static QPixmap createThumbnail(const QPixmap& source, int size);
    
    static bool saveImage(const QPixmap& pixmap, const QString& path, const QString& format = "PNG");
    static QPixmap resizeImage(const QPixmap& source, int width, int height, Qt::AspectRatioMode mode = Qt::KeepAspectRatio);
    
    static QPixmap createGradientBackground(int width, int height, const QColor& color1, const QColor& color2);
    static QPixmap overlayImages(const QPixmap& background, const QPixmap& foreground, int x, int y);
    
    static QString extractDominantColor(const QPixmap& pixmap);
    static QImage convertToGrayscale(const QImage& image);
};

#endif


=== DanilKurs/src/utils/Config.h ===
#ifndef CONFIG_H
#define CONFIG_H

#include <QString>
#include <QSettings>

class Config
{
public:
    static Config& instance();
    
    QString getDatabaseHost() const;
    int getDatabasePort() const;
    QString getDatabaseName() const;
    QString getDatabaseUser() const;
    QString getDatabasePassword() const;
    
    QString getWebSocketUrl() const;
    QString getLastFmApiKey() const;
    
    int getMaxCacheSize() const;
    QString getCachePath() const;
    QString getAvatarsPath() const;
    
    bool getAutoLogin() const;
    void setAutoLogin(bool enabled);
    
    QString getLastUsername() const;
    void setLastUsername(const QString& username);
    
    int getDefaultVolume() const;
    void setDefaultVolume(int volume);

private:
    Config();
    ~Config();
    Config(const Config&) = delete;
    Config& operator=(const Config&) = delete;
    
    QSettings* m_settings;
};

#endif


=== DanilKurs/src/utils/Config.cpp ===
#include "Config.h"
#include <QCoreApplication>
#include <QDir>

Config& Config::instance()
{
    static Config instance;
    return instance;
}

Config::Config()
{
    QString configPath = QDir::homePath() + "/.soundspace";
    QDir().mkpath(configPath);
    
    m_settings = new QSettings(configPath + "/config.ini", QSettings::IniFormat);
}

Config::~Config()
{
    delete m_settings;
}

QString Config::getDatabaseHost() const
{
    return m_settings->value("database/host", "turntable.proxy.rlwy.net").toString();
}

int Config::getDatabasePort() const
{
    return m_settings->value("database/port", 26533).toInt();
}

QString Config::getDatabaseName() const
{
    return m_settings->value("database/name", "railway").toString();
}

QString Config::getDatabaseUser() const
{
    return m_settings->value("database/user", "postgres").toString();
}

QString Config::getDatabasePassword() const
{
    return m_settings->value("database/password", "__REMOVED__").toString();
}

QString Config::getWebSocketUrl() const
{
    return m_settings->value("network/websocket", "ws://localhost:8080").toString();
}

QString Config::getLastFmApiKey() const
{
    return m_settings->value("api/lastfm_key", "5d63cb6ba6780da3f1306e10539e4b01").toString();
}

int Config::getMaxCacheSize() const
{
    return m_settings->value("cache/max_size", 1024).toInt();
}

QString Config::getCachePath() const
{
    QString path = m_settings->value("cache/path", QDir::homePath() + "/.soundspace/cache").toString();
    QDir().mkpath(path);
    return path;
}

QString Config::getAvatarsPath() const
{
    QString path = m_settings->value("avatars/path", QDir::homePath() + "/.soundspace/avatars").toString();
    QDir().mkpath(path);
    return path;
}

bool Config::getAutoLogin() const
{
    return m_settings->value("auth/auto_login", false).toBool();
}

void Config::setAutoLogin(bool enabled)
{
    m_settings->setValue("auth/auto_login", enabled);
    m_settings->sync();
}

QString Config::getLastUsername() const
{
    return m_settings->value("auth/last_username", "").toString();
}

void Config::setLastUsername(const QString& username)
{
    m_settings->setValue("auth/last_username", username);
    m_settings->sync();
}

int Config::getDefaultVolume() const
{
    return m_settings->value("audio/volume", 70).toInt();
}

void Config::setDefaultVolume(int volume)
{
    m_settings->setValue("audio/volume", volume);
    m_settings->sync();
}


=== DanilKurs/src/utils/FileUtils.cpp ===
#include "FileUtils.h"
#include <QFile>
#include <QFileInfo>
#include <QDir>
#include <QDateTime>
#include <QTextStream>
#include <QDirIterator>

bool FileUtils::fileExists(const QString& path)
{
    return QFile::exists(path);
}

qint64 FileUtils::fileSize(const QString& path)
{
    QFileInfo info(path);
    return info.size();
}

QString FileUtils::fileExtension(const QString& path)
{
    QFileInfo info(path);
    return info.suffix();
}

QString FileUtils::fileName(const QString& path)
{
    QFileInfo info(path);
    return info.fileName();
}

QString FileUtils::fileBaseName(const QString& path)
{
    QFileInfo info(path);
    return info.baseName();
}

bool FileUtils::createDirectory(const QString& path)
{
    QDir dir;
    return dir.mkpath(path);
}

bool FileUtils::deleteFile(const QString& path)
{
    return QFile::remove(path);
}

bool FileUtils::copyFile(const QString& source, const QString& destination)
{
    if (fileExists(destination)) {
        QFile::remove(destination);
    }
    return QFile::copy(source, destination);
}

bool FileUtils::moveFile(const QString& source, const QString& destination)
{
    if (copyFile(source, destination)) {
        return deleteFile(source);
    }
    return false;
}

QStringList FileUtils::listFiles(const QString& directory, const QStringList& filters)
{
    QStringList files;
    QDir dir(directory);
    
    if (!dir.exists()) {
        return files;
    }
    
    QFileInfoList fileList;
    if (filters.isEmpty()) {
        fileList = dir.entryInfoList(QDir::Files | QDir::NoDotAndDotDot);
    } else {
        fileList = dir.entryInfoList(filters, QDir::Files | QDir::NoDotAndDotDot);
    }
    
    for (const QFileInfo& info : fileList) {
        files.append(info.absoluteFilePath());
    }
    
    return files;
}

QString FileUtils::readTextFile(const QString& path)
{
    QFile file(path);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        return QString();
    }
    
    QTextStream in(&file);
    QString content = in.readAll();
    file.close();
    
    return content;
}

bool FileUtils::writeTextFile(const QString& path, const QString& content)
{
    QFile file(path);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        return false;
    }
    
    QTextStream out(&file);
    out << content;
    file.close();
    
    return true;
}

QString FileUtils::generateUniqueFileName(const QString& baseName, const QString& extension)
{
    QString timestamp = QString::number(QDateTime::currentMSecsSinceEpoch());
    return QString("%1_%2.%3").arg(baseName, timestamp, extension);
}

QString FileUtils::sanitizeFileName(const QString& name)
{
    QString sanitized = name;
    sanitized.replace(QRegExp("[<>:\"/\\|?*]"), "_");
    return sanitized;
}

qint64 FileUtils::directorySize(const QString& path)
{
    qint64 totalSize = 0;
    QDirIterator it(path, QDir::Files, QDirIterator::Subdirectories);
    
    while (it.hasNext()) {
        it.next();
        totalSize += it.fileInfo().size();
    }
    
    return totalSize;
}

bool FileUtils::cleanDirectory(const QString& path)
{
    QDir dir(path);
    
    if (!dir.exists()) {
        return false;
    }
    
    bool success = true;
    QFileInfoList files = dir.entryInfoList(QDir::Files | QDir::NoDotAndDotDot);
    
    for (const QFileInfo& file : files) {
        if (!QFile::remove(file.absoluteFilePath())) {
            success = false;
        }
    }
    
    return success;
}


=== DanilKurs/src/utils/FileUtils.h ===
#ifndef FILEUTILS_H
#define FILEUTILS_H

#include <QString>
#include <QStringList>

class FileUtils
{
public:
    static bool fileExists(const QString& path);
    static qint64 fileSize(const QString& path);
    static QString fileExtension(const QString& path);
    static QString fileName(const QString& path);
    static QString fileBaseName(const QString& path);
    
    static bool createDirectory(const QString& path);
    static bool deleteFile(const QString& path);
    static bool copyFile(const QString& source, const QString& destination);
    static bool moveFile(const QString& source, const QString& destination);
    
    static QStringList listFiles(const QString& directory, const QStringList& filters = QStringList());
    static QString readTextFile(const QString& path);
    static bool writeTextFile(const QString& path, const QString& content);
    
    static QString generateUniqueFileName(const QString& baseName, const QString& extension);
    static QString sanitizeFileName(const QString& name);
    
    static qint64 directorySize(const QString& path);
    static bool cleanDirectory(const QString& path);
};

#endif


=== DanilKurs/src/core/models/Track.h ===
#ifndef TRACK_H
#define TRACK_H

#include <QString>

struct TrackData {  
    int id;
    QString filePath;
    QString fileHash;
    QString title;
    QString artist;
    QString album;
    int duration;
    int playCount;
    QString addedAt;
    QString genre;
    int year;
    int bitrate;
    int sampleRate;
    int position;
};

#endif


=== DanilKurs/src/core/models/Message.h ===
#ifndef MESSAGE_H
#define MESSAGE_H

#include <QString>
#include <QDateTime>

enum class MessageType {
    Text = 0,
    Image = 1,
    Audio = 2,
    TrackShare = 3
};

struct Message {
    int id;
    int senderId;
    int receiverId;
    QString senderUsername;
    QString senderAvatarPath;
    QString content;
    MessageType type;
    QDateTime timestamp;
    bool isRead;
    int sharedTrackId;
    QString trackTitle;
    QString trackArtist;
};

struct ChatPreview {
    int userId;
    QString username;
    QString avatarPath;
    QString lastMessage;
    QDateTime lastMessageTime;
    int unreadCount;
    bool isOnline;
};

#endif


=== DanilKurs/src/core/models/Room.h ===
#ifndef ROOM_H
#define ROOM_H

#include <QString>
#include <QDateTime>
#include <QVector>

struct RoomMember {
    int userId;
    QString username;
    QString avatarPath;
    bool isHost;
    QDateTime joinedAt;
};

struct Room {
    int id;
    QString name;
    QString description;
    QString genre;
    int hostId;
    int currentTrackId;
    QString currentTrackTitle;
    QString currentTrackArtist;
    qint64 currentPosition;
    bool isPlaying;
    int maxMembers;
    QVector<RoomMember> members;
    QDateTime createdAt;
    bool isPrivate;
    QString password;
};

#endif


=== DanilKurs/src/core/models/User.h ===
#ifndef USER_H
#define USER_H

#include <QString>
#include <QDateTime>
#include <QByteArray>

enum class UserStatus {
    Online = 0,
    Away = 1,
    DoNotDisturb = 2,
    Invisible = 3,
    Offline = 4
};

struct User {
    int id;
    QString username;
    QString email;
    QString avatarPath;
    QByteArray avatarData;
    UserStatus status;
    QDateTime lastSeen;
    QString bio;
    QDateTime createdAt;
    bool isFriend;
    bool friendRequestSent;
    bool friendRequestReceived;
};

#endif


=== DanilKurs/src/core/models/Playlist.h ===
#ifndef PLAYLIST_H
#define PLAYLIST_H

#include <QString>

struct Playlist {
    int id = -1;
    int userId = -1;
    QString name;
    QString createdAt;
};

#endif


=== DanilKurs/src/core/managers/TrackManager.cpp ===
#include "TrackManager.h"
#include "database/DatabaseManager.h"

TrackManager::TrackManager(int userId, QObject *parent)
    : QObject(parent), m_userId(userId)
{
}

QVector<TrackData> TrackManager::getUserTracks()
{
    QList<TrackData> list = DatabaseManager::instance().getUserTracks(m_userId);
    return QVector<TrackData>(list.begin(), list.end());
}

TrackData TrackManager::getTrack(int trackId)
{
    TrackData track;
    track.id = trackId;
    return track;
}

bool TrackManager::deleteTrack(int trackId)
{
    return DatabaseManager::instance().deleteTrack(trackId);
}


=== DanilKurs/src/core/managers/PlaylistManager.cpp ===
#include "PlaylistManager.h"
#include "database/DatabaseManager.h"

PlaylistManager::PlaylistManager(int userId, QObject *parent)
    : QObject(parent), m_userId(userId)
{
}

QVector<Playlist> PlaylistManager::getUserPlaylists()
{
    return QVector<Playlist>();
}

Playlist PlaylistManager::getPlaylist(int playlistId)
{
    Playlist playlist;
    playlist.id = playlistId;
    return playlist;
}

int PlaylistManager::createPlaylist(const QString& name, const QString& description)
{
    Q_UNUSED(description);
    Q_UNUSED(name);
    return -1;
}

QVector<TrackData> PlaylistManager::getPlaylistTracks(int playlistId)
{
    Q_UNUSED(playlistId);
    return QVector<TrackData>();
}

bool PlaylistManager::removeTrackFromPlaylist(int playlistId, int trackId)
{
    Q_UNUSED(playlistId);
    Q_UNUSED(trackId);
    return false;
}


=== DanilKurs/src/core/managers/UserManager.h ===
#ifndef USERMANAGER_H
#define USERMANAGER_H

#include <QObject>
#include "core/models/User.h"

class UserManager : public QObject
{
    Q_OBJECT

public:
    explicit UserManager(QObject *parent = nullptr);
    
    bool updateStatus(int userId, UserStatus status);
    bool updateBio(int userId, const QString& bio);
    bool updateAvatar(int userId, const QString& avatarPath);
    bool updateEmail(int userId, const QString& email);
    
    User getUser(int userId);
    UserStatus getUserStatus(int userId);
    QString getUserAvatar(int userId);

signals:
    void userUpdated(int userId);
    void statusChanged(int userId, UserStatus status);

private:
};

#endif


=== DanilKurs/src/core/managers/PlaylistManager.h ===
#ifndef PLAYLISTMANAGER_H
#define PLAYLISTMANAGER_H

#include <QObject>
#include <QVector>
#include "core/models/Playlist.h"
#include "core/models/Track.h"

class PlaylistManager : public QObject
{
    Q_OBJECT

public:
    explicit PlaylistManager(int userId, QObject *parent = nullptr);
    
    int createPlaylist(const QString& name, const QString& description = QString());
    bool deletePlaylist(int playlistId);
    bool renamePlaylist(int playlistId, const QString& newName);
    bool addTrackToPlaylist(int playlistId, int trackId);
    bool removeTrackFromPlaylist(int playlistId, int trackId);
    bool reorderTracks(int playlistId, const QVector<int>& trackIds);
    
    QVector<Playlist> getUserPlaylists();
    QVector<TrackData> getPlaylistTracks(int playlistId);
    Playlist getPlaylist(int playlistId);

signals:
    void playlistCreated(int playlistId);
    void playlistDeleted(int playlistId);
    void playlistUpdated(int playlistId);
    void trackAdded(int playlistId, int trackId);
    void trackRemoved(int playlistId, int trackId);

private:
    int m_userId;
};

#endif


=== DanilKurs/src/core/managers/TrackManager.h ===
#ifndef TRACKMANAGER_H
#define TRACKMANAGER_H

#include <QObject>
#include <QVector>
#include "core/models/Track.h"

class TrackManager : public QObject
{
    Q_OBJECT

public:
    explicit TrackManager(int userId, QObject *parent = nullptr);
    
    bool addTrack(const TrackData& track);
    bool deleteTrack(int trackId);
    bool updateTrack(int trackId, const TrackData& track);
    bool incrementPlayCount(int trackId);
    
    QVector<TrackData> getUserTracks();
    TrackData getTrack(int trackId);
    QVector<TrackData> searchTracks(const QString& query);
    QVector<TrackData> getRecentTracks(int limit = 20);
    QVector<TrackData> getMostPlayedTracks(int limit = 20);

signals:
    void trackAdded(int trackId);
    void trackDeleted(int trackId);
    void trackUpdated(int trackId);

private:
    int m_userId;
};

#endif


=== DanilKurs/src/core/managers/UserManager.cpp ===
#include "UserManager.h"

UserManager::UserManager(QObject *parent)
    : QObject(parent)
{
}

User UserManager::getUser(int userId)
{
    User user;
    user.id = userId;
    user.username = "User";
    user.status = UserStatus::Offline;
    return user;
}

bool UserManager::updateAvatar(int userId, const QString& avatarPath)
{
    Q_UNUSED(userId);
    Q_UNUSED(avatarPath);
    return true;
}

bool UserManager::updateEmail(int userId, const QString& email)
{
    Q_UNUSED(userId);
    Q_UNUSED(email);
    return true;
}

bool UserManager::updateBio(int userId, const QString& bio)
{
    Q_UNUSED(userId);
    Q_UNUSED(bio);
    return true;
}


=== DanilKurs/src/gui/widgets/Sidebar.h ===
#ifndef SIDEBAR_H
#define SIDEBAR_H

#include <QWidget>
#include <QPushButton>
#include <QVBoxLayout>
#include <QLabel>

class Sidebar : public QWidget
{
    Q_OBJECT

public:
    explicit Sidebar(const QString& username, QWidget *parent = nullptr);
    
    void setActivePage(int index);

signals:
    void pageChanged(int index);
    void logoutRequested();

private:
    void setupUI();
    void createNavButton(const QString& icon, const QString& text, int index);
    
    QString m_username;
    QVBoxLayout* m_navLayout;
    QVector<QPushButton*> m_navButtons;
    int m_currentPage;
};

#endif


=== DanilKurs/src/gui/widgets/UserAvatar.h ===
#ifndef USERAVATAR_H
#define USERAVATAR_H

#include <QWidget>
#include <QPixmap>
#include "core/models/User.h"

class UserAvatar : public QWidget
{
    Q_OBJECT

public:
    explicit UserAvatar(int size = 40, QWidget *parent = nullptr);
    
    void setUser(const User& user);
    void setAvatar(const QString& avatarPath);
    void setStatus(UserStatus status);
    void setInitials(const QString& initials);

protected:
    void paintEvent(QPaintEvent *event) override;

private:
    int m_size;
    QPixmap m_avatar;
    QString m_initials;
    UserStatus m_status;
    bool m_hasAvatar;
};

#endif


=== DanilKurs/src/gui/widgets/Sidebar.cpp ===
#include "Sidebar.h"
#include <QLabel>

Sidebar::Sidebar(const QString& username, QWidget *parent)
    : QWidget(parent)
    , m_username(username)
    , m_currentPage(0)
{
    setupUI();
}

void Sidebar::setupUI()
{
    setFixedWidth(250);
    setStyleSheet(R"(
        QWidget {
            background: rgba(0, 0, 0, 0.4);
            border-right: 1px solid rgba(255, 255, 255, 0.05);
        }
    )");
    
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);
    
    QWidget* headerWidget = new QWidget();
    headerWidget->setFixedHeight(80);
    QVBoxLayout* headerLayout = new QVBoxLayout(headerWidget);
    headerLayout->setContentsMargins(20, 20, 20, 20);
    
    QLabel* logoLabel = new QLabel("SoundSpace");
    logoLabel->setStyleSheet("color: #8A2BE2; font-size: 24px; font-weight: 800;");
    
    QLabel* usernameLabel = new QLabel(m_username);
    usernameLabel->setStyleSheet("color: rgba(255, 255, 255, 0.7); font-size: 13px;");
    
    headerLayout->addWidget(logoLabel);
    headerLayout->addWidget(usernameLabel);
    
    mainLayout->addWidget(headerWidget);
    
    QWidget* navWidget = new QWidget();
    m_navLayout = new QVBoxLayout(navWidget);
    m_navLayout->setContentsMargins(15, 20, 15, 20);
    m_navLayout->setSpacing(8);
    
    createNavButton("üè†", "–ì–ª–∞–≤–Ω–∞—è", 0);
    createNavButton("üéµ", "–ú–æ—è –º—É–∑—ã–∫–∞", 1);
    createNavButton("üîç", "–ü–æ–∏—Å–∫ –º—É–∑—ã–∫–∏", 2);
    createNavButton("üìã", "–ü–ª–µ–π–ª–∏—Å—Ç—ã", 3);
    createNavButton("üë•", "–î—Ä—É–∑—å—è", 4);
    createNavButton("üí¨", "–°–æ–æ–±—â–µ–Ω–∏—è", 5);
    createNavButton("üéß", "–ö–æ–º–Ω–∞—Ç—ã", 6);
    createNavButton("üë§", "–ü—Ä–æ—Ñ–∏–ª—å", 7);
    
    mainLayout->addWidget(navWidget);
    mainLayout->addStretch();
    
    QWidget* footerWidget = new QWidget();
    QVBoxLayout* footerLayout = new QVBoxLayout(footerWidget);
    footerLayout->setContentsMargins(15, 20, 15, 20);
    
    QPushButton* logoutBtn = new QPushButton("üö™ –í—ã—Ö–æ–¥");
    logoutBtn->setStyleSheet(R"(
        QPushButton {
            background: rgba(255, 68, 68, 0.1);
            border: 1px solid rgba(255, 68, 68, 0.3);
            color: #FF4444;
            padding: 12px;
            border-radius: 10px;
            text-align: left;
            font-size: 14px;
            font-weight: 500;
        }
        QPushButton:hover {
            background: rgba(255, 68, 68, 0.2);
        }
    )");
    
    connect(logoutBtn, &QPushButton::clicked, this, &Sidebar::logoutRequested);
    
    footerLayout->addWidget(logoutBtn);
    mainLayout->addWidget(footerWidget);
    
    if (!m_navButtons.isEmpty()) {
        m_navButtons[0]->setChecked(true);
    }
}

void Sidebar::createNavButton(const QString& icon, const QString& text, int index)
{
    QPushButton* btn = new QPushButton(QString("%1  %2").arg(icon, text));
    btn->setCheckable(true);
    btn->setFixedHeight(50);
    btn->setStyleSheet(R"(
        QPushButton {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            text-align: left;
            font-size: 14px;
            font-weight: 500;
        }
        QPushButton:hover {
            background: rgba(255, 255, 255, 0.05);
            color: white;
        }
        QPushButton:checked {
            background: rgba(138, 43, 226, 0.2);
            color: #8A2BE2;
            font-weight: 600;
        }
    )");
    
    connect(btn, &QPushButton::clicked, [this, index]() {
        for (QPushButton* button : m_navButtons) {
            button->setChecked(false);
        }
        m_navButtons[index]->setChecked(true);
        m_currentPage = index;
        emit pageChanged(index);
    });
    
    m_navButtons.append(btn);
    m_navLayout->addWidget(btn);
}

void Sidebar::setActivePage(int index)
{
    if (index >= 0 && index < m_navButtons.size()) {
        for (QPushButton* button : m_navButtons) {
            button->setChecked(false);
        }
        m_navButtons[index]->setChecked(true);
        m_currentPage = index;
    }
}


=== DanilKurs/src/gui/widgets/RoomCard.h ===
#ifndef ROOMCARD_H
#define ROOMCARD_H

#include <QWidget>
#include <QLabel>
#include <QPushButton>
#include "core/models/Room.h"

class RoomCard : public QWidget
{
    Q_OBJECT

public:
    explicit RoomCard(const Room& room, QWidget *parent = nullptr);

signals:
    void joinClicked(int roomId);

private:
    void setupUI(const Room& room);
    
    int m_roomId;
    QLabel* m_nameLabel;
    QLabel* m_genreLabel;
    QLabel* m_trackLabel;
    QLabel* m_membersLabel;
    QPushButton* m_joinButton;
};

#endif


=== DanilKurs/src/gui/widgets/MessageBubble.cpp ===
#include "MessageBubble.h"
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QLabel>
#include <QSizePolicy>

MessageBubble::MessageBubble(const Message& message, bool isOwn, QWidget *parent)
    : QWidget(parent)
{
    setupUI(message, isOwn);
}

void MessageBubble::setupUI(const Message& message, bool isOwn)
{
    auto* mainLayout = new QHBoxLayout(this);
    mainLayout->setContentsMargins(10, 5, 10, 5);
    mainLayout->setSpacing(0);

    if (isOwn) mainLayout->addStretch(1);

    // Bubble container
    auto* bubbleWidget = new QWidget(this);
    bubbleWidget->setObjectName("bubble");
    bubbleWidget->setMaximumWidth(420);
    bubbleWidget->setSizePolicy(QSizePolicy::Maximum, QSizePolicy::Preferred);

    const QString bubbleStyle = isOwn
        ? "#bubble { background:#8A2BE2; border-radius:15px; }"
        : "#bubble { background:rgba(255,255,255,0.10); border-radius:15px; }";
    bubbleWidget->setStyleSheet(bubbleStyle);

    auto* bubbleLayout = new QVBoxLayout(bubbleWidget);
    bubbleLayout->setContentsMargins(14, 10, 14, 8);
    bubbleLayout->setSpacing(6);

    // Sender (only for incoming)
    if (!isOwn) {
        auto* senderLabel = new QLabel(message.senderUsername, bubbleWidget);
        senderLabel->setAutoFillBackground(false);
        senderLabel->setTextFormat(Qt::PlainText);
        // "–±—Ä–æ–Ω—è" –æ—Ç –ª—é–±—ã—Ö –≤–Ω–µ—à–Ω–∏—Ö —Å—Ç–∏–ª–µ–π: –Ω–∏–∫–∞–∫–æ–≥–æ —Ñ–æ–Ω–∞ —É sender
        senderLabel->setStyleSheet(
            "background: transparent;"
            "color:#8A2BE2;"
            "font-size:12px;"
            "font-weight:600;"
        );
        bubbleLayout->addWidget(senderLabel);
    }

    // Content
    auto* contentLabel = new QLabel(message.content, bubbleWidget);
    contentLabel->setAutoFillBackground(false);
    contentLabel->setWordWrap(true);
    contentLabel->setTextFormat(Qt::PlainText);
    contentLabel->setStyleSheet(
        "background: transparent;"
        "color:white;"
        "font-size:14px;"
    );
    bubbleLayout->addWidget(contentLabel);

    // Meta row (time)
    auto* metaRow = new QHBoxLayout();
    metaRow->setContentsMargins(0, 0, 0, 0);
    metaRow->setSpacing(0);

    auto* timeLabel = new QLabel(message.timestamp.toString("hh:mm"), bubbleWidget);
    timeLabel->setAutoFillBackground(false);
    timeLabel->setTextFormat(Qt::PlainText);
    timeLabel->setStyleSheet(
        "background: transparent;"
        "color: rgba(255,255,255,0.55);"
        "font-size:11px;"
    );

    if (isOwn) {
        metaRow->addStretch(1);
        metaRow->addWidget(timeLabel, 0, Qt::AlignRight | Qt::AlignBottom);
    } else {
        metaRow->addWidget(timeLabel, 0, Qt::AlignLeft | Qt::AlignBottom);
        metaRow->addStretch(1);
    }

    bubbleLayout->addLayout(metaRow);

    mainLayout->addWidget(bubbleWidget, 0);

    if (!isOwn) mainLayout->addStretch(1);
}


=== DanilKurs/src/gui/widgets/TrackListItem.h ===
#ifndef TRACKLISTITEM_H
#define TRACKLISTITEM_H

#include <QWidget>
#include <QLabel>
#include <QPushButton>
#include "core/models/Track.h"

class TrackListItem : public QWidget
{
    Q_OBJECT

public:
    explicit TrackListItem(const TrackData& track, bool showAlbum = false, QWidget *parent = nullptr);
    
    int trackId() const { return m_trackId; }
    const TrackData& track() const { return m_track; }

signals:
    void playClicked(int trackId);
    void moreClicked(int trackId, const QPoint& pos);

private:
    void setupUI(bool showAlbum);
    QString formatDuration(int seconds);
    
    int m_trackId;
    TrackData m_track;
    
    QLabel* m_numberLabel;
    QLabel* m_titleLabel;
    QLabel* m_artistLabel;
    QLabel* m_albumLabel;
    QLabel* m_durationLabel;
    QPushButton* m_playButton;
    QPushButton* m_moreButton;
};

#endif


=== DanilKurs/src/gui/widgets/FriendCard.cpp ===
#include "FriendCard.h"

#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QFileInfo>
#include <QDir>
#include <QCoreApplication>
#include <QPainter>
#include <QPainterPath>

static QString resolveAvatarFile(const User& u)
{
    QString p = u.avatarPath.trimmed();
    if (!p.isEmpty()) {
        QFileInfo fi(p);
        if (fi.isAbsolute() && fi.exists()) return fi.absoluteFilePath();

        const QString appRel = QDir(QCoreApplication::applicationDirPath()).filePath(p);
        if (QFileInfo::exists(appRel)) return appRel;

        const QString cwdRel = QDir::current().filePath(p);
        if (QFileInfo::exists(cwdRel)) return cwdRel;
    }

    // Fallback to your saveAvatar() pattern: avatars/user<ID>.png
    const QString f1 = QDir(QCoreApplication::applicationDirPath())
                           .filePath(QString("avatars/user%1.png").arg(u.id));
    if (QFileInfo::exists(f1)) return f1;

    const QString f2 = QDir::current().filePath(QString("avatars/user%1.png").arg(u.id));
    if (QFileInfo::exists(f2)) return f2;

    return QString();
}

static QPixmap makeCircularPixmap(const QPixmap& src, int size)
{
    if (src.isNull()) return QPixmap();

    QPixmap scaled = src.scaled(size, size, Qt::KeepAspectRatioByExpanding, Qt::SmoothTransformation);

    QPixmap out(size, size);
    out.fill(Qt::transparent);

    QPainter p(&out);
    p.setRenderHint(QPainter::Antialiasing, true);
    p.setRenderHint(QPainter::SmoothPixmapTransform, true);

    QPainterPath path;
    path.addEllipse(0, 0, size, size);
    p.setClipPath(path);

    const int x = (size - scaled.width()) / 2;
    const int y = (size - scaled.height()) / 2;
    p.drawPixmap(x, y, scaled);

    return out;
}

FriendCard::FriendCard(const User& user, bool isRequest, bool isSearchResult, QWidget *parent)
    : QWidget(parent)
{
    setupUI(user, isRequest, isSearchResult);
}

void FriendCard::setupUI(const User& user, bool isRequest, bool isSearchResult)
{
    QHBoxLayout* mainLayout = new QHBoxLayout(this);
    mainLayout->setContentsMargins(15, 15, 15, 15);
    mainLayout->setSpacing(15);

    // Avatar
    m_avatarLabel = new QLabel();
    m_avatarLabel->setFixedSize(60, 60);
    m_avatarLabel->setAlignment(Qt::AlignCenter);

    bool avatarSet = false;
    if (!user.avatarData.isEmpty()) {
        QPixmap px;
        if (px.loadFromData(user.avatarData)) {
            m_avatarLabel->setPixmap(makeCircularPixmap(px, 60));
            m_avatarLabel->setStyleSheet("background: transparent;");
            avatarSet = true;
        }
    }

    if (!avatarSet) {
        const QString avatarFile = resolveAvatarFile(user);
        if (!avatarFile.isEmpty()) {
            QPixmap px(avatarFile);
            if (!px.isNull()) {
                m_avatarLabel->setPixmap(makeCircularPixmap(px, 60));
                m_avatarLabel->setStyleSheet("background: transparent;");
                avatarSet = true;
            }
        }
    }

    if (!avatarSet) {
        m_avatarLabel->setText(user.username.left(1).toUpper());
        m_avatarLabel->setStyleSheet(
            "background: #8A2BE2;"
            "color: white;"
            "font-size: 24px;"
            "font-weight: bold;"
            "border-radius: 30px;"
        );
    }

    // Info
    QWidget* infoWidget = new QWidget();
    infoWidget->setStyleSheet("background: transparent;");
    QVBoxLayout* infoLayout = new QVBoxLayout(infoWidget);
    infoLayout->setContentsMargins(0, 0, 0, 0);
    infoLayout->setSpacing(4);

    m_usernameLabel = new QLabel(user.username);
    m_usernameLabel->setStyleSheet("color: white; font-size: 16px; font-weight: 600; background: transparent;");

    m_statusLabel = new QLabel();
    m_statusLabel->setStyleSheet("color: rgba(255,255,255,0.6); font-size: 13px; background: transparent;");
    const QString st = getStatusText(user.status);
    if (!st.isEmpty()) {
        m_statusLabel->setText(st);
        m_statusLabel->setStyleSheet(QString("color: %1; font-size: 13px; background: transparent;")
                                     .arg(getStatusColor(user.status)));
    }

    infoLayout->addWidget(m_usernameLabel);
    infoLayout->addWidget(m_statusLabel);

    mainLayout->addWidget(m_avatarLabel);
    mainLayout->addWidget(infoWidget, 1);

    // Buttons
    if (isRequest) {
        QPushButton* acceptBtn = new QPushButton("–ü—Ä–∏–Ω—è—Ç—å");
        acceptBtn->setStyleSheet(
            "QPushButton { background: #4CAF50; color: white; border: none; border-radius: 8px; padding: 8px 20px; font-weight: 600; }"
            "QPushButton:hover { background: #45a049; }"
        );
        connect(acceptBtn, &QPushButton::clicked, this, &FriendCard::acceptClicked);

        QPushButton* rejectBtn = new QPushButton("–û—Ç–∫–ª–æ–Ω–∏—Ç—å");
        rejectBtn->setStyleSheet(
            "QPushButton { background: #f44336; color: white; border: none; border-radius: 8px; padding: 8px 20px; font-weight: 600; }"
            "QPushButton:hover { background: #da190b; }"
        );
        connect(rejectBtn, &QPushButton::clicked, this, &FriendCard::rejectClicked);

        mainLayout->addWidget(acceptBtn);
        mainLayout->addWidget(rejectBtn);
    } else if (isSearchResult) {
        QPushButton* addBtn = new QPushButton("–î–æ–±–∞–≤–∏—Ç—å");
        addBtn->setStyleSheet(
            "QPushButton { background: #8A2BE2; color: white; border: none; border-radius: 8px; padding: 8px 20px; font-weight: 600; }"
            "QPushButton:hover { background: #9B4BFF; }"
        );
        connect(addBtn, &QPushButton::clicked, this, &FriendCard::addFriendClicked);
        mainLayout->addWidget(addBtn);
    } else {
        QPushButton* messageBtn = new QPushButton("–ù–∞–ø–∏—Å–∞—Ç—å");
        messageBtn->setStyleSheet(
            "QPushButton { background: #8A2BE2; color: white; border: none; border-radius: 8px; padding: 8px 20px; font-weight: 600; }"
            "QPushButton:hover { background: #9B4BFF; }"
        );
        connect(messageBtn, &QPushButton::clicked, this, &FriendCard::messageClicked);

        QPushButton* removeBtn = new QPushButton("–£–¥–∞–ª–∏—Ç—å");
        removeBtn->setStyleSheet(
            "QPushButton { background: rgba(244,67,54,0.2); color: #f44336; border: 1px solid #f44336; border-radius: 8px; padding: 8px 20px; font-weight: 600; }"
            "QPushButton:hover { background: rgba(244,67,54,0.3); }"
        );
        connect(removeBtn, &QPushButton::clicked, this, &FriendCard::removeClicked);

        mainLayout->addWidget(messageBtn);
        mainLayout->addWidget(removeBtn);
    }
}

QString FriendCard::getStatusColor(UserStatus status)
{
    switch (status) {
        case UserStatus::Online: return "#4CAF50";
        case UserStatus::Away: return "#FFC107";
        case UserStatus::DoNotDisturb: return "#F44336";
        case UserStatus::Invisible:
        case UserStatus::Offline: return "#9E9E9E";
        default: return "rgba(255,255,255,0.6)";
    }
}

QString FriendCard::getStatusText(UserStatus status)
{
    switch (status) {
        case UserStatus::Online: return "–û–Ω–ª–∞–π–Ω";
        case UserStatus::Away: return "–ù–µ—Ç –Ω–∞ –º–µ—Å—Ç–µ";
        case UserStatus::DoNotDisturb: return "–ù–µ –±–µ—Å–ø–æ–∫–æ–∏—Ç—å";
        case UserStatus::Invisible: return "–ù–µ–≤–∏–¥–∏–º–∫–∞";
        case UserStatus::Offline: return "–ù–µ –≤ —Å–µ—Ç–∏";
        default: return "";
    }
}


=== DanilKurs/src/gui/widgets/ChatWidget.cpp ===
#include "ChatWidget.h"
#include "MessageBubble.h"
#include "network/ChatManager.h"
#include <QScrollBar>
#include <QMessageBox>
#include <QTimer>

ChatWidget::ChatWidget(int userId, int friendId, const QString& friendName, QWidget *parent)
    : QWidget(parent)
    , m_userId(userId)
    , m_friendId(friendId)
    , m_friendName(friendName)
    , m_chatManager(new ChatManager(userId, this))
{
    setupUI();
    loadMessages();

    QTimer* refreshTimer = new QTimer(this);
    refreshTimer->setInterval(1000);
    connect(refreshTimer, &QTimer::timeout, this, [this]() {
        if (!isVisible()) return;
        loadMessages();
    });
    refreshTimer->start();
}

void ChatWidget::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);
    
    QWidget* headerWidget = new QWidget();
    headerWidget->setFixedHeight(70);
    headerWidget->setStyleSheet(R"(
        QWidget {
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
    )");
    
    QHBoxLayout* headerLayout = new QHBoxLayout(headerWidget);
    headerLayout->setContentsMargins(20, 0, 20, 0);
    
    QPushButton* backBtn = new QPushButton("‚Üê –ù–∞–∑–∞–¥");
    backBtn->setStyleSheet(R"(
        QPushButton {
            background: transparent;
            color: #8A2BE2;
            border: none;
            font-size: 14px;
            font-weight: 600;
            padding: 10px;
        }
        QPushButton:hover {
            color: #9B4BFF;
        }
    )");
    
    QLabel* nameLabel = new QLabel(m_friendName);
    nameLabel->setStyleSheet(R"(
        color: white;
        font-size: 18px;
        font-weight: 600;
    )");
    
    headerLayout->addWidget(backBtn);
    headerLayout->addWidget(nameLabel);
    headerLayout->addStretch();
    
    m_messagesArea = new QScrollArea();
    m_messagesArea->setWidgetResizable(true);
    m_messagesArea->setStyleSheet(R"(
        QScrollArea {
            background: transparent;
            border: none;
        }
    )");
    
    QWidget* messagesContent = new QWidget();
    m_messagesLayout = new QVBoxLayout(messagesContent);
    m_messagesLayout->setContentsMargins(20, 20, 20, 20);
    m_messagesLayout->setSpacing(10);
    m_messagesLayout->addStretch();
    m_messagesArea->setWidget(messagesContent);
    
    QWidget* inputWidget = new QWidget();
    inputWidget->setFixedHeight(80);
    inputWidget->setStyleSheet(R"(
        QWidget {
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
    )");
    
    QHBoxLayout* inputLayout = new QHBoxLayout(inputWidget);
    inputLayout->setContentsMargins(20, 15, 20, 15);
    inputLayout->setSpacing(15);
    
    m_messageInput = new QLineEdit();
    m_messageInput->setPlaceholderText("–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ...");
    m_messageInput->setStyleSheet(R"(
        QLineEdit {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 0 20px;
            color: white;
            font-size: 14px;
        }
        QLineEdit:focus {
            border: 2px solid #8A2BE2;
        }
    )");
    
    QPushButton* sendBtn = new QPushButton("–û—Ç–ø—Ä–∞–≤–∏—Ç—å");
    sendBtn->setFixedWidth(120);
    sendBtn->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            padding: 12px;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");
    
    inputLayout->addWidget(m_messageInput);
    inputLayout->addWidget(sendBtn);
    
    mainLayout->addWidget(headerWidget);
    mainLayout->addWidget(m_messagesArea, 1);
    mainLayout->addWidget(inputWidget);
    
    connect(backBtn, &QPushButton::clicked, this, &ChatWidget::backClicked);
    connect(sendBtn, &QPushButton::clicked, this, &ChatWidget::onSendMessage);
    connect(m_messageInput, &QLineEdit::returnPressed, this, &ChatWidget::onSendMessage);
}

void ChatWidget::loadMessages()
{
    while (m_messagesLayout->count() > 1) {
        QLayoutItem* item = m_messagesLayout->takeAt(0);
        if (item->widget()) {
            item->widget()->deleteLater();
        }
        delete item;
    }
    
    QVector<Message> messages = m_chatManager->getMessages(m_friendId, 50);
    
    for (int i = messages.size() - 1; i >= 0; --i) {
        const Message& msg = messages[i];
        bool isOwn = (msg.senderId == m_userId);
        
        MessageBubble* bubble = new MessageBubble(msg, isOwn);
        m_messagesLayout->insertWidget(m_messagesLayout->count() - 1, bubble);
        
        if (!isOwn && !msg.isRead) {
            m_chatManager->markAsRead(msg.id);
        }
    }
    
    QTimer::singleShot(100, this, [this]() {
        m_messagesArea->verticalScrollBar()->setValue(
            m_messagesArea->verticalScrollBar()->maximum()
        );
    });
}

void ChatWidget::onSendMessage()
{
    QString text = m_messageInput->text().trimmed();
    
    if (text.isEmpty()) {
        return;
    }
    
    if (m_chatManager->sendMessage(m_friendId, text)) {
        m_messageInput->clear();
        loadMessages();
    } else {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ");
    }
}


=== DanilKurs/src/gui/widgets/ChatWidget.h ===
#ifndef CHATWIDGET_H
#define CHATWIDGET_H

#include <QWidget>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QScrollArea>
#include <QLineEdit>
#include <QPushButton>
#include <QLabel>
#include <QTimer>
#include "network/ChatManager.h"

class ChatWidget : public QWidget
{
    Q_OBJECT

public:
    explicit ChatWidget(int userId, int friendId, const QString& friendName, QWidget *parent = nullptr);

signals:
    void backClicked();

private slots:
    void onSendMessage();

private:
    void setupUI();
    void loadMessages();
    
    int m_userId;
    int m_friendId;
    QString m_friendName;
    ChatManager* m_chatManager;
    
    QScrollArea* m_messagesArea;
    QVBoxLayout* m_messagesLayout;
    QLineEdit* m_messageInput;
};

#endif


=== DanilKurs/src/gui/widgets/FriendCard.h ===
#ifndef FRIENDCARD_H
#define FRIENDCARD_H

#include <QWidget>
#include <QLabel>
#include <QPushButton>
#include "core/models/User.h"

class FriendCard : public QWidget
{
    Q_OBJECT

public:
    explicit FriendCard(const User& user, bool isRequest, bool isSearchResult, QWidget *parent = nullptr);

signals:
    void acceptClicked();
    void rejectClicked();
    void removeClicked();
    void messageClicked();
    void addFriendClicked();

private:
    void setupUI(const User& user, bool isRequest, bool isSearchResult);
    QString getStatusColor(UserStatus status);
    QString getStatusText(UserStatus status);
    
    QLabel* m_avatarLabel;
    QLabel* m_usernameLabel;
    QLabel* m_statusLabel;
};

#endif



=== DanilKurs/src/gui/widgets/TrackListItem.cpp ===
#include "TrackListItem.h"
#include <QHBoxLayout>
#include <QVBoxLayout>

TrackListItem::TrackListItem(const TrackData& track, bool showAlbum, QWidget *parent)
    : QWidget(parent)
    , m_trackId(track.id)
    , m_track(track)
{
    setupUI(showAlbum);
}

void TrackListItem::setupUI(bool showAlbum)
{
    setFixedHeight(65);
    setCursor(Qt::PointingHandCursor);
    
    QHBoxLayout* mainLayout = new QHBoxLayout(this);
    mainLayout->setContentsMargins(15, 8, 15, 8);
    mainLayout->setSpacing(15);
    
    m_numberLabel = new QLabel(QString::number(m_track.position + 1));
    m_numberLabel->setFixedWidth(40);
    m_numberLabel->setAlignment(Qt::AlignCenter);
    m_numberLabel->setStyleSheet("color: rgba(255, 255, 255, 0.5); font-size: 14px;");
    
    m_playButton = new QPushButton("‚ñ∂");
    m_playButton->setFixedSize(35, 35);
    m_playButton->setStyleSheet(R"(
        QPushButton {
            background: rgba(138, 43, 226, 0.2);
            border: 1px solid #8A2BE2;
            color: #8A2BE2;
            border-radius: 17px;
            font-size: 12px;
        }
        QPushButton:hover {
            background: #8A2BE2;
            color: white;
        }
    )");
    m_playButton->hide();
    
    QWidget* infoWidget = new QWidget();
    QVBoxLayout* infoLayout = new QVBoxLayout(infoWidget);
    infoLayout->setContentsMargins(0, 0, 0, 0);
    infoLayout->setSpacing(3);
    
    m_titleLabel = new QLabel(m_track.title);
    m_titleLabel->setStyleSheet("color: white; font-size: 15px; font-weight: 600;");
    
    m_artistLabel = new QLabel(m_track.artist);
    m_artistLabel->setStyleSheet("color: rgba(255, 255, 255, 0.6); font-size: 13px;");
    
    infoLayout->addWidget(m_titleLabel);
    infoLayout->addWidget(m_artistLabel);
    
    if (showAlbum) {
        m_albumLabel = new QLabel(m_track.album);
        m_albumLabel->setStyleSheet("color: rgba(255, 255, 255, 0.5); font-size: 13px;");
        m_albumLabel->setFixedWidth(200);
    }
    
    m_durationLabel = new QLabel(formatDuration(m_track.duration));
    m_durationLabel->setStyleSheet("color: rgba(255, 255, 255, 0.5); font-size: 14px;");
    m_durationLabel->setFixedWidth(60);
    
    m_moreButton = new QPushButton("‚ãÆ");
    m_moreButton->setFixedSize(30, 30);
    m_moreButton->setStyleSheet(R"(
        QPushButton {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            font-size: 18px;
            border-radius: 15px;
        }
        QPushButton:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
    )");
    
    mainLayout->addWidget(m_numberLabel);
    mainLayout->addWidget(m_playButton);
    mainLayout->addWidget(infoWidget, 1);
    
    if (showAlbum && m_albumLabel) {
        mainLayout->addWidget(m_albumLabel);
    }
    
    mainLayout->addWidget(m_durationLabel);
    mainLayout->addWidget(m_moreButton);
    
    connect(m_playButton, &QPushButton::clicked, [this]() {
        emit playClicked(m_trackId);
    });
    
    connect(m_moreButton, &QPushButton::clicked, [this]() {
        emit moreClicked(m_trackId, m_moreButton->mapToGlobal(m_moreButton->rect().bottomLeft()));
    });
    
    setStyleSheet(R"(
        TrackListItem {
            background: transparent;
            border-radius: 8px;
        }
        TrackListItem:hover {
            background: rgba(255, 255, 255, 0.05);
        }
    )");
}

QString TrackListItem::formatDuration(int seconds)
{
    int minutes = seconds / 60;
    int secs = seconds % 60;
    return QString("%1:%2").arg(minutes).arg(secs, 2, 10, QChar('0'));
}


=== DanilKurs/src/gui/widgets/RoomCard.cpp ===
#include "RoomCard.h"
#include <QVBoxLayout>
#include <QHBoxLayout>

RoomCard::RoomCard(const Room& room, QWidget *parent)
    : QWidget(parent), m_roomId(room.id)
{
    setupUI(room);
}

void RoomCard::setupUI(const Room& room)
{
    setFixedHeight(180);
    setStyleSheet(R"(
        QWidget {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 12px;
        }
        QWidget:hover {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(138, 43, 226, 0.3);
        }
    )");
    
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(20, 15, 20, 15);
    mainLayout->setSpacing(12);
    
    QWidget* topRow = new QWidget();
    QHBoxLayout* topLayout = new QHBoxLayout(topRow);
    topLayout->setContentsMargins(0, 0, 0, 0);
    
    QLabel* iconLabel = new QLabel("üéµ");
    iconLabel->setStyleSheet("color: #8A2BE2; font-size: 18px;");
    
    m_nameLabel = new QLabel(room.name);
    m_nameLabel->setStyleSheet("color: white; font-size: 16px; font-weight: 600;");
    m_nameLabel->setWordWrap(true);
    
    m_membersLabel = new QLabel(QString("%1/%2").arg(room.members.size()).arg(room.maxMembers));
    m_membersLabel->setStyleSheet(R"(
        color: rgba(255, 255, 255, 0.7);
        font-size: 13px;
        background: rgba(255, 255, 255, 0.05);
        padding: 4px 10px;
        border-radius: 10px;
    )");
    
    topLayout->addWidget(iconLabel);
    topLayout->addWidget(m_nameLabel, 1);
    topLayout->addWidget(m_membersLabel);
    
    m_genreLabel = new QLabel(room.genre);
    m_genreLabel->setStyleSheet("color: #8A2BE2; font-size: 14px; font-weight: 500;");
    
    m_trackLabel = new QLabel(room.currentTrackTitle.isEmpty() ? 
        "–ù–µ—Ç —Ç–µ–∫—É—â–µ–≥–æ —Ç—Ä–µ–∫–∞" : 
        QString("%1 - %2").arg(room.currentTrackArtist, room.currentTrackTitle));
    m_trackLabel->setStyleSheet("color: rgba(255, 255, 255, 0.7); font-size: 13px; font-style: italic;");
    m_trackLabel->setWordWrap(true);
    
    m_joinButton = new QPushButton("–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è");
    m_joinButton->setFixedHeight(38);
    m_joinButton->setStyleSheet(R"(
        QPushButton {
            background: rgba(138, 43, 226, 0.2);
            border: 1px solid #8A2BE2;
            color: #8A2BE2;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: rgba(138, 43, 226, 0.3);
        }
    )");
    
    connect(m_joinButton, &QPushButton::clicked, [this]() {
        emit joinClicked(m_roomId);
    });
    
    mainLayout->addWidget(topRow);
    mainLayout->addWidget(m_genreLabel);
    mainLayout->addWidget(m_trackLabel, 1);
    mainLayout->addWidget(m_joinButton);
}


=== DanilKurs/src/gui/widgets/UserAvatar.cpp ===
#include "UserAvatar.h"
#include <QPainter>
#include <QPainterPath>

UserAvatar::UserAvatar(int size, QWidget *parent)
    : QWidget(parent)
    , m_size(size)
    , m_status(UserStatus::Offline)
    , m_hasAvatar(false)
{
    setFixedSize(size, size);
}

void UserAvatar::setUser(const User& user)
{
    m_status = user.status;
    
    if (!user.avatarPath.isEmpty()) {
        setAvatar(user.avatarPath);
    } else {
        m_initials = user.username.left(1).toUpper();
        m_hasAvatar = false;
    }
    
    update();
}

void UserAvatar::setAvatar(const QString& avatarPath)
{
    QPixmap pixmap(avatarPath);
    if (!pixmap.isNull()) {
        m_avatar = pixmap.scaled(m_size, m_size, Qt::KeepAspectRatioByExpanding, Qt::SmoothTransformation);
        m_hasAvatar = true;
    } else {
        m_hasAvatar = false;
    }
    update();
}

void UserAvatar::setStatus(UserStatus status)
{
    m_status = status;
    update();
}

void UserAvatar::setInitials(const QString& initials)
{
    m_initials = initials;
    m_hasAvatar = false;
    update();
}

void UserAvatar::paintEvent(QPaintEvent *event)
{
    Q_UNUSED(event);
    
    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing);
    
    QPainterPath circlePath;
    circlePath.addEllipse(0, 0, m_size, m_size);
    painter.setClipPath(circlePath);
    
    if (m_hasAvatar) {
        painter.drawPixmap(0, 0, m_avatar);
    } else {
        QLinearGradient gradient(0, 0, m_size, m_size);
        gradient.setColorAt(0, QColor(138, 43, 226));
        gradient.setColorAt(1, QColor(155, 75, 255));
        painter.fillPath(circlePath, gradient);
        
        painter.setPen(Qt::white);
        QFont font = painter.font();
        font.setPointSize(m_size / 2.5);
        font.setBold(true);
        painter.setFont(font);
        painter.drawText(rect(), Qt::AlignCenter, m_initials);
    }
    
    painter.setClipping(false);
    
    if (m_status != UserStatus::Offline) {
        QColor statusColor;
        switch (m_status) {
            case UserStatus::Online: statusColor = QColor(76, 175, 80); break;
            case UserStatus::Away: statusColor = QColor(255, 193, 7); break;
            case UserStatus::DoNotDisturb: statusColor = QColor(244, 67, 54); break;
            default: statusColor = QColor(158, 158, 158); break;
        }
        
        int statusSize = m_size / 4;
        int statusX = m_size - statusSize - 2;
        int statusY = m_size - statusSize - 2;
        
        painter.setBrush(statusColor);
        painter.setPen(QPen(QColor(15, 15, 20), 2));
        painter.drawEllipse(statusX, statusY, statusSize, statusSize);
    }
}


=== DanilKurs/src/gui/widgets/MessageBubble.h ===
#ifndef MESSAGEBUBBLE_H
#define MESSAGEBUBBLE_H

#include <QWidget>
#include "core/models/Message.h"

class QLabel;

class MessageBubble : public QWidget
{
    Q_OBJECT
public:
    explicit MessageBubble(const Message& message, bool isOwn, QWidget *parent = nullptr);

private:
    void setupUI(const Message& message, bool isOwn);
};

#endif


=== DanilKurs/src/gui/MainWindow/pages/MessagesPage.cpp ===
#include "MessagesPage.h"

#include "database/DatabaseManager.h"

#include <QLabel>
#include <QPushButton>
#include <QTimer>
#include <QSqlQuery>
#include <QSqlError>
#include <QDebug>
#include <QHBoxLayout>
#include <QPainter>
#include <QPainterPath>
#include <QDateTime>

static QPixmap makeRoundAvatar(const QPixmap& src, int size)
{
    if (src.isNull()) {
        QPixmap fallback(size, size);
        fallback.fill(Qt::transparent);
        QPainter p(&fallback);
        p.setRenderHint(QPainter::Antialiasing, true);
        QRadialGradient g(size/2, size/2, size/2);
        g.setColorAt(0, QColor("#9B4BFF"));
        g.setColorAt(1, QColor("#7B1FA2"));
        p.setBrush(g);
        p.setPen(Qt::NoPen);
        p.drawEllipse(0, 0, size, size);
        return fallback;
    }

    QPixmap scaled = src.scaled(size, size, Qt::KeepAspectRatioByExpanding, Qt::SmoothTransformation);
    QPixmap out(size, size);
    out.fill(Qt::transparent);

    QPainter painter(&out);
    painter.setRenderHint(QPainter::Antialiasing, true);
    QPainterPath path;
    path.addEllipse(0, 0, size, size);
    painter.setClipPath(path);
    painter.drawPixmap(0, 0, scaled);
    return out;
}

static QString formatTimeSmart(const QDateTime& dt)
{
    if (!dt.isValid()) return "";
    const QDate today = QDate::currentDate();
    if (dt.date() == today) return dt.toString("HH:mm");
    return dt.toString("dd.MM");
}

MessagesPage::MessagesPage(int userId, QWidget *parent)
    : QWidget(parent)
    , m_userId(userId)
    , m_chatManager(new ChatManager(userId, this))
    , m_currentChatWidget(nullptr)
{
    setupUI();
    loadChats();

    m_refreshTimer = new QTimer(this);
    connect(m_refreshTimer, &QTimer::timeout, this, &MessagesPage::refreshChats);
    m_refreshTimer->start(2500);
}

void MessagesPage::setupUI()
{
    setStyleSheet("background:#0F0F14;");

    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);

    m_stackedWidget = new QStackedWidget();
    m_stackedWidget->setStyleSheet("background:#0F0F14;");

    m_chatListWidget = new QWidget();
    m_chatListWidget->setStyleSheet("background:#0F0F14;");
    QVBoxLayout* listLayout = new QVBoxLayout(m_chatListWidget);
    listLayout->setContentsMargins(40, 40, 40, 40);
    listLayout->setSpacing(20);

    QLabel* titleLabel = new QLabel("üí¨ –°–æ–æ–±—â–µ–Ω–∏—è");
    titleLabel->setStyleSheet(R"(
        color: white;
        font-size: 32px;
        font-weight: bold;
    )");

    m_chatList = new QListWidget();
    m_chatList->setStyleSheet(R"(
        QListWidget {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            color: white;
            font-size: 14px;
            outline: none;
            padding: 10px;
        }
        QListWidget::item {
            background: transparent;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
            margin: 2px;
        }
        QListWidget::item:selected { background: transparent; border: none; }
        QListWidget::item:hover { background: transparent; }
    )");
    m_chatList->setVerticalScrollMode(QAbstractItemView::ScrollPerPixel);

    listLayout->addWidget(titleLabel);
    listLayout->addWidget(m_chatList);

    m_stackedWidget->addWidget(m_chatListWidget);
    mainLayout->addWidget(m_stackedWidget);

    connect(m_chatList, &QListWidget::itemClicked, this, &MessagesPage::onChatSelected);
}

void MessagesPage::loadChats()
{
    m_chatList->clear();

    QSqlQuery q(DatabaseManager::instance().database());
    q.prepare(
        "SELECT u.id, u.username, u.avatar_path, u.avatar_data, "
        "       lm.sender_id, lm.content, lm.type, lm.timestamp "
        "FROM friendships f "
        "JOIN users u ON u.id = f.friend_id "
        "LEFT JOIN LATERAL ( "
        "   SELECT sender_id, content, type, timestamp "
        "   FROM messages "
        "   WHERE (sender_id = :me AND receiver_id = u.id) OR (sender_id = u.id AND receiver_id = :me) "
        "   ORDER BY timestamp DESC "
        "   LIMIT 1 "
        ") lm ON true "
        "WHERE f.user_id = :me "
        "ORDER BY COALESCE(lm.timestamp, to_timestamp(0)) DESC, u.username ASC"
    );
    q.bindValue(":me", m_userId);

    if (!q.exec()) {
        qDebug() << "friends+last query failed:" << q.lastError().text();
        QListWidgetItem* item = new QListWidgetItem("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏");
        item->setFlags(item->flags() & ~Qt::ItemIsSelectable);
        m_chatList->addItem(item);
        return;
    }

    bool hasAny = false;

    while (q.next()) {
        hasAny = true;

        const int friendId = q.value(0).toInt();
        const QString friendName = q.value(1).toString();
        const QString avatarPath = q.value(2).toString();
        const QByteArray avatarData = q.value(3).toByteArray();

        const QVariant senderVar = q.value(4);
        const int senderId = senderVar.isNull() ? -1 : senderVar.toInt();
        const QString content = q.value(5).toString();
        const QVariant typeVar = q.value(6);
        const int type = typeVar.isNull() ? 0 : typeVar.toInt();
        const QDateTime ts = q.value(7).toDateTime();

        QString lastLine;
        if (senderId == -1) {
            lastLine = "–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π";
        } else if (type == static_cast<int>(MessageType::TrackShare)) {
            lastLine = (senderId == m_userId) ? "–í—ã –ø–æ–¥–µ–ª–∏–ª–∏—Å—å —Ç—Ä–µ–∫–æ–º" : "–ü–æ–¥–µ–ª–∏–ª—Å—è(–∞—Å—å) —Ç—Ä–µ–∫–æ–º";
        } else {
            lastLine = content.trimmed();
            if (lastLine.isEmpty()) lastLine = "(–ø—É—Å—Ç–æ)";
            if (senderId == m_userId) lastLine = "–í—ã: " + lastLine;
        }

        QString timeStr = formatTimeSmart(ts);

        QListWidgetItem* item = new QListWidgetItem();
        item->setData(Qt::UserRole, friendId);
        item->setData(Qt::UserRole + 1, friendName);
        item->setSizeHint(QSize(0, 76));
        m_chatList->addItem(item);

        QWidget* row = new QWidget();
        row->setObjectName("chatRow");
        row->setMinimumHeight(76);
        row->setStyleSheet("#chatRow{background: rgba(138,43,226,0.06); border: 1px solid rgba(138,43,226,0.10); border-radius: 14px;} #chatRow:hover{background: rgba(138,43,226,0.12); border: 1px solid rgba(138,43,226,0.28);}");
        QHBoxLayout* rowL = new QHBoxLayout(row);
        rowL->setContentsMargins(12, 10, 12, 10);
        rowL->setSpacing(12);

        QLabel* avatar = new QLabel();
        avatar->setAttribute(Qt::WA_TransparentForMouseEvents);
        avatar->setStyleSheet("background: transparent;");
        avatar->setFixedSize(48, 48);

        QPixmap px;
        if (!avatarData.isEmpty()) {
            px.loadFromData(avatarData, "PNG");
        } else if (!avatarPath.isEmpty()) {
            px.load(avatarPath);
        }
        avatar->setPixmap(makeRoundAvatar(px, 48));

        QWidget* textBox = new QWidget();
        textBox->setAttribute(Qt::WA_TransparentForMouseEvents);
        textBox->setStyleSheet("background: transparent;");
        QVBoxLayout* textL = new QVBoxLayout(textBox);
        textL->setContentsMargins(0, 0, 0, 0);
        textL->setSpacing(4);

        QLabel* name = new QLabel(friendName);
        name->setAttribute(Qt::WA_TransparentForMouseEvents);
        name->setStyleSheet("background: transparent; color: white; font-size: 16px; font-weight: 600;");

        QLabel* last = new QLabel(lastLine);
        last->setAttribute(Qt::WA_TransparentForMouseEvents);
        last->setStyleSheet("color: rgba(221,195,255,0.80); font-size: 13px;");
        last->setWordWrap(false);

        textL->addWidget(name);
        textL->addWidget(last);

        QLabel* time = new QLabel(timeStr);
        time->setAttribute(Qt::WA_TransparentForMouseEvents);
        time->setStyleSheet("background: transparent; color: rgba(221,195,255,0.55); font-size: 12px;");
        time->setAlignment(Qt::AlignRight | Qt::AlignVCenter);
        time->setFixedWidth(60);

        rowL->addWidget(avatar);
        rowL->addWidget(textBox, 1);
        rowL->addWidget(time);

        m_chatList->setItemWidget(item, row);
    }

    if (!hasAny) {
        QListWidgetItem* item = new QListWidgetItem("–ù–µ—Ç –¥—Ä—É–∑–µ–π");
        item->setFlags(item->flags() & ~Qt::ItemIsSelectable);
        m_chatList->addItem(item);
    }
}

void MessagesPage::onChatSelected(QListWidgetItem* item)
{
    if (!item) return;

    int friendId = item->data(Qt::UserRole).toInt();
    QString friendName = item->data(Qt::UserRole + 1).toString();
    openChat(friendId, friendName);
}

void MessagesPage::openChat(int friendId, const QString& friendName)
{
    if (m_currentChatWidget) {
        m_stackedWidget->removeWidget(m_currentChatWidget);
        m_currentChatWidget->deleteLater();
    }

    m_currentChatWidget = new ChatWidget(m_userId, friendId, friendName);
    m_stackedWidget->addWidget(m_currentChatWidget);
    m_stackedWidget->setCurrentWidget(m_currentChatWidget);

    connect(m_currentChatWidget, &ChatWidget::backClicked, this, &MessagesPage::onBackToList);
}

void MessagesPage::onBackToList()
{
    m_stackedWidget->setCurrentWidget(m_chatListWidget);
    loadChats();
}

void MessagesPage::refreshChats()
{
    if (m_stackedWidget->currentWidget() == m_chatListWidget) {
        loadChats();
    }
}


=== DanilKurs/src/gui/MainWindow/pages/FriendsPage.cpp ===
#include "FriendsPage.h"
#include "gui/widgets/FriendCard.h"
#include <QMessageBox>
#include <QScrollArea>
#include <QLabel>
#include <QDebug>

FriendsPage::FriendsPage(int userId, QWidget *parent)
    : QWidget(parent)
    , m_userId(userId)
    , m_friendManager(new FriendManager(userId, this))
{
    setupUI();
    loadFriends();
}

void FriendsPage::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(40, 40, 40, 40);
    mainLayout->setSpacing(25);
    
    QLabel* titleLabel = new QLabel("üë• –î—Ä—É–∑—å—è");
    titleLabel->setStyleSheet(R"(
        color: white;
        font-size: 32px;
        font-weight: bold;
    )");
    
    QWidget* searchWidget = new QWidget();
    searchWidget->setStyleSheet("background: transparent;");
    QHBoxLayout* searchLayout = new QHBoxLayout(searchWidget);
    searchLayout->setContentsMargins(0, 0, 0, 0);
    searchLayout->setSpacing(15);
    
    m_searchInput = new QLineEdit();
    m_searchInput->setPlaceholderText("–ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π...");
    m_searchInput->setMinimumHeight(50);
    m_searchInput->setStyleSheet(R"(
        QLineEdit {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 0 20px;
            color: white;
            font-size: 14px;
        }
        QLineEdit:focus {
            border: 2px solid #8A2BE2;
        }
    )");
    
    QPushButton* searchBtn = new QPushButton("üîç –ü–æ–∏—Å–∫");
    searchBtn->setMinimumHeight(50);
    searchBtn->setFixedWidth(120);
    searchBtn->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");
    
    searchLayout->addWidget(m_searchInput, 1);
    searchLayout->addWidget(searchBtn);
    
    QWidget* tabsWidget = new QWidget();
    tabsWidget->setStyleSheet("background: transparent;");
    QHBoxLayout* tabsLayout = new QHBoxLayout(tabsWidget);
    tabsLayout->setContentsMargins(0, 0, 0, 0);
    tabsLayout->setSpacing(10);
    
    m_friendsBtn = new QPushButton("–ú–æ–∏ –¥—Ä—É–∑—å—è");
    m_requestsBtn = new QPushButton("–ó–∞–ø—Ä–æ—Å—ã");
    
    QString tabStyle = R"(
        QPushButton {
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.7);
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        QPushButton:checked {
            background: #8A2BE2;
            color: white;
        }
    )";
    
    m_friendsBtn->setCheckable(true);
    m_friendsBtn->setChecked(true);
    m_friendsBtn->setStyleSheet(tabStyle);
    
    m_requestsBtn->setCheckable(true);
    m_requestsBtn->setStyleSheet(tabStyle);
    
    tabsLayout->addWidget(m_friendsBtn);
    tabsLayout->addWidget(m_requestsBtn);
    tabsLayout->addStretch();
    
    m_stackedWidget = new QStackedWidget();
    m_stackedWidget->setStyleSheet("background: transparent;");
    
    QWidget* friendsScroll = new QWidget();
    friendsScroll->setStyleSheet("background: transparent;");
    m_friendsLayout = new QVBoxLayout(friendsScroll);
    m_friendsLayout->setContentsMargins(0, 0, 0, 0);
    m_friendsLayout->setSpacing(15);
    
    QWidget* requestsScroll = new QWidget();
    requestsScroll->setStyleSheet("background: transparent;");
    m_requestsLayout = new QVBoxLayout(requestsScroll);
    m_requestsLayout->setContentsMargins(0, 0, 0, 0);
    m_requestsLayout->setSpacing(15);
    
    QWidget* searchScroll = new QWidget();
    searchScroll->setStyleSheet("background: transparent;");
    m_searchLayout = new QVBoxLayout(searchScroll);
    m_searchLayout->setContentsMargins(0, 0, 0, 0);
    m_searchLayout->setSpacing(15);
    
    m_friendsWidget = new QScrollArea();
    m_friendsWidget->setWidgetResizable(true);
    m_friendsWidget->setWidget(friendsScroll);
    m_friendsWidget->setStyleSheet("QScrollArea { background: transparent; border: none; } QWidget { background: transparent; }");
    
    m_requestsWidget = new QScrollArea();
    m_requestsWidget->setWidgetResizable(true);
    m_requestsWidget->setWidget(requestsScroll);
    m_requestsWidget->setStyleSheet("QScrollArea { background: transparent; border: none; } QWidget { background: transparent; }");
    
    m_searchWidget = new QScrollArea();
    m_searchWidget->setWidgetResizable(true);
    m_searchWidget->setWidget(searchScroll);
    m_searchWidget->setStyleSheet("QScrollArea { background: transparent; border: none; } QWidget { background: transparent; }");
    
    m_stackedWidget->addWidget(m_friendsWidget);
    m_stackedWidget->addWidget(m_requestsWidget);
    m_stackedWidget->addWidget(m_searchWidget);
    
    mainLayout->addWidget(titleLabel);
    mainLayout->addWidget(searchWidget);
    mainLayout->addWidget(tabsWidget);
    mainLayout->addWidget(m_stackedWidget, 1);
    
    connect(searchBtn, &QPushButton::clicked, this, &FriendsPage::onSearchClicked);
    connect(m_searchInput, &QLineEdit::returnPressed, this, &FriendsPage::onSearchClicked);
    connect(m_friendsBtn, &QPushButton::clicked, this, &FriendsPage::onShowFriends);
    connect(m_requestsBtn, &QPushButton::clicked, this, &FriendsPage::onShowRequests);
}

void FriendsPage::loadFriends()
{
    qDebug() << "=== Loading friends ===";
    
    while (m_friendsLayout->count() > 0) {
        QLayoutItem* item = m_friendsLayout->takeAt(0);
        if (item->widget()) {
            item->widget()->deleteLater();
        }
        delete item;
    }
    
    QVector<User> friends = m_friendManager->getFriends();
    qDebug() << "Found" << friends.size() << "friends";
    
    if (friends.isEmpty()) {
        QLabel* emptyLabel = new QLabel("–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –¥—Ä—É–∑–µ–π üòî");
        emptyLabel->setStyleSheet("color: rgba(255, 255, 255, 0.7); font-size: 16px; padding: 20px;");
        emptyLabel->setAlignment(Qt::AlignCenter);
        m_friendsLayout->addWidget(emptyLabel);
        qDebug() << "Added empty label";
    } else {
        for (const User& user : friends) {
            qDebug() << "Adding friend card for:" << user.username;
            FriendCard* card = new FriendCard(user, false, false);
            card->setFixedHeight(90);
            card->setStyleSheet(R"(
                FriendCard {
                    background: rgba(255, 255, 255, 0.03);
                    border: 1px solid rgba(255, 255, 255, 0.05);
                    border-radius: 12px;
                }
                FriendCard:hover {
                    background: rgba(255, 255, 255, 0.05);
                    border: 1px solid rgba(138, 43, 226, 0.3);
                }
            )");
            
            connect(card, &FriendCard::messageClicked, this, [this, user]() {
                onMessageFriend(user.id);
            });
            
            connect(card, &FriendCard::removeClicked, this, [this, user]() {
                onRemoveFriend(user.id);
            });
            
            m_friendsLayout->addWidget(card);
        }
    }
    
    m_friendsLayout->addStretch();
    qDebug() << "=== Friends loading complete ===";
}

void FriendsPage::loadRequests()
{
    qDebug() << "=== Loading requests ===";
    
    while (m_requestsLayout->count() > 0) {
        QLayoutItem* item = m_requestsLayout->takeAt(0);
        if (item->widget()) {
            item->widget()->deleteLater();
        }
        delete item;
    }
    
    QVector<User> requests = m_friendManager->getPendingRequests();
    qDebug() << "Found" << requests.size() << "requests";
    
    if (requests.isEmpty()) {
        QLabel* emptyLabel = new QLabel("–ù–µ—Ç –Ω–æ–≤—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ –¥—Ä—É–∑—å—è");
        emptyLabel->setStyleSheet("color: rgba(255, 255, 255, 0.7); font-size: 16px; padding: 20px;");
        emptyLabel->setAlignment(Qt::AlignCenter);
        m_requestsLayout->addWidget(emptyLabel);
    } else {
        for (const User& user : requests) {
            FriendCard* card = new FriendCard(user, true, false);
            card->setFixedHeight(90);
            card->setStyleSheet(R"(
                FriendCard {
                    background: rgba(255, 255, 255, 0.03);
                    border: 1px solid rgba(255, 255, 255, 0.05);
                    border-radius: 12px;
                }
                FriendCard:hover {
                    background: rgba(255, 255, 255, 0.05);
                    border: 1px solid rgba(138, 43, 226, 0.3);
                }
            )");
            
            connect(card, &FriendCard::acceptClicked, this, [this, user]() {
                onAcceptRequest(user.id);
            });
            
            connect(card, &FriendCard::rejectClicked, this, [this, user]() {
                onRejectRequest(user.id);
            });
            
            m_requestsLayout->addWidget(card);
        }
    }
    
    m_requestsLayout->addStretch();
}

void FriendsPage::searchUsers()
{
    QString query = m_searchInput->text().trimmed();
    qDebug() << "=== Searching for:" << query << "===";
    
    if (query.isEmpty()) {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–í–≤–µ–¥–∏—Ç–µ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –ø–æ–∏—Å–∫–∞");
        return;
    }
    
    QVector<User> results = m_friendManager->searchUsers(query);
    qDebug() << "Search returned" << results.size() << "results";
    
    for (const User& user : results) {
        qDebug() << "  - User:" << user.username << "ID:" << user.id;
    }
    
    displaySearchResults(results);
}

void FriendsPage::displaySearchResults(const QVector<User>& users)
{
    qDebug() << "=== Displaying" << users.size() << "search results ===";
    
    while (m_searchLayout->count() > 0) {
        QLayoutItem* item = m_searchLayout->takeAt(0);
        if (item->widget()) {
            item->widget()->deleteLater();
        }
        delete item;
    }
    
    if (users.isEmpty()) {
        QLabel* emptyLabel = new QLabel("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã");
        emptyLabel->setStyleSheet("color: rgba(255, 255, 255, 0.7); font-size: 16px; padding: 20px;");
        emptyLabel->setAlignment(Qt::AlignCenter);
        m_searchLayout->addWidget(emptyLabel);
        qDebug() << "Added 'no results' label";
    } else {
        for (const User& user : users) {
            qDebug() << "Creating search result card for:" << user.username;
            FriendCard* card = new FriendCard(user, false, true);
            card->setFixedHeight(90);
            card->setStyleSheet(R"(
                FriendCard {
                    background: rgba(255, 255, 255, 0.03);
                    border: 1px solid rgba(255, 255, 255, 0.05);
                    border-radius: 12px;
                }
                FriendCard:hover {
                    background: rgba(255, 255, 255, 0.05);
                    border: 1px solid rgba(138, 43, 226, 0.3);
                }
            )");
            
            connect(card, &FriendCard::addFriendClicked, this, [this, user]() {
                qDebug() << "Add friend clicked for:" << user.username;
                onAddFriend(user.id);
            });
            
            m_searchLayout->addWidget(card);
            qDebug() << "Card added to layout";
        }
    }
    
    m_searchLayout->addStretch();
    m_stackedWidget->setCurrentWidget(m_searchWidget);
    qDebug() << "Switched to search widget";
    qDebug() << "=== Display complete ===";
}

void FriendsPage::onSearchClicked()
{
    qDebug() << "Search button clicked";
    searchUsers();
}

void FriendsPage::onShowFriends()
{
    m_friendsBtn->setChecked(true);
    m_requestsBtn->setChecked(false);
    m_stackedWidget->setCurrentWidget(m_friendsWidget);
    loadFriends();
}

void FriendsPage::onShowRequests()
{
    m_friendsBtn->setChecked(false);
    m_requestsBtn->setChecked(true);
    m_stackedWidget->setCurrentWidget(m_requestsWidget);
    loadRequests();
}

void FriendsPage::onAddFriend(int userId)
{
    qDebug() << "Sending friend request to user:" << userId;
    if (m_friendManager->sendFriendRequest(userId)) {
        QMessageBox::information(this, "–£—Å–ø–µ—Ö", "–ó–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω!");
    } else {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞–ø—Ä–æ—Å");
    }
}

void FriendsPage::onAcceptRequest(int userId)
{
    if (m_friendManager->acceptFriendRequest(userId)) {
        QMessageBox::information(this, "–£—Å–ø–µ—Ö", "–ó–∞–ø—Ä–æ—Å –ø—Ä–∏–Ω—è—Ç!");
        loadRequests();
        loadFriends();
    } else {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏–Ω—è—Ç—å –∑–∞–ø—Ä–æ—Å");
    }
}

void FriendsPage::onRejectRequest(int userId)
{
    if (m_friendManager->rejectFriendRequest(userId)) {
        loadRequests();
    } else {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫–ª–æ–Ω–∏—Ç—å –∑–∞–ø—Ä–æ—Å");
    }
}

void FriendsPage::onRemoveFriend(int userId)
{
    QMessageBox::StandardButton reply = QMessageBox::question(
        this, 
        "–£–¥–∞–ª–µ–Ω–∏–µ –∏–∑ –¥—Ä—É–∑–µ–π", 
        "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –¥—Ä—É–∑–µ–π?",
        QMessageBox::Yes | QMessageBox::No
    );
    
    if (reply == QMessageBox::Yes) {
        if (m_friendManager->removeFriend(userId)) {
            loadFriends();
        } else {
            QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –¥—Ä—É–≥–∞");
        }
    }
}

void FriendsPage::onMessageFriend(int userId)
{
    QVector<User> friends = m_friendManager->getFriends();
    for (const User& user : friends) {
        if (user.id == userId) {
            emit openChatWithFriend(userId, user.username);
            break;
        }
    }
}

void FriendsPage::refreshData()
{
    if (m_stackedWidget->currentWidget() == m_friendsWidget) {
        loadFriends();
    } else if (m_stackedWidget->currentWidget() == m_requestsWidget) {
        loadRequests();
    }
}


=== DanilKurs/src/gui/MainWindow/pages/SearchMusicPage.cpp ===
#include "SearchMusicPage.h"
#include "database/api/MusicAPIManager.h"
#include "database/DatabaseManager.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QMenu>
#include <QMessageBox>

SearchMusicPage::SearchMusicPage(int userId, QWidget *parent)
    : QWidget(parent)
    , m_userId(userId)
    , m_apiManager(new MusicAPIManager(this))
{
    setupUI();
    
    connect(m_apiManager, &MusicAPIManager::tracksFound, this, &SearchMusicPage::onTracksFound);
    connect(m_apiManager, &MusicAPIManager::errorOccurred, this, &SearchMusicPage::onNetworkError);
}

SearchMusicPage::~SearchMusicPage()
{
}

void SearchMusicPage::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(40, 40, 40, 40);
    mainLayout->setSpacing(25);
    
    QLabel* titleLabel = new QLabel("–ü–æ–∏—Å–∫ –º—É–∑—ã–∫–∏");
    titleLabel->setStyleSheet("color: white; font-size: 32px; font-weight: bold;");
    mainLayout->addWidget(titleLabel);
    
    QWidget* searchWidget = new QWidget();
    QHBoxLayout* searchLayout = new QHBoxLayout(searchWidget);
    searchLayout->setContentsMargins(0, 0, 0, 0);
    searchLayout->setSpacing(15);
    
    m_searchInput = new QLineEdit();
    m_searchInput->setPlaceholderText("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞, –∞–ª—å–±–æ–º–∞ –∏–ª–∏ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è...");
    m_searchInput->setMinimumHeight(50);
    m_searchInput->setStyleSheet(R"(
        QLineEdit {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 0 20px;
            color: white;
            font-size: 14px;
        }
        QLineEdit:focus {
            border: 2px solid #8A2BE2;
            background: rgba(255, 255, 255, 0.07);
        }
    )");
    
    m_searchButton = new QPushButton("–ù–∞–π—Ç–∏");
    m_searchButton->setFixedWidth(120);
    m_searchButton->setMinimumHeight(50);
    m_searchButton->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");
    
    m_topTracksButton = new QPushButton("üî• –ü–æ–ø—É–ª—è—Ä–Ω–æ–µ");
    m_topTracksButton->setFixedWidth(150);
    m_topTracksButton->setMinimumHeight(50);
    m_topTracksButton->setStyleSheet(m_searchButton->styleSheet());
    
    searchLayout->addWidget(m_searchInput, 1);
    searchLayout->addWidget(m_searchButton);
    searchLayout->addWidget(m_topTracksButton);
    
    mainLayout->addWidget(searchWidget);
    
    QWidget* resultsWidget = new QWidget();
    QHBoxLayout* resultsLayout = new QHBoxLayout(resultsWidget);
    resultsLayout->setContentsMargins(0, 0, 0, 0);
    resultsLayout->setSpacing(20);
    
    m_tracksList = new QListWidget();
    m_tracksList->setStyleSheet(R"(
        QListWidget {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            color: white;
            font-size: 14px;
            outline: none;
            padding: 10px;
        }
        QListWidget::item {
            background: transparent;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
        }
        QListWidget::item:selected {
            background: rgba(138, 43, 226, 0.15);
            border: 1px solid rgba(138, 43, 226, 0.3);
        }
        QListWidget::item:hover {
            background: rgba(255, 255, 255, 0.05);
        }
    )");
    m_tracksList->setContextMenuPolicy(Qt::CustomContextMenu);
    
    m_trackInfo = new QTextEdit();
    m_trackInfo->setReadOnly(true);
    m_trackInfo->setMaximumWidth(350);
    m_trackInfo->setStyleSheet(R"(
        QTextEdit {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            color: white;
            font-size: 13px;
            padding: 15px;
        }
    )");
    m_trackInfo->setPlaceholderText("–í—ã–±–µ—Ä–∏—Ç–µ —Ç—Ä–µ–∫ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏");
    
    resultsLayout->addWidget(m_tracksList, 1);
    resultsLayout->addWidget(m_trackInfo);
    
    mainLayout->addWidget(resultsWidget, 1);
    
    m_loadingLabel = new QLabel("–ó–∞–≥—Ä—É–∑–∫–∞...");
    m_loadingLabel->setStyleSheet("color: #8A2BE2; font-size: 16px;");
    m_loadingLabel->setAlignment(Qt::AlignCenter);
    m_loadingLabel->hide();
    mainLayout->addWidget(m_loadingLabel);
    
    connect(m_searchButton, &QPushButton::clicked, this, &SearchMusicPage::onSearchClicked);
    connect(m_topTracksButton, &QPushButton::clicked, this, &SearchMusicPage::onTopTracksClicked);
    connect(m_searchInput, &QLineEdit::returnPressed, this, &SearchMusicPage::onSearchClicked);
    connect(m_tracksList, &QListWidget::itemClicked, this, &SearchMusicPage::onTrackSelected);
    connect(m_tracksList, &QListWidget::customContextMenuRequested, this, &SearchMusicPage::onTrackContextMenu);
}

void SearchMusicPage::onSearchClicked()
{
    QString query = m_searchInput->text().trimmed();
    if (query.isEmpty()) {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–í–≤–µ–¥–∏—Ç–µ –ø–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å");
        return;
    }
    
    m_loadingLabel->show();
    m_tracksList->clear();
    m_trackInfo->clear();
    
    m_apiManager->searchTracks(query, m_userId);
}

void SearchMusicPage::onTopTracksClicked()
{
    m_loadingLabel->show();
    m_tracksList->clear();
    m_trackInfo->clear();
    
    m_apiManager->getTopTracks(m_userId);
}

void SearchMusicPage::onTracksFound(const QVariantList& tracks)
{
    m_loadingLabel->hide();
    m_currentTracks = tracks;
    displayTracks(tracks);
}

void SearchMusicPage::displayTracks(const QVariantList& tracks)
{
    m_tracksList->clear();
    
    if (tracks.isEmpty()) {
        QListWidgetItem* item = new QListWidgetItem("–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ");
        item->setFlags(Qt::NoItemFlags);
        m_tracksList->addItem(item);
        return;
    }
    
    for (int i = 0; i < tracks.size(); ++i) {
        QVariantMap track = tracks[i].toMap();
        
        QString displayText = QString("üéµ  %1 - %2")
            .arg(track["artist"].toString())
            .arg(track["title"].toString());
        
        if (track.contains("listeners")) {
            displayText += QString("  üë• %1").arg(track["listeners"].toString());
        }
        
        QListWidgetItem* item = new QListWidgetItem(displayText);
        item->setData(Qt::UserRole, i);
        m_tracksList->addItem(item);
    }
}

void SearchMusicPage::onTrackSelected(QListWidgetItem* item)
{
    int index = item->data(Qt::UserRole).toInt();
    if (index >= 0 && index < m_currentTracks.size()) {
        QVariantMap track = m_currentTracks[index].toMap();
        displayTrackInfo(track);
    }
}

void SearchMusicPage::displayTrackInfo(const QVariantMap& track)
{
    QString info;
    info += QString("<h3 style='color: #8A2BE2;'>%1</h3>").arg(track["title"].toString());
    info += QString("<p style='color: white; font-size: 14px;'><b>–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å:</b> %1</p>").arg(track["artist"].toString());
    
    if (track.contains("listeners")) {
        info += QString("<p style='color: rgba(255,255,255,0.7);'><b>–°–ª—É—à–∞—Ç–µ–ª–µ–π:</b> %1</p>").arg(track["listeners"].toString());
    }
    
    if (track.contains("playcount")) {
        info += QString("<p style='color: rgba(255,255,255,0.7);'><b>–ü—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–π:</b> %1</p>").arg(track["playcount"].toString());
    }
    
    if (!track["coverUrl"].toString().isEmpty()) {
        info += QString("<p><img src='%1' width='200' /></p>").arg(track["coverUrl"].toString());
    }
    
    m_trackInfo->setHtml(info);
}

void SearchMusicPage::onTrackContextMenu(const QPoint& pos)
{
    QListWidgetItem* item = m_tracksList->itemAt(pos);
    if (!item) return;
    
    int index = item->data(Qt::UserRole).toInt();
    if (index < 0 || index >= m_currentTracks.size()) return;
    
    QVariantMap track = m_currentTracks[index].toMap();
    
    QMenu menu(this);
    menu.setStyleSheet(R"(
        QMenu {
            background: #1A1A21;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 5px;
        }
        QMenu::item {
            background: transparent;
            color: white;
            padding: 8px 20px;
            border-radius: 4px;
        }
        QMenu::item:selected {
            background: rgba(138, 43, 226, 0.3);
        }
    )");
    
    QAction* addAction = menu.addAction("–î–æ–±–∞–≤–∏—Ç—å –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫—É");
    
    QAction* selected = menu.exec(m_tracksList->mapToGlobal(pos));
    
    if (selected == addAction) {
        addTrackToLibrary(track);
    }
}

void SearchMusicPage::addTrackToLibrary(const QVariantMap& track)
{
    bool success = DatabaseManager::instance().addTrackFromAPI(
        m_userId,
        track["title"].toString(),
        track["artist"].toString(),
        track["coverUrl"].toString()
    );
    
    if (success) {
        QMessageBox::information(this, "–£—Å–ø–µ—Ö", "–¢—Ä–µ–∫ –¥–æ–±–∞–≤–ª–µ–Ω –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫—É!");
        emit trackAddedToLibrary(0);
    } else {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å —Ç—Ä–µ–∫");
    }
}

void SearchMusicPage::onNetworkError(const QString& error)
{
    m_loadingLabel->hide();
    QMessageBox::critical(this, "–û—à–∏–±–∫–∞ —Å–µ—Ç–∏", error);
}


=== DanilKurs/src/gui/MainWindow/pages/RoomsPage.cpp ===
#include "RoomsPage.h"
#include "network/RoomManager.h"
#include "network/WebSocketClient.h"
#include "gui/widgets/RoomCard.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QLabel>
#include <QInputDialog>
#include <QMessageBox>
#include <QScrollArea>

RoomsPage::RoomsPage(int userId, QWidget *parent)
    : QWidget(parent)
    , m_userId(userId)
    , m_currentRoomId(-1)
    , m_roomManager(new RoomManager(userId, this))
    , m_wsClient(new WebSocketClient(userId, this))
{
    setupUI();
    
    connect(m_roomManager, &RoomManager::roomJoined, [this](int roomId) {
        m_currentRoomId = roomId;
        m_wsClient->joinRoom(roomId);
    });
    
    connect(m_roomManager, &RoomManager::roomLeft, [this](int roomId) {
        m_wsClient->leaveRoom(roomId);
        m_currentRoomId = -1;
    });
    
    m_wsClient->connectToServer("ws://localhost:8080");
    
    loadRooms();
}

RoomsPage::~RoomsPage()
{
    if (m_currentRoomId != -1) {
        m_roomManager->leaveRoom(m_currentRoomId);
    }
}

void RoomsPage::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(40, 40, 40, 40);
    mainLayout->setSpacing(25);
    
    QLabel* titleLabel = new QLabel("–ö–æ–º–Ω–∞—Ç—ã");
    titleLabel->setStyleSheet("color: white; font-size: 32px; font-weight: bold;");
    mainLayout->addWidget(titleLabel);
    
    QWidget* controlsWidget = new QWidget();
    QHBoxLayout* controlsLayout = new QHBoxLayout(controlsWidget);
    controlsLayout->setContentsMargins(0, 0, 0, 0);
    
    m_searchInput = new QLineEdit();
    m_searchInput->setPlaceholderText("–ü–æ–∏—Å–∫ –∫–æ–º–Ω–∞—Ç...");
    m_searchInput->setMinimumHeight(45);
    m_searchInput->setStyleSheet(R"(
        QLineEdit {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 0 20px;
            color: white;
            font-size: 14px;
        }
        QLineEdit:focus {
            border: 2px solid #8A2BE2;
        }
    )");
    
    m_createButton = new QPushButton("–°–æ–∑–¥–∞—Ç—å –∫–æ–º–Ω–∞—Ç—É");
    m_createButton->setMinimumHeight(45);
    m_createButton->setFixedWidth(180);
    m_createButton->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");
    
    controlsLayout->addWidget(m_searchInput);
    controlsLayout->addWidget(m_createButton);
    
    mainLayout->addWidget(controlsWidget);
    
    m_scrollArea = new QScrollArea();
    m_scrollArea->setWidgetResizable(true);
    m_scrollArea->setStyleSheet(R"(
        QScrollArea {
            background: transparent;
            border: none;
        }
        QScrollBar:vertical {
            background: rgba(255, 255, 255, 0.05);
            width: 8px;
            border-radius: 4px;
        }
        QScrollBar::handle:vertical {
            background: rgba(138, 43, 226, 0.5);
            border-radius: 4px;
        }
    )");
    
    m_roomsContainer = new QWidget();
    m_scrollArea->setWidget(m_roomsContainer);
    
    mainLayout->addWidget(m_scrollArea);
    
    connect(m_createButton, &QPushButton::clicked, this, &RoomsPage::onCreateRoom);
    connect(m_searchInput, &QLineEdit::textChanged, this, &RoomsPage::onSearchRooms);
}

void RoomsPage::loadRooms()
{
    QVector<Room> rooms = m_roomManager->getPublicRooms();
    displayRooms(rooms);
}

void RoomsPage::displayRooms(const QVector<Room>& rooms)
{
    if (m_roomsContainer->layout()) {
        QLayoutItem* item;
        while ((item = m_roomsContainer->layout()->takeAt(0)) != nullptr) {
            delete item->widget();
            delete item;
        }
        delete m_roomsContainer->layout();
    }
    
    QGridLayout* gridLayout = new QGridLayout(m_roomsContainer);
    gridLayout->setSpacing(20);
    gridLayout->setContentsMargins(0, 0, 0, 0);
    
    for (int i = 0; i < rooms.size(); ++i) {
        RoomCard* card = new RoomCard(rooms[i]);
        connect(card, &RoomCard::joinClicked, this, &RoomsPage::onJoinRoom);
        
        int row = i / 2;
        int col = i % 2;
        gridLayout->addWidget(card, row, col);
    }
    
    gridLayout->setRowStretch(gridLayout->rowCount(), 1);
}

void RoomsPage::onCreateRoom()
{
    openRoomDialog();
}

void RoomsPage::openRoomDialog()
{
    bool ok;
    QString name = QInputDialog::getText(
        this,
        "–°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–º–Ω–∞—Ç—ã",
        "–ù–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–Ω–∞—Ç—ã:",
        QLineEdit::Normal,
        "",
        &ok
    );
    
    if (!ok || name.isEmpty()) return;
    
    QString genre = QInputDialog::getText(
        this,
        "–°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–º–Ω–∞—Ç—ã",
        "–ñ–∞–Ω—Ä:",
        QLineEdit::Normal,
        "",
        &ok
    );
    
    if (!ok) return;
    
    int maxMembers = QInputDialog::getInt(
        this,
        "–°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–º–Ω–∞—Ç—ã",
        "–ú–∞–∫—Å–∏–º—É–º —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤:",
        10, 2, 100, 1,
        &ok
    );
    
    if (!ok) return;
    
    int roomId = m_roomManager->createRoom(name, "", genre, maxMembers, false);
    
    if (roomId != -1) {
        QMessageBox::information(this, "–£—Å–ø–µ—Ö", "–ö–æ–º–Ω–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∞!");
        loadRooms();
    } else {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∫–æ–º–Ω–∞—Ç—É");
    }
}

void RoomsPage::onJoinRoom(int roomId)
{
    if (m_roomManager->joinRoom(roomId)) {
        QMessageBox::information(this, "–£—Å–ø–µ—Ö", "–í—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª–∏—Å—å –∫ –∫–æ–º–Ω–∞—Ç–µ!");
    } else {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è");
    }
}

void RoomsPage::onLeaveRoom()
{
    if (m_currentRoomId != -1) {
        m_roomManager->leaveRoom(m_currentRoomId);
    }
}

void RoomsPage::onSearchRooms(const QString& query)
{
    QVector<Room> allRooms = m_roomManager->getPublicRooms();
    
    if (query.isEmpty()) {
        displayRooms(allRooms);
        return;
    }
    
    QVector<Room> filtered;
    for (const Room& room : allRooms) {
        if (room.name.contains(query, Qt::CaseInsensitive) ||
            room.genre.contains(query, Qt::CaseInsensitive)) {
            filtered.append(room);
        }
    }
    
    displayRooms(filtered);
}


=== DanilKurs/src/gui/MainWindow/pages/RoomsPage.h ===
#ifndef ROOMSPAGE_H
#define ROOMSPAGE_H

#include <QWidget>
#include <QListWidget>
#include <QPushButton>
#include <QLineEdit>
#include <QScrollArea>
#include "core/models/Room.h"

class RoomManager;
class WebSocketClient;

class RoomsPage : public QWidget
{
    Q_OBJECT

public:
    explicit RoomsPage(int userId, QWidget *parent = nullptr);
    ~RoomsPage();
    
    void loadRooms();

private slots:
    void onCreateRoom();
    void onJoinRoom(int roomId);
    void onLeaveRoom();
    void onSearchRooms(const QString& query);

private:
    void setupUI();
    void displayRooms(const QVector<Room>& rooms);
    void openRoomDialog();
    
    int m_userId;
    int m_currentRoomId;
    RoomManager* m_roomManager;
    WebSocketClient* m_wsClient;
    
    QListWidget* m_roomsList;
    QPushButton* m_createButton;
    QLineEdit* m_searchEdit;
    QLineEdit* m_searchInput;
    QScrollArea* m_scrollArea;
    QWidget* m_roomsContainer;
};

#endif




=== DanilKurs/src/gui/MainWindow/pages/MessagesPage.h ===
#ifndef MESSAGESPAGE_H
#define MESSAGESPAGE_H

#include <QWidget>
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QListWidget>
#include <QStackedWidget>
#include <QTimer>

#include "network/ChatManager.h"
#include "gui/widgets/ChatWidget.h"

class MessagesPage : public QWidget
{
    Q_OBJECT

public:
    explicit MessagesPage(int userId, QWidget *parent = nullptr);

    void openChat(int friendId, const QString& friendName);
    void refreshChats();

private slots:
    void onChatSelected(QListWidgetItem* item);
    void onBackToList();

private:
    void setupUI();
    void loadChats();

    int m_userId;
    ChatManager* m_chatManager;

    QStackedWidget* m_stackedWidget;
    QWidget* m_chatListWidget;
    QListWidget* m_chatList;
    ChatWidget* m_currentChatWidget;

    QTimer* m_refreshTimer = nullptr;
};

#endif // MESSAGESPAGE_H


=== DanilKurs/src/gui/MainWindow/pages/MyMusicPage.cpp ===
#include "MyMusicPage.h"
#include "core/managers/TrackManager.h"
#include "audio/LocalFileHandler.h"
#include "gui/widgets/TrackListItem.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QMessageBox>
#include <QMenu>
#include <QFileDialog>

MyMusicPage::MyMusicPage(int userId, QWidget *parent)
    : QWidget(parent)
    , m_userId(userId)
    , m_trackManager(new TrackManager(userId, this))
    , m_fileHandler(new LocalFileHandler(this))
{
    setupUI();
    loadTracks();
}

void MyMusicPage::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(40, 40, 40, 40);
    mainLayout->setSpacing(25);
    
    QWidget* headerWidget = new QWidget();
    QHBoxLayout* headerLayout = new QHBoxLayout(headerWidget);
    headerLayout->setContentsMargins(0, 0, 0, 0);
    
    QLabel* titleLabel = new QLabel("–ú–æ—è –º—É–∑—ã–∫–∞");
    titleLabel->setStyleSheet("color: white; font-size: 32px; font-weight: bold;");
    
    m_statsLabel = new QLabel();
    m_statsLabel->setStyleSheet("color: rgba(255, 255, 255, 0.6); font-size: 14px;");
    
    m_addButton = new QPushButton("+ –î–æ–±–∞–≤–∏—Ç—å —Ç—Ä–µ–∫–∏");
    m_addButton->setFixedHeight(45);
    m_addButton->setStyleSheet(R"(
        QPushButton { background: #8A2BE2; color: white; border: none; border-radius: 10px; padding: 0 25px; font-size: 14px; font-weight: 600; }
        QPushButton:hover { background: #9B4BFF; }
    )");
    
    m_scanButton = new QPushButton("–°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –ø–∞–ø–∫—É");
    m_scanButton->setFixedHeight(45);
    m_scanButton->setStyleSheet(R"(
        QPushButton { background: rgba(138, 43, 226, 0.2); color: #8A2BE2; border: 1px solid #8A2BE2; border-radius: 10px; padding: 0 25px; font-size: 14px; font-weight: 600; }
        QPushButton:hover { background: rgba(138, 43, 226, 0.3); }
    )");
    
    headerLayout->addWidget(titleLabel);
    headerLayout->addWidget(m_statsLabel);
    headerLayout->addStretch();
    headerLayout->addWidget(m_scanButton);
    headerLayout->addWidget(m_addButton);
    
    m_searchEdit = new QLineEdit();
    m_searchEdit->setPlaceholderText("–ü–æ–∏—Å–∫ —Ç—Ä–µ–∫–æ–≤...");
    m_searchEdit->setFixedHeight(45);
    m_searchEdit->setStyleSheet(R"(
        QLineEdit { background: rgba(255, 255, 255, 0.05); border: 2px solid rgba(255, 255, 255, 0.1); border-radius: 10px; padding: 0 15px; color: white; font-size: 14px; }
        QLineEdit:focus { border: 2px solid #8A2BE2; }
    )");
    
    m_tracksList = new QListWidget();
    m_tracksList->setStyleSheet(R"(
        QListWidget { background: rgba(255, 255, 255, 0.02); border: 2px solid rgba(255, 255, 255, 0.05); border-radius: 15px; outline: none; padding: 10px; }
        QListWidget::item { background: transparent; border: none; }
        QListWidget::item:hover { background: rgba(255, 255, 255, 0.05); border-radius: 8px; }
    )");
    m_tracksList->setContextMenuPolicy(Qt::CustomContextMenu);
    
    mainLayout->addWidget(headerWidget);
    mainLayout->addWidget(m_searchEdit);
    mainLayout->addWidget(m_tracksList);
    
    connect(m_addButton, &QPushButton::clicked, this, &MyMusicPage::onAddTrackClicked);
    connect(m_scanButton, &QPushButton::clicked, this, &MyMusicPage::onScanFolderClicked);
    connect(m_tracksList, &QListWidget::itemDoubleClicked, this, &MyMusicPage::onTrackDoubleClicked);
    connect(m_searchEdit, &QLineEdit::textChanged, this, &MyMusicPage::onSearchChanged);
    connect(m_tracksList, &QListWidget::customContextMenuRequested, this, &MyMusicPage::onTrackContextMenu);
}

void MyMusicPage::loadTracks()
{
    m_allTracks = m_trackManager->getUserTracks();
    displayTracks(m_allTracks);
    
    m_statsLabel->setText(QString("–í—Å–µ–≥–æ —Ç—Ä–µ–∫–æ–≤: %1").arg(m_allTracks.size()));
}

void MyMusicPage::displayTracks(const QVector<TrackData>& tracks)
{
    m_tracksList->clear();
    
    if (tracks.isEmpty()) {
        QLabel* emptyLabel = new QLabel("–ù–µ—Ç —Ç—Ä–µ–∫–æ–≤. –î–æ–±–∞–≤—å—Ç–µ –º—É–∑—ã–∫—É —Å –ø–æ–º–æ—â—å—é –∫–Ω–æ–ø–∫–∏ –≤—ã—à–µ.");
        emptyLabel->setStyleSheet("color: rgba(255, 255, 255, 0.5); font-size: 16px;");
        emptyLabel->setAlignment(Qt::AlignCenter);
        
        QListWidgetItem* item = new QListWidgetItem(m_tracksList);
        item->setSizeHint(QSize(0, 100));
        m_tracksList->setItemWidget(item, emptyLabel);
        return;
    }
    
    for (const TrackData& track : tracks) {
        QListWidgetItem* item = new QListWidgetItem(m_tracksList);
        item->setData(Qt::UserRole, track.id);
        
        TrackListItem* trackWidget = new TrackListItem(track, true);
        
        connect(trackWidget, &TrackListItem::playClicked, [this, track]() {
            emit playTrackRequested(track);
        });
        
        item->setSizeHint(trackWidget->sizeHint());
        m_tracksList->setItemWidget(item, trackWidget);
    }
}

void MyMusicPage::onAddTrackClicked()
{
    QStringList files = QFileDialog::getOpenFileNames(
        this,
        "–í—ã–±–µ—Ä–∏—Ç–µ –∞—É–¥–∏–æ—Ñ–∞–π–ª—ã",
        QDir::homePath(),
        "Audio Files (*.mp3 *.wav *.flac *.ogg *.m4a)"
    );
    
    if (files.isEmpty()) return;
    
    int added = 0;
    for (const QString& filePath : files) {
        if (m_fileHandler->addTrackToDatabase(m_userId, filePath)) {
            added++;
        }
    }
    
    if (added > 0) {
        QMessageBox::information(this, "–£—Å–ø–µ—Ö", QString("–î–æ–±–∞–≤–ª–µ–Ω–æ —Ç—Ä–µ–∫–æ–≤: %1").arg(added));
        loadTracks();
    }
}

void MyMusicPage::onScanFolderClicked()
{
    QString directory = QFileDialog::getExistingDirectory(
        this,
        "–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞–ø–∫—É —Å –º—É–∑—ã–∫–æ–π",
        QDir::homePath()
    );
    
    if (directory.isEmpty()) return;
    
    if (m_fileHandler->scanDirectory(m_userId, directory)) {
        QMessageBox::information(this, "–£—Å–ø–µ—Ö", "–ü–∞–ø–∫–∞ –ø—Ä–æ—Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∞");
        loadTracks();
    } else {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ù–µ –Ω–∞–π–¥–µ–Ω–æ –∞—É–¥–∏–æ—Ñ–∞–π–ª–æ–≤");
    }
}

void MyMusicPage::onTrackDoubleClicked(QListWidgetItem* item)
{
    int trackId = item->data(Qt::UserRole).toInt();
    
    for (const TrackData& track : m_allTracks) {
        if (track.id == trackId) {
            emit playTrackRequested(track);
            break;
        }
    }
}

void MyMusicPage::onSearchChanged(const QString& text)
{
    if (text.isEmpty()) {
        displayTracks(m_allTracks);
        return;
    }
    
    QVector<TrackData> filtered;
    for (const TrackData& track : m_allTracks) {
        if (track.title.contains(text, Qt::CaseInsensitive) ||
            track.artist.contains(text, Qt::CaseInsensitive) ||
            track.album.contains(text, Qt::CaseInsensitive)) {
            filtered.append(track);
        }
    }
    
    displayTracks(filtered);
}

void MyMusicPage::onTrackContextMenu(const QPoint& pos)
{
    QListWidgetItem* item = m_tracksList->itemAt(pos);
    
    int trackId = item->data(Qt::UserRole).toInt();
    
    QMenu menu(this);
    menu.setStyleSheet(R"(
        QMenu { background: #1A1A21; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 5px; }
        QMenu::item { background: transparent; color: white; padding: 8px 20px; border-radius: 4px; }
        QMenu::item:selected { background: rgba(138, 43, 226, 0.3); }
    )");
    
    QAction* deleteAction = menu.addAction("–£–¥–∞–ª–∏—Ç—å");
    
    QAction* selected = menu.exec(m_tracksList->mapToGlobal(pos));
    
    if (selected == deleteAction) {
        onDeleteTrack(trackId);
    }
}

void MyMusicPage::onDeleteTrack(int trackId)
{
    if (m_trackManager->deleteTrack(trackId)) {
        QMessageBox::information(this, "–£—Å–ø–µ—Ö", "–¢—Ä–µ–∫ —É–¥–∞–ª–µ–Ω");
        loadTracks();
    }
}


=== DanilKurs/src/gui/MainWindow/pages/ProfilePage.h ===
#ifndef PROFILEPAGE_H
#define PROFILEPAGE_H

#include <QWidget>
#include <QLabel>
#include <QLineEdit>
#include <QPushButton>
#include <QTextEdit>
#include "core/models/User.h"

class UserManager;

class ProfilePage : public QWidget
{
    Q_OBJECT

public:
    explicit ProfilePage(int userId, QWidget *parent = nullptr);
    ~ProfilePage();

private slots:
    void onChangeAvatar();
    void onSaveProfile();
    void onChangePassword();

private:
    void setupUI();
    void loadUserData();
    void updateAvatar(const QPixmap& avatar);
    
    int m_userId;
    UserManager* m_userManager;
    
    QLabel* m_avatarLabel;
    QPushButton* m_changeAvatarButton;
    QLineEdit* m_usernameInput;
    QLineEdit* m_emailInput;
    QTextEdit* m_bioInput;
    QPushButton* m_saveButton;
    QPushButton* m_changePasswordButton;
    QLabel* m_statsLabel;
};

#endif


=== DanilKurs/src/gui/MainWindow/pages/ProfilePage.cpp ===
#include "ProfilePage.h"
#include "core/models/Track.h"
#include "core/managers/UserManager.h"
#include "database/DatabaseManager.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QFileDialog>
#include <QMessageBox>
#include <QInputDialog>
#include <QPainter>
#include <QPainterPath>

ProfilePage::ProfilePage(int userId, QWidget *parent)
    : QWidget(parent)
    , m_userId(userId)
    , m_userManager(new UserManager(this))
{
    setupUI();
    loadUserData();
}

ProfilePage::~ProfilePage()
{
}

void ProfilePage::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(40, 40, 40, 40);
    mainLayout->setSpacing(30);
    
    QLabel* titleLabel = new QLabel("–ü—Ä–æ—Ñ–∏–ª—å");
    titleLabel->setStyleSheet("color: white; font-size: 32px; font-weight: bold;");
    mainLayout->addWidget(titleLabel);
    
    QWidget* contentWidget = new QWidget();
    contentWidget->setMaximumWidth(600);
    QVBoxLayout* contentLayout = new QVBoxLayout(contentWidget);
    contentLayout->setSpacing(25);
    
    QWidget* avatarSection = new QWidget();
    QVBoxLayout* avatarLayout = new QVBoxLayout(avatarSection);
    avatarLayout->setAlignment(Qt::AlignCenter);
    avatarLayout->setSpacing(15);
    
    m_avatarLabel = new QLabel();
    m_avatarLabel->setFixedSize(150, 150);
    m_avatarLabel->setStyleSheet(R"(
        border: 3px solid #8A2BE2;
        border-radius: 75px;
        background: rgba(138, 43, 226, 0.1);
    )");
    m_avatarLabel->setAlignment(Qt::AlignCenter);
    
    m_changeAvatarButton = new QPushButton("–ò–∑–º–µ–Ω–∏—Ç—å –∞–≤–∞—Ç–∞—Ä");
    m_changeAvatarButton->setFixedWidth(180);
    m_changeAvatarButton->setStyleSheet(R"(
        QPushButton {
            background: rgba(138, 43, 226, 0.2);
            border: 1px solid #8A2BE2;
            color: #8A2BE2;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: rgba(138, 43, 226, 0.3);
        }
    )");
    
    avatarLayout->addWidget(m_avatarLabel);
    avatarLayout->addWidget(m_changeAvatarButton);
    
    contentLayout->addWidget(avatarSection);
    
    QWidget* formWidget = new QWidget();
    QVBoxLayout* formLayout = new QVBoxLayout(formWidget);
    formLayout->setSpacing(15);
    
    QLabel* usernameLabel = new QLabel("–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è");
    usernameLabel->setStyleSheet("color: rgba(255, 255, 255, 0.7); font-size: 14px;");
    
    m_usernameInput = new QLineEdit();
    m_usernameInput->setReadOnly(true);
    m_usernameInput->setStyleSheet(R"(
        QLineEdit {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 12px 15px;
            color: white;
            font-size: 14px;
        }
    )");
    
    QLabel* emailLabel = new QLabel("Email");
    emailLabel->setStyleSheet("color: rgba(255, 255, 255, 0.7); font-size: 14px;");
    
    m_emailInput = new QLineEdit();
    m_emailInput->setStyleSheet(R"(
        QLineEdit {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 12px 15px;
            color: white;
            font-size: 14px;
        }
        QLineEdit:focus {
            border: 2px solid #8A2BE2;
        }
    )");
    
    QLabel* bioLabel = new QLabel("–û —Å–µ–±–µ");
    bioLabel->setStyleSheet("color: rgba(255, 255, 255, 0.7); font-size: 14px;");
    
    m_bioInput = new QTextEdit();
    m_bioInput->setMaximumHeight(120);
    m_bioInput->setStyleSheet(R"(
        QTextEdit {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 12px 15px;
            color: white;
            font-size: 14px;
        }
        QTextEdit:focus {
            border: 2px solid #8A2BE2;
        }
    )");
    
    formLayout->addWidget(usernameLabel);
    formLayout->addWidget(m_usernameInput);
    formLayout->addWidget(emailLabel);
    formLayout->addWidget(m_emailInput);
    formLayout->addWidget(bioLabel);
    formLayout->addWidget(m_bioInput);
    
    contentLayout->addWidget(formWidget);
    
    m_statsLabel = new QLabel();
    m_statsLabel->setStyleSheet(R"(
        background: rgba(138, 43, 226, 0.1);
        border: 1px solid rgba(138, 43, 226, 0.3);
        border-radius: 10px;
        padding: 15px;
        color: white;
        font-size: 13px;
    )");
    contentLayout->addWidget(m_statsLabel);
    
    QWidget* buttonsWidget = new QWidget();
    QHBoxLayout* buttonsLayout = new QHBoxLayout(buttonsWidget);
    buttonsLayout->setSpacing(15);
    
    m_saveButton = new QPushButton("–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è");
    m_saveButton->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 10px;
            padding: 12px 30px;
            font-weight: 600;
            font-size: 14px;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");
    
    m_changePasswordButton = new QPushButton("–ò–∑–º–µ–Ω–∏—Ç—å –ø–∞—Ä–æ–ª—å");
    m_changePasswordButton->setStyleSheet(R"(
        QPushButton {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 12px 30px;
            font-weight: 600;
            font-size: 14px;
        }
        QPushButton:hover {
            background: rgba(255, 255, 255, 0.15);
        }
    )");
    
    buttonsLayout->addWidget(m_saveButton);
    buttonsLayout->addWidget(m_changePasswordButton);
    buttonsLayout->addStretch();
    
    contentLayout->addWidget(buttonsWidget);
    
    mainLayout->addWidget(contentWidget);
    mainLayout->addStretch();
    
    connect(m_changeAvatarButton, &QPushButton::clicked, this, &ProfilePage::onChangeAvatar);
    connect(m_saveButton, &QPushButton::clicked, this, &ProfilePage::onSaveProfile);
    connect(m_changePasswordButton, &QPushButton::clicked, this, &ProfilePage::onChangePassword);
}

void ProfilePage::loadUserData()
{
    User user = m_userManager->getUser(m_userId);
    
    if (user.id == -1) return;
    
    m_usernameInput->setText(user.username);
    m_emailInput->setText(user.email);
    m_bioInput->setText(user.bio);
    
    if (!user.avatarPath.isEmpty()) {
        QPixmap avatar(user.avatarPath);
        if (!avatar.isNull()) {
            updateAvatar(avatar);
        } else {
            m_avatarLabel->setText(user.username.left(1).toUpper());
            m_avatarLabel->setStyleSheet(m_avatarLabel->styleSheet() + 
                "font-size: 60px; font-weight: bold; color: white;");
        }
    } else {
        m_avatarLabel->setText(user.username.left(1).toUpper());
        m_avatarLabel->setStyleSheet(m_avatarLabel->styleSheet() + 
            "font-size: 60px; font-weight: bold; color: white;");
    }
    
    QList<TrackData> tracks = DatabaseManager::instance().getUserTracks(m_userId);
    int totalTracks = tracks.size();
    int totalPlayCount = 0;
    
    for (const TrackData& track : tracks) {
        totalPlayCount += track.playCount;
    }
    
    QString stats = QString(
        "<b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b><br>"
        "–¢—Ä–µ–∫–æ–≤ –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫–µ: %1<br>"
        "–í—Å–µ–≥–æ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–π: %2<br>"
        "–ê–∫–∫–∞—É–Ω—Ç —Å–æ–∑–¥–∞–Ω: %3"
    ).arg(totalTracks).arg(totalPlayCount).arg(user.createdAt.toString("dd.MM.yyyy"));
    
    m_statsLabel->setText(stats);
}

void ProfilePage::updateAvatar(const QPixmap& avatar)
{
    QPixmap scaled = avatar.scaled(150, 150, Qt::KeepAspectRatioByExpanding, Qt::SmoothTransformation);
    
    QPixmap rounded(150, 150);
    rounded.fill(Qt::transparent);
    
    QPainter painter(&rounded);
    painter.setRenderHint(QPainter::Antialiasing);
    
    QPainterPath path;
    path.addEllipse(0, 0, 150, 150);
    painter.setClipPath(path);
    
    painter.drawPixmap(0, 0, scaled);
    
    m_avatarLabel->setPixmap(rounded);
}

void ProfilePage::onChangeAvatar()
{
    QString fileName = QFileDialog::getOpenFileName(
        this,
        "–í—ã–±–µ—Ä–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ",
        QDir::homePath(),
        "Images (*.png *.jpg *.jpeg *.bmp)"
    );
    
    if (fileName.isEmpty()) return;
    
    QPixmap avatar(fileName);
    if (avatar.isNull()) {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ");
        return;
    }
    
    QString avatarDir = "avatars";
    QDir().mkpath(avatarDir);
    
    QString avatarPath = QString("%1/user_%2.png").arg(avatarDir).arg(m_userId);
    
    if (avatar.save(avatarPath)) {
        if (m_userManager->updateAvatar(m_userId, avatarPath)) {
            updateAvatar(avatar);
            QMessageBox::information(this, "–£—Å–ø–µ—Ö", "–ê–≤–∞—Ç–∞—Ä –æ–±–Ω–æ–≤–ª–µ–Ω!");
        }
    }
}

void ProfilePage::onSaveProfile()
{
    QString email = m_emailInput->text().trimmed();
    QString bio = m_bioInput->toPlainText().trimmed();
    
    bool success = true;
    
    if (!email.isEmpty()) {
        success = success && m_userManager->updateEmail(m_userId, email);
    }
    
    success = success && m_userManager->updateBio(m_userId, bio);
    
    if (success) {
        QMessageBox::information(this, "–£—Å–ø–µ—Ö", "–ü—Ä–æ—Ñ–∏–ª—å –æ–±–Ω–æ–≤–ª–µ–Ω!");
    } else {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å");
    }
}

void ProfilePage::onChangePassword()
{
    bool ok;
    QString oldPassword = QInputDialog::getText(
        this,
        "–°–º–µ–Ω–∞ –ø–∞—Ä–æ–ª—è",
        "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—É—â–∏–π –ø–∞—Ä–æ–ª—å:",
        QLineEdit::Password,
        "",
        &ok
    );
    
    if (!ok || oldPassword.isEmpty()) return;
    
    QString newPassword = QInputDialog::getText(
        this,
        "–°–º–µ–Ω–∞ –ø–∞—Ä–æ–ª—è",
        "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –ø–∞—Ä–æ–ª—å (–º–∏–Ω–∏–º—É–º 6 —Å–∏–º–≤–æ–ª–æ–≤):",
        QLineEdit::Password,
        "",
        &ok
    );
    
    if (!ok || newPassword.length() < 6) {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 6 —Å–∏–º–≤–æ–ª–æ–≤");
        return;
    }
    
    QString confirmPassword = QInputDialog::getText(
        this,
        "–°–º–µ–Ω–∞ –ø–∞—Ä–æ–ª—è",
        "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –Ω–æ–≤—ã–π –ø–∞—Ä–æ–ª—å:",
        QLineEdit::Password,
        "",
        &ok
    );
    
    if (!ok || newPassword != confirmPassword) {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ü–∞—Ä–æ–ª–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç");
        return;
    }
    
    QMessageBox::information(this, "–£—Å–ø–µ—Ö", "–ü–∞—Ä–æ–ª—å –∏–∑–º–µ–Ω–µ–Ω!");
}


=== DanilKurs/src/gui/MainWindow/pages/FriendsPage.h ===
#ifndef FRIENDSPAGE_H
#define FRIENDSPAGE_H

#include <QWidget>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLineEdit>
#include <QPushButton>
#include <QScrollArea>
#include <QStackedWidget>
#include "network/FriendManager.h"

class FriendsPage : public QWidget
{
    Q_OBJECT

public:
    explicit FriendsPage(int userId, QWidget *parent = nullptr);
    
    void refreshData();

signals:
    void openChatWithFriend(int friendId, const QString& friendName);

private slots:
    void onSearchClicked();
    void onShowFriends();
    void onShowRequests();
    void onAddFriend(int userId);
    void onAcceptRequest(int userId);
    void onRejectRequest(int userId);
    void onRemoveFriend(int userId);
    void onMessageFriend(int userId);

private:
    void setupUI();
    void loadFriends();
    void loadRequests();
    void searchUsers();
    void displaySearchResults(const QVector<User>& users);
    
    int m_userId;
    FriendManager* m_friendManager;
    
    QLineEdit* m_searchInput;
    QPushButton* m_friendsBtn;
    QPushButton* m_requestsBtn;
    QStackedWidget* m_stackedWidget;
    QScrollArea* m_friendsWidget;
    QScrollArea* m_requestsWidget;
    QScrollArea* m_searchWidget;
    QVBoxLayout* m_friendsLayout;
    QVBoxLayout* m_requestsLayout;
    QVBoxLayout* m_searchLayout;
};

#endif


=== DanilKurs/src/gui/MainWindow/pages/MyMusicPage.h ===
#ifndef MYMUSICPAGE_H
#define MYMUSICPAGE_H

#include <QWidget>
#include <QListWidget>
#include <QPushButton>
#include <QLineEdit>
#include <QLabel>
#include "core/models/Track.h"

class TrackManager;
class LocalFileHandler;

class MyMusicPage : public QWidget
{
    Q_OBJECT

public:
    explicit MyMusicPage(int userId, QWidget *parent = nullptr);
    
    void loadTracks();

signals:
    void playTrackRequested(const TrackData& track);

private slots:
    void onAddTrackClicked();
    void onScanFolderClicked();
    void onTrackDoubleClicked(QListWidgetItem* item);
    void onSearchChanged(const QString& text);
    void onTrackContextMenu(const QPoint& pos);
    void onDeleteTrack(int trackId);

private:
    void setupUI();
    void displayTracks(const QVector<TrackData>& tracks);
    
    int m_userId;
    TrackManager* m_trackManager;
    LocalFileHandler* m_fileHandler;
    
    QListWidget* m_tracksList;
    QPushButton* m_addButton;
    QPushButton* m_scanButton;
    QLineEdit* m_searchEdit;
    QLabel* m_statsLabel;
    
    QVector<TrackData> m_allTracks;
};

#endif


=== DanilKurs/src/gui/MainWindow/pages/PlaylistsPage.h ===
#ifndef PLAYLISTPAGE_H
#define PLAYLISTPAGE_H

#include <QWidget>
#include <QListWidget>
#include <QPushButton>
#include <QLabel>
#include <QVector>
#include "core/models/Playlist.h"
#include "core/models/Track.h"

class PlaylistManager;

class PlaylistPage : public QWidget
{
    Q_OBJECT

public:
    explicit PlaylistPage(int userId, QWidget *parent = nullptr);
    ~PlaylistPage();
    
    void loadPlaylists();

signals:
    void playTrackRequested(const TrackData& track);

private slots:
    void onCreatePlaylist();
    void onPlaylistSelected(QListWidgetItem* item);
    void onTrackDoubleClicked(QListWidgetItem* item);
    void onBackToPlaylists();

private:
    void setupUI();
    void displayPlaylists(const QVector<Playlist>& playlists);
    void displayPlaylistTracks(int playlistId);
    void showPlaylistsView();
    void showTracksView();
    
    int m_userId;
    int m_currentPlaylistId;
    PlaylistManager* m_playlistManager;
    
    QWidget* m_playlistsWidget;
    QWidget* m_tracksWidget;
    QListWidget* m_playlistsList;
    QListWidget* m_tracksList;
    QPushButton* m_createButton;
    QPushButton* m_backButton;
    QLabel* m_playlistTitleLabel;
};

#endif


=== DanilKurs/src/gui/MainWindow/pages/SearchMusicPage.h ===
#ifndef SEARCHMUSICPAGE_H
#define SEARCHMUSICPAGE_H

#include <QWidget>
#include <QLabel>
#include <QLineEdit>
#include <QPushButton>
#include <QListWidget>
#include <QTextEdit>
#include <QVector>
#include <QVariantMap>

class MusicAPIManager;

class SearchMusicPage : public QWidget
{
    Q_OBJECT

public:
    explicit SearchMusicPage(int userId, QWidget *parent = nullptr);
    ~SearchMusicPage();

private slots:
    void onSearchClicked();
    void onTopTracksClicked();
    void onTracksFound(const QVariantList& tracks);
    void onTrackSelected(QListWidgetItem* item);
    void onTrackContextMenu(const QPoint& pos);
    void onNetworkError(const QString& error);

signals:
    void trackAddedToLibrary(int trackId);

private:
    void setupUI();
    void displayTracks(const QVariantList& tracks);
    void displayTrackInfo(const QVariantMap& track);
    void addTrackToLibrary(const QVariantMap& track);
    
    int m_userId;
    MusicAPIManager* m_apiManager;
    QVariantList m_currentTracks;
    
    QLineEdit* m_searchInput;
    QPushButton* m_searchButton;
    QPushButton* m_topTracksButton;
    QListWidget* m_tracksList;
    QTextEdit* m_trackInfo;
    QLabel* m_loadingLabel;
};

#endif


=== DanilKurs/src/gui/MainWindow/pages/PlaylistsPage.cpp ===
#include "PlaylistsPage.h"
#include "core/managers/PlaylistManager.h"
#include "gui/widgets/TrackListItem.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QInputDialog>
#include <QMessageBox>
#include <QMenu>
#include <QStackedWidget>

PlaylistPage::PlaylistPage(int userId, QWidget *parent)
    : QWidget(parent)
    , m_userId(userId)
    , m_currentPlaylistId(-1)
    , m_playlistManager(new PlaylistManager(userId, this))
{
    setupUI();
    loadPlaylists();
    
    connect(m_playlistManager, &PlaylistManager::playlistCreated, [this](int) {
        loadPlaylists();
    });
}

PlaylistPage::~PlaylistPage()
{
}

void PlaylistPage::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);
    
    QStackedWidget* stackedWidget = new QStackedWidget();
    
    m_playlistsWidget = new QWidget();
    QVBoxLayout* playlistsLayout = new QVBoxLayout(m_playlistsWidget);
    playlistsLayout->setContentsMargins(40, 40, 40, 40);
    playlistsLayout->setSpacing(25);
    
    QWidget* headerWidget = new QWidget();
    QHBoxLayout* headerLayout = new QHBoxLayout(headerWidget);
    headerLayout->setContentsMargins(0, 0, 0, 0);
    
    QLabel* titleLabel = new QLabel("–ü–ª–µ–π–ª–∏—Å—Ç—ã");
    titleLabel->setStyleSheet("color: white; font-size: 32px; font-weight: bold;");
    
    m_createButton = new QPushButton("+ –°–æ–∑–¥–∞—Ç—å –ø–ª–µ–π–ª–∏—Å—Ç");
    m_createButton->setFixedHeight(45);
    m_createButton->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 10px;
            padding: 0 25px;
            font-size: 14px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");
    
    headerLayout->addWidget(titleLabel);
    headerLayout->addStretch();
    headerLayout->addWidget(m_createButton);
    
    m_playlistsList = new QListWidget();
    m_playlistsList->setStyleSheet(R"(
        QListWidget {
            background: transparent;
            border: none;
            outline: none;
        }
        QListWidget::item {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 10px;
        }
        QListWidget::item:hover {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(138, 43, 226, 0.3);
        }
        QListWidget::item:selected {
            background: rgba(138, 43, 226, 0.15);
            border: 1px solid #8A2BE2;
        }
    )");
    
    playlistsLayout->addWidget(headerWidget);
    playlistsLayout->addWidget(m_playlistsList);
    
    m_tracksWidget = new QWidget();
    QVBoxLayout* tracksLayout = new QVBoxLayout(m_tracksWidget);
    tracksLayout->setContentsMargins(40, 40, 40, 40);
    tracksLayout->setSpacing(25);
    
    QWidget* tracksHeaderWidget = new QWidget();
    QHBoxLayout* tracksHeaderLayout = new QHBoxLayout(tracksHeaderWidget);
    tracksHeaderLayout->setContentsMargins(0, 0, 0, 0);
    
    m_backButton = new QPushButton("‚Üê –ù–∞–∑–∞–¥");
    m_backButton->setStyleSheet(R"(
        QPushButton {
            background: transparent;
            color: rgba(255, 255, 255, 0.7);
            border: none;
            font-size: 14px;
            padding: 10px;
        }
        QPushButton:hover {
            color: white;
        }
    )");
    
    m_playlistTitleLabel = new QLabel();
    m_playlistTitleLabel->setStyleSheet("color: white; font-size: 28px; font-weight: bold;");
    
    tracksHeaderLayout->addWidget(m_backButton);
    tracksHeaderLayout->addWidget(m_playlistTitleLabel);
    tracksHeaderLayout->addStretch();
    
    m_tracksList = new QListWidget();
    m_tracksList->setStyleSheet(R"(
        QListWidget {
            background: rgba(255, 255, 255, 0.02);
            border: 2px solid rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            outline: none;
            padding: 10px;
        }
        QListWidget::item {
            background: transparent;
            border: none;
        }
        QListWidget::item:hover {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }
    )");
    
    tracksLayout->addWidget(tracksHeaderWidget);
    tracksLayout->addWidget(m_tracksList);
    
    stackedWidget->addWidget(m_playlistsWidget);
    stackedWidget->addWidget(m_tracksWidget);
    
    mainLayout->addWidget(stackedWidget);
    
    connect(m_createButton, &QPushButton::clicked, this, &PlaylistPage::onCreatePlaylist);
    connect(m_playlistsList, &QListWidget::itemDoubleClicked, this, &PlaylistPage::onPlaylistSelected);
    connect(m_tracksList, &QListWidget::itemDoubleClicked, this, &PlaylistPage::onTrackDoubleClicked);
    connect(m_backButton, &QPushButton::clicked, this, &PlaylistPage::onBackToPlaylists);
}

void PlaylistPage::loadPlaylists()
{
    QVector<Playlist> playlists = m_playlistManager->getUserPlaylists();
    displayPlaylists(playlists);
}

void PlaylistPage::displayPlaylists(const QVector<Playlist>& playlists)
{
    m_playlistsList->clear();
    
    for (const Playlist& playlist : playlists) {
        QListWidgetItem* item = new QListWidgetItem();
        item->setData(Qt::UserRole, playlist.id);
        
        QString displayText = QString("üìÅ  %1\n%2")
            .arg(playlist.name)
            .arg(playlist.createdAt);
        
        item->setText(displayText);
        item->setSizeHint(QSize(0, 80));
        
        m_playlistsList->addItem(item);
    }
}

void PlaylistPage::onCreatePlaylist()
{
    bool ok;
    QString name = QInputDialog::getText(
        this,
        "–°–æ–∑–¥–∞—Ç—å –ø–ª–µ–π–ª–∏—Å—Ç",
        "–ù–∞–∑–≤–∞–Ω–∏–µ –ø–ª–µ–π–ª–∏—Å—Ç–∞:",
        QLineEdit::Normal,
        "",
        &ok
    );
    
    if (!ok || name.isEmpty()) return;
    
    QString description = QInputDialog::getText(
        this,
        "–°–æ–∑–¥–∞—Ç—å –ø–ª–µ–π–ª–∏—Å—Ç",
        "–û–ø–∏—Å–∞–Ω–∏–µ (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ):",
        QLineEdit::Normal,
        "",
        &ok
    );
    
    int playlistId = m_playlistManager->createPlaylist(name, description);
    
    if (playlistId != -1) {
        QMessageBox::information(this, "–£—Å–ø–µ—Ö", "–ü–ª–µ–π–ª–∏—Å—Ç —Å–æ–∑–¥–∞–Ω!");
        loadPlaylists();
    } else {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –ø–ª–µ–π–ª–∏—Å—Ç");
    }
}

void PlaylistPage::onPlaylistSelected(QListWidgetItem* item)
{
    int playlistId = item->data(Qt::UserRole).toInt();
    m_currentPlaylistId = playlistId;
    
    Playlist playlist = m_playlistManager->getPlaylist(playlistId);
    m_playlistTitleLabel->setText(playlist.name);
    
    displayPlaylistTracks(playlistId);
    showTracksView();
}

void PlaylistPage::displayPlaylistTracks(int playlistId)
{
    m_tracksList->clear();
    
    QVector<TrackData> tracks = m_playlistManager->getPlaylistTracks(playlistId);
    
    if (tracks.isEmpty()) {
        QLabel* emptyLabel = new QLabel("–í —ç—Ç–æ–º –ø–ª–µ–π–ª–∏—Å—Ç–µ –ø–æ–∫–∞ –Ω–µ—Ç —Ç—Ä–µ–∫–æ–≤");
        emptyLabel->setStyleSheet("color: rgba(255, 255, 255, 0.5); font-size: 16px;");
        emptyLabel->setAlignment(Qt::AlignCenter);
        
        QListWidgetItem* item = new QListWidgetItem(m_tracksList);
        item->setSizeHint(QSize(0, 100));
        m_tracksList->setItemWidget(item, emptyLabel);
        return;
    }
    
    for (const TrackData& track : tracks) {
        QListWidgetItem* item = new QListWidgetItem(m_tracksList);
        item->setData(Qt::UserRole, track.id);
        
        TrackListItem* trackWidget = new TrackListItem(track, true);
        
        connect(trackWidget, &TrackListItem::playClicked, [this, track]() {
            emit playTrackRequested(track);
        });
        
        connect(trackWidget, &TrackListItem::moreClicked, [this, track, playlistId](int trackId, const QPoint& pos) {
            QMenu menu(this);
            menu.setStyleSheet(R"(
                QMenu {
                    background: #1A1A21;
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    border-radius: 8px;
                    padding: 5px;
                }
                QMenu::item {
                    background: transparent;
                    color: white;
                    padding: 8px 20px;
                    border-radius: 4px;
                }
                QMenu::item:selected {
                    background: rgba(138, 43, 226, 0.3);
                }
            )");
            
            QAction* playAction = menu.addAction("–í–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏");
            QAction* removeAction = menu.addAction("–£–¥–∞–ª–∏—Ç—å –∏–∑ –ø–ª–µ–π–ª–∏—Å—Ç–∞");
            
            QAction* selected = menu.exec(pos);
            
            if (selected == playAction) {
                emit playTrackRequested(track);
            } else if (selected == removeAction) {
                if (m_playlistManager->removeTrackFromPlaylist(playlistId, trackId)) {
                    displayPlaylistTracks(playlistId);
                }
            }
        });
        
        item->setSizeHint(trackWidget->sizeHint());
        m_tracksList->setItemWidget(item, trackWidget);
    }
}

void PlaylistPage::onTrackDoubleClicked(QListWidgetItem* item)
{
    int trackId = item->data(Qt::UserRole).toInt();
    
    QVector<TrackData> tracks = m_playlistManager->getPlaylistTracks(m_currentPlaylistId);
    
    for (const TrackData& track : tracks) {
        if (track.id == trackId) {
            emit playTrackRequested(track);
            break;
        }
    }
}

void PlaylistPage::onBackToPlaylists()
{
    showPlaylistsView();
}

void PlaylistPage::showPlaylistsView()
{
    QStackedWidget* stack = qobject_cast<QStackedWidget*>(layout()->itemAt(0)->widget());
    if (stack) {
        stack->setCurrentIndex(0);
    }
}

void PlaylistPage::showTracksView()
{
    QStackedWidget* stack = qobject_cast<QStackedWidget*>(layout()->itemAt(0)->widget());
    if (stack) {
        stack->setCurrentIndex(1);
    }
}


=== DanilKurs/src/gui/MainWindow/MainWindow.cpp ===
#include "MainWindow.h"
#include "pages/FriendsPage.h"
#include "pages/MessagesPage.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QStackedWidget>
#include <QLabel>
#include <QPushButton>
#include <QFrame>
#include <QLineEdit>
#include <QListWidget>
#include <QTextEdit>
#include <QListWidgetItem>
#include <QFileDialog>
#include <QMessageBox>
#include <QDir>
#include <QFile>
#include <QPixmap>
#include <QPainter>
#include <QPainterPath>
#include <QToolButton>
#include <QTimer>
#include <QApplication>
#include <QMenu>
#include <QEvent>
#include <QScrollArea>
#include <QScrollBar>
#include <QDebug>
#include <QBuffer>
#include <QBuffer>
#include <QSqlQuery>
#include <QSqlError>

#include "database/DatabaseManager.h"
#include "database/api/MusicAPIManager.h"
#include "audio/AudioPlayer.h"
#include "core/models/Track.h"

QIcon createStatusIcon(const QString& color) {
    QPixmap pixmap(8, 8);
    pixmap.fill(Qt::transparent);
    QPainter painter(&pixmap);
    painter.setRenderHint(QPainter::Antialiasing);
    painter.setBrush(QColor(color));
    painter.setPen(Qt::NoPen);
    painter.drawEllipse(0, 0, 8, 8);
    return QIcon(pixmap);
}

class TrackListWidgetItem : public QListWidgetItem {
public:
    TrackListWidgetItem(const QString& text, int trackId, QListWidget* parent = nullptr)
        : QListWidgetItem(text, parent), m_trackId(trackId) {}
    
    int trackId() const { return m_trackId; }
    
private:
    int m_trackId;
};

MainWindow::MainWindow(const QString& username, int userId, QWidget *parent)
    : FramelessWindow(parent)
    , currentUsername(username)
    , currentUserId(userId)
    , sidebar(nullptr)
    , avatarButton(nullptr)
    , avatarOverlay(nullptr)
    , usernameLabel(nullptr)
    , profileBtn(nullptr)
    , messagesBtn(nullptr)
    , friendsBtn(nullptr)
    , notificationsBtn(nullptr)
    , playlistBtn(nullptr)
    , musicSearchBtn(nullptr)
    , myMusicBtn(nullptr)
    , roomsBtn(nullptr)
    , mainStack(nullptr)
    , profilePage(nullptr)
    , messagesPage(nullptr)
    , friendsPage(nullptr)
    , notificationsPage(nullptr)
    , playlistPage(nullptr)
    , musicPage(nullptr)
    , myMusicPage(nullptr)
    , roomsPage(nullptr)
    , searchInput(nullptr)
    , searchButton(nullptr)
    , topTracksButton(nullptr)
    , tracksList(nullptr)
    , trackInfo(nullptr)
    , userTracksList(nullptr)
    , refreshTracksBtn(nullptr)
    , addLocalTrackBtn(nullptr)
    , apiManager(new MusicAPIManager(this))
    , audioPlayer(new AudioPlayer(this))
    , currentTrackIndex(-1)
{
    setupUI();
    setupConnections();
    setupAvatar(); 
    loadUserAvatar();
    loadUserTracks();
    
    setWindowTitle("Chorus - " + username);
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–µ —Å—Ç–∏–ª–∏
    QFile styleFile(":/styles/styles.css");
    if (styleFile.open(QIODevice::ReadOnly)) {
        QString styleSheet = QLatin1String(styleFile.readAll());
        setStyleSheet(styleSheet);
    }
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º eventFilter –¥–ª—è –∞–≤–∞—Ç–∞—Ä–∫–∏
    avatarButton->installEventFilter(this);
    
    // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã
    setMinimumSize(1200, 750);
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –Ω–∞—á–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä
    resize(1400, 850);
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —à—Ä–∏—Ñ—Ç
    QFont font = QApplication::font();
    font.setPointSize(10);
    QApplication::setFont(font);
}

MainWindow::~MainWindow()
{
    // –î–µ—Å—Ç—Ä—É–∫—Ç–æ—Ä MainWindow
    // Qt –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É–¥–∞–ª–∏—Ç –≤—Å–µ –¥–æ—á–µ—Ä–Ω–∏–µ –≤–∏–¥–∂–µ—Ç—ã
    // —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∏ —Å–æ–∑–¥–∞–Ω—ã —Å this –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ä–æ–¥–∏—Ç–µ–ª—è
}


bool MainWindow::eventFilter(QObject *obj, QEvent *event)
{
    if (obj == avatarButton) {
        if (event->type() == QEvent::Enter) {
            showAvatarOverlay();
            return true;
        } else if (event->type() == QEvent::Leave) {
            hideAvatarOverlay();
            return true;
        }
    }

    if (obj == avatarOverlay) {
        if (event->type() == QEvent::MouseButtonPress) {
            changeAvatar();
            hideAvatarOverlay();
            return true;
        }
    }
    
    return FramelessWindow::eventFilter(obj, event);
}
void MainWindow::onAvatarButtonEnter()
{
    showAvatarOverlay();
}

void MainWindow::onAvatarButtonLeave()
{
    hideAvatarOverlay();
}

void MainWindow::showAvatarOverlay()
{
    if (!avatarOverlay) {
        // –°–æ–∑–¥–∞–µ–º –∫–∞–∫ –¥–æ—á–µ—Ä–Ω–∏–π –≤–∏–¥–∂–µ—Ç –∫–Ω–æ–ø–∫–∏
        avatarOverlay = new QLabel(avatarButton);
        avatarOverlay->setText("–°–º–µ–Ω–∏—Ç—å\n–∞–≤–∞—Ç–∞—Ä?");
        avatarOverlay->setStyleSheet(R"(
            QLabel {
                background-color: rgba(0, 0, 0, 0.85);
                color: white;
                font-weight: 600;
                font-size: 12px;
                border-radius: 50px;
                border: 2px solid rgba(138, 43, 226, 0.5);
                text-align: center;
                padding: 5px;
            }
        )");
        avatarOverlay->setAlignment(Qt::AlignCenter);
        
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–æ—Ç –∂–µ —Ä–∞–∑–º–µ—Ä, —á—Ç–æ –∏ —É –∞–≤–∞—Ç–∞—Ä–∫–∏
        avatarOverlay->setFixedSize(100, 100);
        
        // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –≤ (0,0) –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∞–≤–∞—Ç–∞—Ä–∫–∏
        avatarOverlay->move(0, 0);
        
        // –í–∞–∂–Ω–æ: –¥–µ–ª–∞–µ–º –æ–≤–µ—Ä–ª–µ–π "–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º" –¥–ª—è —Å–æ–±—ã—Ç–∏–π –º—ã—à–∏
        avatarOverlay->setAttribute(Qt::WA_TransparentForMouseEvents);
    }
    
    avatarOverlay->show();
    avatarOverlay->raise();
}

void MainWindow::hideAvatarOverlay()
{
    if (avatarOverlay) {
        avatarOverlay->hide();
    }
}

void MainWindow::setupUI()
{
    QWidget *centralWidget = new QWidget();
    centralWidget->setObjectName("windowContent");
    centralWidget->setStyleSheet(R"(
        #windowContent {
            background-color: #0F0F14;
            border-radius: 0;
        }
    )");
    
    QVBoxLayout *mainLayout = new QVBoxLayout(centralWidget);
    mainLayout->setSpacing(0);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    
    // –ü–∞–Ω–µ–ª—å –∑–∞–≥–æ–ª–æ–≤–∫–∞
    QWidget *titleBar = new QWidget();
    titleBar->setFixedHeight(40);
    titleBar->setStyleSheet(R"(
        QWidget {
            background: rgba(15, 15, 20, 0.8);
            border-top-left-radius: 0;
            border-top-right-radius: 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
    )");
    
    QHBoxLayout *titleLayout = new QHBoxLayout(titleBar);
    titleLayout->setContentsMargins(20, 0, 20, 0);
    
    QLabel *titleLabel = new QLabel("Chorus");
    titleLabel->setStyleSheet(R"(
        QLabel {
            color: #8A2BE2;
            font-size: 16px;
            font-weight: bold;
            opacity: 0.9;
        }
    )");
    
    QWidget *windowButtons = new QWidget();
    QHBoxLayout *buttonsLayout = new QHBoxLayout(windowButtons);
    buttonsLayout->setContentsMargins(0, 0, 0, 0);
    buttonsLayout->setSpacing(5);
    
    QPushButton *minimizeBtn = new QPushButton("‚Äî");
    QPushButton *maximizeBtn = new QPushButton("‚ñ°");
    QPushButton *closeBtn = new QPushButton("√ó");
    
    QString windowBtnStyle = R"(
        QPushButton {
            background: transparent;
            color: rgba(255, 255, 255, 0.6);
            border: none;
            font-size: 16px;
            padding: 0;
            min-width: 28px;
            min-height: 28px;
            border-radius: 4px;
            font-weight: 300;
        }
        QPushButton:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        QPushButton#closeBtn:hover {
            background: #FF4444;
            color: white;
        }
    )";
    
    minimizeBtn->setStyleSheet(windowBtnStyle);
    maximizeBtn->setStyleSheet(windowBtnStyle);
    closeBtn->setStyleSheet(windowBtnStyle);
    closeBtn->setObjectName("closeBtn");
    
    buttonsLayout->addWidget(minimizeBtn);
    buttonsLayout->addWidget(maximizeBtn);
    buttonsLayout->addWidget(closeBtn);
    
    titleLayout->addWidget(titleLabel);
    titleLayout->addStretch();
    titleLayout->addWidget(windowButtons);
    
    connect(minimizeBtn, &QPushButton::clicked, this, &QMainWindow::showMinimized);
    connect(closeBtn, &QPushButton::clicked, this, &QMainWindow::close);
    connect(maximizeBtn, &QPushButton::clicked, this, [this]() {
        if (isMaximized()) {
            showNormal();
        } else {
            showMaximized();
        }
    });
    
    QHBoxLayout *contentLayout = new QHBoxLayout();
    contentLayout->setSpacing(0);
    contentLayout->setContentsMargins(0, 0, 0, 0);
    
    createSidebar();
    contentLayout->addWidget(sidebar);
    
    createPages();
    contentLayout->addWidget(mainStack, 1);
    
    mainLayout->addWidget(titleBar);
    mainLayout->addLayout(contentLayout, 1);
    
    audioPlayer->setupPlayerControls(centralWidget);
    mainLayout->addWidget(audioPlayer->getPlayerControls());
    
    setCentralWidget(centralWidget);
}

void MainWindow::createSidebar()
{
    sidebar = new QWidget();
    sidebar->setFixedWidth(280);
    sidebar->setStyleSheet(R"(
        QWidget {
            background: #0F0F14;
            border-right: 1px solid rgba(255, 255, 255, 0.05);
        }
    )");

    QVBoxLayout *sidebarLayout = new QVBoxLayout(sidebar);
    sidebarLayout->setContentsMargins(0, 0, 0, 0);
    sidebarLayout->setSpacing(0);

    // –í–µ—Ä—Ö–Ω—è—è —á–∞—Å—Ç—å: —Ç–æ–ª—å–∫–æ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ (–±–µ–∑ "Chorus")
    QWidget *logoSection = new QWidget();
    logoSection->setFixedHeight(70);
    logoSection->setStyleSheet(R"(
        QWidget {
            background: rgba(138, 43, 226, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
    )");

    QHBoxLayout *logoLayout = new QHBoxLayout(logoSection);
    logoLayout->setContentsMargins(20, 0, 20, 0);

    greetingLabel = new QLabel();
    greetingLabel->setWordWrap(true);
    greetingLabel->setStyleSheet(R"(
        QLabel {
            color: #8A2BE2;
            font-size: 18px;
            font-weight: 800;
        }
    )");
    logoLayout->addWidget(greetingLabel, 1, Qt::AlignVCenter | Qt::AlignLeft);

    sidebarLayout->addWidget(logoSection);

    // –¢–∞–π–º–µ—Ä –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–π (Qt5-safe)
    greetingMessages = QStringList()
        << QString("–ü—Ä–∏–≤–µ—Ç, %1!").arg(currentUsername)
        << "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!"
        << "–ß—Ç–æ –ø–æ—Å–ª—É—à–∞–µ–º —Å–µ–≥–æ–¥–Ω—è?"
        << "–û—Ç–∫—Ä—ã–≤–∞–π ¬´–ú–æ—è –º—É–∑—ã–∫–∞¬ª"
        << "–ü–æ–ø—Ä–æ–±—É–π –ø–æ–∏—Å–∫ —Ç—Ä–µ–∫–æ–≤";

    greetingIndex = 0;
    greetingLabel->setText(greetingMessages[greetingIndex]);

    greetingTimer = new QTimer(this);
    greetingTimer->setInterval(4000);
    connect(greetingTimer, &QTimer::timeout, this, [this]() {
        if (greetingMessages.isEmpty()) return;
        greetingIndex = (greetingIndex + 1) % greetingMessages.size();
        greetingLabel->setText(greetingMessages[greetingIndex]);
    });
    greetingTimer->start();

    // –ü—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    QWidget *profileSection = new QWidget();
    profileSection->setStyleSheet(R"(
        QWidget {
            background: transparent;
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
    )");

    QVBoxLayout *profileLayout = new QVBoxLayout(profileSection);
    profileLayout->setContentsMargins(0, 0, 0, 0);
    profileLayout->setSpacing(15);
    profileLayout->setAlignment(Qt::AlignTop);

    // –ê–≤–∞—Ç–∞—Ä
    avatarButton = new QPushButton();
    avatarButton->setFixedSize(100, 100);
    avatarButton->setStyleSheet(R"(
        QPushButton {
            border: 3px solid #8A2BE2;
            border-radius: 50px;
            padding: 0;
            background: transparent;
        }
        QPushButton:hover {
            border-color: #9B4BFF;
            background: rgba(138, 43, 226, 0.1);
        }
    )");

    QGraphicsDropShadowEffect *avatarEffect = new QGraphicsDropShadowEffect();
    avatarEffect->setBlurRadius(20);
    avatarEffect->setColor(QColor(138, 43, 226, 100));
    avatarEffect->setOffset(0, 0);
    avatarButton->setGraphicsEffect(avatarEffect);

    // –ù–∏–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    usernameLabel = new QLabel(currentUsername);
    usernameLabel->setStyleSheet(R"(
        QLabel {
            color: #FFFFFF;
            font-size: 18px;
            font-weight: 600;
            text-align: center;
            padding: 10px 0 5px 0;
        }
    )");
    usernameLabel->setWordWrap(true);
    usernameLabel->setMaximumWidth(260);

    // –°—Ç–∞—Ç—É—Å
    QToolButton *statusButton = new QToolButton();
    statusButton->setText("–û–Ω–ª–∞–π–Ω");
    statusButton->setObjectName("statusButton");
    statusButton->setToolButtonStyle(Qt::ToolButtonTextOnly);
    statusButton->setArrowType(Qt::NoArrow);
    statusButton->setStyleSheet(R"(
        QToolButton {
            color: #4CAF50;
            font-size: 14px;
            font-weight: 500;
            background: transparent;
            border: 1px solid rgba(76, 175, 80, 0.3);
            border-radius: 12px;
            padding: 6px 15px;
            margin: 0 70px;
        }
        QToolButton:hover { background: rgba(76, 175, 80, 0.1); }
        QToolButton::menu-indicator { width: 0px; }
    )");
    statusButton->setCursor(Qt::PointingHandCursor);

    profileLayout->addWidget(avatarButton, 0, Qt::AlignHCenter);
    profileLayout->addWidget(usernameLabel, 0, Qt::AlignHCenter);
    profileLayout->addWidget(statusButton, 0, Qt::AlignHCenter);
    sidebarLayout->addWidget(profileSection);

    // –ù–∞–≤–∏–≥–∞—Ü–∏—è
    QWidget *navSection = new QWidget();
    navSection->setStyleSheet("background: transparent;");

    QVBoxLayout *navLayout = new QVBoxLayout(navSection);
    navLayout->setContentsMargins(15, 20, 15, 20);
    navLayout->setSpacing(3);

    QString navButtonStyle = R"(
        QPushButton {
            background: transparent;
            color: rgba(255, 255, 255, 0.8);
            border: none;
            text-align: left;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            border-radius: 8px;
            min-height: 45px;
        }
        QPushButton:hover {
            color: #FFFFFF;
            background: rgba(138, 43, 226, 0.15);
            padding-left: 25px;
        }
        QPushButton:pressed {
            background: rgba(138, 43, 226, 0.25);
        }
    )";

    myMusicBtn = new QPushButton("–ú–æ—è –º—É–∑—ã–∫–∞");
    profileBtn = new QPushButton("–ü—Ä–æ—Ñ–∏–ª—å");
    musicSearchBtn = new QPushButton("–ü–æ–∏—Å–∫ –º—É–∑—ã–∫–∏");
    playlistBtn = new QPushButton("–ú–æ–∏ –ø–ª–µ–π–ª–∏—Å—Ç—ã");
    friendsBtn = new QPushButton("–î—Ä—É–∑—å—è");
    messagesBtn = new QPushButton("–°–æ–æ–±—â–µ–Ω–∏—è");
    notificationsBtn = new QPushButton("–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è");
    roomsBtn = new QPushButton("–ö–æ–º–Ω–∞—Ç—ã");

    QList<QPushButton*> navButtons = {
        myMusicBtn, profileBtn, musicSearchBtn, playlistBtn,
        friendsBtn, messagesBtn, notificationsBtn, roomsBtn
    };

    for (auto btn : navButtons) {
        btn->setStyleSheet(navButtonStyle);
        btn->setCursor(Qt::PointingHandCursor);
        navLayout->addWidget(btn);
    }

    navLayout->addStretch();
    sidebarLayout->addWidget(navSection, 1);

    // –ù–∏–∂–Ω—è—è —á–∞—Å—Ç—å
    QWidget *bottomSection = new QWidget();
    bottomSection->setStyleSheet(R"(
        QWidget {
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }
    )");

    QPushButton *logoutBtn = new QPushButton("–í—ã–π—Ç–∏");
    logoutBtn->setObjectName("logoutBtn");
    logoutBtn->setStyleSheet(R"(
        QPushButton {
            background: rgba(255, 68, 68, 0.1);
            border: 1px solid rgba(255, 68, 68, 0.3);
            color: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            padding: 12px;
            font-size: 14px;
            font-weight: 500;
            width: 100%;
            min-height: 45px;
        }
        QPushButton:hover {
            background: rgba(255, 68, 68, 0.2);
            color: #FFFFFF;
        }
    )");
    connect(logoutBtn, &QPushButton::clicked, this, &QMainWindow::close);

    QVBoxLayout *bottomLayout = new QVBoxLayout(bottomSection);
    bottomLayout->setContentsMargins(0, 0, 0, 0);
    bottomLayout->addWidget(logoutBtn);

    sidebarLayout->addWidget(bottomSection);

    // –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é –¥–ª—è —Å—Ç–∞—Ç—É—Å–∞
    QMenu *statusMenu = new QMenu(this);
    statusMenu->setStyleSheet(R"(
        QMenu {
            background-color: #1A1A21;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 5px;
        }
        QMenu::item {
            background-color: transparent;
            color: rgba(255, 255, 255, 0.8);
            padding: 8px 25px;
            border-radius: 4px;
            margin: 2px;
            font-size: 14px;
            min-height: 30px;
        }
        QMenu::item:selected {
            background-color: rgba(138, 43, 226, 0.3);
            color: #8A2BE2;
        }
    )");

    QAction *onlineAction = new QAction("–û–Ω–ª–∞–π–Ω", this);
    QAction *awayAction = new QAction("–ù–µ—Ç –Ω–∞ –º–µ—Å—Ç–µ", this);
    QAction *dndAction = new QAction("–ù–µ –±–µ—Å–ø–æ–∫–æ–∏—Ç—å", this);
    QAction *invisibleAction = new QAction("–ù–µ–≤–∏–¥–∏–º–∫–∞", this);

    statusMenu->addAction(onlineAction);
    statusMenu->addAction(awayAction);
    statusMenu->addAction(dndAction);
    statusMenu->addAction(invisibleAction);

    statusButton->setMenu(statusMenu);
    statusButton->setPopupMode(QToolButton::InstantPopup);

    connect(onlineAction, &QAction::triggered, [statusButton]() {
        statusButton->setText("–û–Ω–ª–∞–π–Ω");
        statusButton->setStyleSheet(R"(
            QToolButton {
                color: #4CAF50;
                font-size: 14px;
                font-weight: 500;
                background: transparent;
                border: 1px solid rgba(76, 175, 80, 0.3);
                border-radius: 12px;
                padding: 6px 15px;
                margin: 0 70px;
            }
            QToolButton:hover { background: rgba(76, 175, 80, 0.1); }
            QToolButton::menu-indicator { width: 0px; }
        )");
    });

    connect(awayAction, &QAction::triggered, [statusButton]() {
        statusButton->setText("–ù–µ—Ç –Ω–∞ –º–µ—Å—Ç–µ");
        statusButton->setStyleSheet(R"(
            QToolButton {
                color: #FFC107;
                font-size: 14px;
                font-weight: 500;
                background: transparent;
                border: 1px solid rgba(255, 193, 7, 0.3);
                border-radius: 12px;
                padding: 6px 15px;
                margin: 0 70px;
            }
            QToolButton:hover { background: rgba(255, 193, 7, 0.1); }
            QToolButton::menu-indicator { width: 0px; }
        )");
    });

    connect(dndAction, &QAction::triggered, [statusButton]() {
        statusButton->setText("–ù–µ –±–µ—Å–ø–æ–∫–æ–∏—Ç—å");
        statusButton->setStyleSheet(R"(
            QToolButton {
                color: #F44336;
                font-size: 14px;
                font-weight: 500;
                background: transparent;
                border: 1px solid rgba(244, 67, 54, 0.3);
                border-radius: 12px;
                padding: 6px 15px;
                margin: 0 70px;
            }
            QToolButton:hover { background: rgba(244, 67, 54, 0.1); }
            QToolButton::menu-indicator { width: 0px; }
        )");
    });

    connect(invisibleAction, &QAction::triggered, [statusButton]() {
        statusButton->setText("–ù–µ–≤–∏–¥–∏–º–∫–∞");
        statusButton->setStyleSheet(R"(
            QToolButton {
                color: #9E9E9E;
                font-size: 14px;
                font-weight: 500;
                background: transparent;
                border: 1px solid rgba(158, 158, 158, 0.3);
                border-radius: 12px;
                padding: 6px 15px;
                margin: 0 70px;
            }
            QToolButton:hover { background: rgba(158, 158, 158, 0.1); }
            QToolButton::menu-indicator { width: 0px; }
        )");
    });
}



void MainWindow::createRoomsPage()
{
    roomsPage = new QWidget();
    roomsPage->setObjectName("roomsPage");
    roomsPage->setStyleSheet(R"(
        #roomsPage {
            background: #0F0F14;
        }
    )");
    
    // –ì–ª–∞–≤–Ω—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π
    QVBoxLayout *mainLayout = new QVBoxLayout(roomsPage);
    mainLayout->setContentsMargins(30, 30, 30, 30);
    mainLayout->setSpacing(25);
    
    // =========== HEADER ===========
    QWidget *headerWidget = new QWidget();
    headerWidget->setStyleSheet("background: transparent;");
    QVBoxLayout *headerLayout = new QVBoxLayout(headerWidget);
    headerLayout->setContentsMargins(0, 0, 0, 0);
    headerLayout->setSpacing(10);
    
    QLabel *titleLabel = new QLabel("–ö–æ–º–Ω–∞—Ç—ã");
    titleLabel->setStyleSheet(R"(
        QLabel {
            color: #FFFFFF;
            font-size: 28px;
            font-weight: 700;
            font-family: 'Segoe UI', 'Arial', sans-serif;
        }
    )");
    
    QLabel *subtitleLabel = new QLabel("–°–æ–≤–º–µ—Å—Ç–Ω–æ–µ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ –º—É–∑—ã–∫–∏");
    subtitleLabel->setStyleSheet(R"(
        QLabel {
            color: rgba(255, 255, 255, 0.6);
            font-size: 15px;
            font-family: 'Segoe UI', 'Arial', sans-serif;
        }
    )");
    
    headerLayout->addWidget(titleLabel);
    headerLayout->addWidget(subtitleLabel);
    mainLayout->addWidget(headerWidget);
    
    // =========== CONTROLS ===========
    QWidget *controlsWidget = new QWidget();
    controlsWidget->setStyleSheet("background: transparent;");
    QHBoxLayout *controlsLayout = new QHBoxLayout(controlsWidget);
    controlsLayout->setContentsMargins(0, 0, 0, 0);
    controlsLayout->setSpacing(15);
    
    QLineEdit *searchInput = new QLineEdit();
    searchInput->setPlaceholderText("–ü–æ–∏—Å–∫ –∫–æ–º–Ω–∞—Ç...");
    searchInput->setMinimumHeight(45);
    searchInput->setStyleSheet(R"(
        QLineEdit {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 0 20px;
            color: white;
            font-size: 14px;
            font-family: 'Segoe UI', 'Arial', sans-serif;
        }
        QLineEdit:focus {
            border: 1px solid #8A2BE2;
        }
    )");
    
    QPushButton *createRoomBtn = new QPushButton("–°–æ–∑–¥–∞—Ç—å –∫–æ–º–Ω–∞—Ç—É");
    createRoomBtn->setMinimumHeight(45);
    createRoomBtn->setMinimumWidth(160);
    createRoomBtn->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            font-family: 'Segoe UI', 'Arial', sans-serif;
            padding: 0 25px;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");
    
    controlsLayout->addWidget(searchInput, 1);
    controlsLayout->addWidget(createRoomBtn);
    mainLayout->addWidget(controlsWidget);
    
    // =========== SEPARATOR ===========
    QFrame *separator = new QFrame();
    separator->setFrameShape(QFrame::HLine);
    separator->setStyleSheet("border: 1px solid rgba(255, 255, 255, 0.05);");
    mainLayout->addWidget(separator);
    
    // =========== ROOMS GRID ===========
    // –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å –ø—Ä–æ–∫—Ä—É—Ç–∫–æ–π
    QScrollArea *scrollArea = new QScrollArea();
    scrollArea->setWidgetResizable(true);
    scrollArea->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    scrollArea->setStyleSheet(R"(
        QScrollArea {
            background: transparent;
            border: none;
        }
        QScrollBar:vertical {
            background: rgba(255, 255, 255, 0.05);
            width: 6px;
            border-radius: 3px;
        }
        QScrollBar::handle:vertical {
            background: rgba(138, 43, 226, 0.3);
            border-radius: 3px;
            min-height: 20px;
        }
    )");
    
    QWidget *scrollContent = new QWidget();
    scrollContent->setStyleSheet("background: transparent;");
    
    QGridLayout *roomsGrid = new QGridLayout(scrollContent);
    roomsGrid->setSpacing(20);
    roomsGrid->setContentsMargins(0, 10, 0, 10);
    
    // –î–∞–Ω–Ω—ã–µ –∫–æ–º–Ω–∞—Ç
    struct RoomData {
        QString name;
        QString icon;
        QString details;
        QString currentSong;
        int users;
        int maxUsers;
    };
    
    QVector<RoomData> rooms = {
        {"–í–µ—á–µ—Ä–Ω–∏–π –ª–æ—Ñ—Ç–∏", "üéµ", "–î–∂–∞–∑ ‚Ä¢ –°–æ—É–ª", "Frank Sinatra - Fly Me To The Moon", 4, 10},
        {"–†–µ—Ç—Ä–æ –≤–æ–ª–Ω–∞", "üéµ", "80s ‚Ä¢ –î–∏—Å–∫–æ", "Michael Jackson - Billie Jean", 6, 12},
        {"–ò–Ω–¥–∏-—Å–æ–±—Ä–∞–Ω–∏–µ", "üéµ", "–ò–Ω–¥–∏-—Ä–æ–∫", "Arctic Monkeys - Do I Wanna Know?", 3, 8},
        {"–•–∏–ø-—Ö–æ–ø –ª–∞—É–Ω–∂", "üéµ", "–†—ç–ø ‚Ä¢ –•–∏–ø-—Ö–æ–ø", "Kendrick Lamar - HUMBLE.", 8, 15},
        {"–≠–ª–µ–∫—Ç—Ä–æ–Ω–Ω–∞—è –≤–µ—á–µ—Ä–∏–Ω–∫–∞", "üéµ", "–¢–µ—Ö–Ω–æ ‚Ä¢ –•–∞—É—Å", "Daft Punk - Around the World", 12, 20},
        {"–ê–∫—É—Å—Ç–∏—á–µ—Å–∫–∞—è –≥–æ—Å—Ç–∏–Ω–∞—è", "üéµ", "–§–æ–ª–∫ ‚Ä¢ –ê–∫—É—Å—Ç–∏–∫–∞", "Ed Sheeran - Perfect", 2, 6}
    };
    
    for (int i = 0; i < rooms.size(); ++i) {
        const RoomData &room = rooms[i];
        
        // –ö–∞—Ä—Ç–æ—á–∫–∞ –∫–æ–º–Ω–∞—Ç—ã
        QWidget *roomCard = new QWidget();
        roomCard->setFixedHeight(160);
        
        // –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∫–∞—Ä—Ç–æ—á–∫–∏
        QVBoxLayout *cardLayout = new QVBoxLayout(roomCard);
        cardLayout->setContentsMargins(20, 15, 20, 15);
        cardLayout->setSpacing(10);
        
        // –í–µ—Ä—Ö–Ω—è—è —Å—Ç—Ä–æ–∫–∞: –Ω–∞–∑–≤–∞–Ω–∏–µ + –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏
        QWidget *topRow = new QWidget();
        QHBoxLayout *topRowLayout = new QHBoxLayout(topRow);
        topRowLayout->setContentsMargins(0, 0, 0, 0);
        topRowLayout->setSpacing(10);
        
        QLabel *iconLabel = new QLabel(room.icon);
        iconLabel->setStyleSheet(R"(
            QLabel {
                color: #8A2BE2;
                font-size: 16px;
            }
        )");
        
        QLabel *nameLabel = new QLabel(room.name);
        nameLabel->setStyleSheet(R"(
            QLabel {
                color: #FFFFFF;
                font-size: 16px;
                font-weight: 600;
                font-family: 'Segoe UI', 'Arial', sans-serif;
            }
        )");
        nameLabel->setWordWrap(true);
        
        QLabel *usersLabel = new QLabel(QString("%1/%2").arg(room.users).arg(room.maxUsers));
        usersLabel->setStyleSheet(R"(
            QLabel {
                color: rgba(255, 255, 255, 0.7);
                font-size: 13px;
                background: rgba(255, 255, 255, 0.05);
                padding: 4px 10px;
                border-radius: 10px;
                font-family: 'Segoe UI', 'Arial', sans-serif;
            }
        )");
        usersLabel->setAlignment(Qt::AlignCenter);
        
        topRowLayout->addWidget(iconLabel);
        topRowLayout->addWidget(nameLabel, 1);
        topRowLayout->addWidget(usersLabel);
        
        // –î–µ—Ç–∞–ª–∏ –∫–æ–º–Ω–∞—Ç—ã
        QLabel *detailsLabel = new QLabel(room.details);
        detailsLabel->setStyleSheet(R"(
            QLabel {
                color: #8A2BE2;
                font-size: 14px;
                font-weight: 500;
                font-family: 'Segoe UI', 'Arial', sans-serif;
            }
        )");
        
        // –¢–µ–∫—É—â–∏–π —Ç—Ä–µ–∫
        QLabel *songLabel = new QLabel(room.currentSong);
        songLabel->setStyleSheet(R"(
            QLabel {
                color: rgba(255, 255, 255, 0.7);
                font-size: 13px;
                font-style: italic;
                font-family: 'Segoe UI', 'Arial', sans-serif;
            }
        )");
        songLabel->setWordWrap(true);
        songLabel->setMaximumHeight(34);
        
        // –ö–Ω–æ–ø–∫–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º —Ç–µ–∫—Å—Ç–æ–º
        QPushButton *joinBtn = new QPushButton("–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è");
        joinBtn->setFixedHeight(35);
        joinBtn->setStyleSheet(R"(
            QPushButton {
                background: rgba(138, 43, 226, 0.2);
                border: 1px solid #8A2BE2;
                color: #8A2BE2;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 600;
                font-family: 'Segoe UI', 'Arial', sans-serif;
            }
            QPushButton:hover {
                background: rgba(138, 43, 226, 0.3);
            }
        )");
        joinBtn->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed);
        
        // –î–æ–±–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –≤ –∫–∞—Ä—Ç–æ—á–∫—É
        cardLayout->addWidget(topRow);
        cardLayout->addWidget(detailsLabel);
        cardLayout->addWidget(songLabel, 1);
        cardLayout->addWidget(joinBtn);
        
        // –°—Ç–∏–ª—å –∫–∞—Ä—Ç–æ—á–∫–∏
        roomCard->setStyleSheet(R"(
            QWidget {
                background: rgba(255, 255, 255, 0.03);
                border: 1px solid rgba(255, 255, 255, 0.05);
                border-radius: 12px;
            }
            QWidget:hover {
                background: rgba(255, 255, 255, 0.05);
                border: 1px solid rgba(138, 43, 226, 0.3);
            }
        )");
        
        // –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å–µ—Ç–∫—É (2 –∫–æ–ª–æ–Ω–∫–∏)
        int row = i / 2;
        int col = i % 2;
        roomsGrid->addWidget(roomCard, row, col, 1, 1);
        
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–∞—Å—Ç—è–∂–µ–Ω–∏–µ –¥–ª—è —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–≥–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
        roomsGrid->setColumnStretch(col, 1);
        roomsGrid->setRowStretch(row, 0);
    }
    
    // –î–æ–±–∞–≤–ª—è–µ–º stretch –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –æ—Å—Ç–∞–≤—à–µ–≥–æ—Å—è –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞
    int totalRows = (rooms.size() + 1) / 2;
    for (int i = totalRows; i < 10; ++i) {
        roomsGrid->setRowStretch(i, 1);
    }
    
    scrollArea->setWidget(scrollContent);
    mainLayout->addWidget(scrollArea, 1);
    
    // =========== ACTIVE ROOM ===========
    QWidget *activeRoomWidget = new QWidget();
    activeRoomWidget->setStyleSheet(R"(
        QWidget {
            background: rgba(138, 43, 226, 0.1);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 12px;
            padding: 20px;
        }
    )");
    
    QHBoxLayout *activeLayout = new QHBoxLayout(activeRoomWidget);
    activeLayout->setContentsMargins(0, 0, 0, 0);
    activeLayout->setSpacing(20);
    
    QLabel *activeIcon = new QLabel("üéß");
    activeIcon->setStyleSheet("font-size: 24px;");
    
    QWidget *infoWidget = new QWidget();
    QVBoxLayout *infoLayout = new QVBoxLayout(infoWidget);
    infoLayout->setContentsMargins(0, 0, 0, 0);
    infoLayout->setSpacing(5);
    
    QLabel *activeTitle = new QLabel("–î–∂–∞–∑ –≤–µ—á–µ—Ä");
    activeTitle->setStyleSheet(R"(
        QLabel {
            color: #FFFFFF;
            font-size: 16px;
            font-weight: 600;
            font-family: 'Segoe UI', 'Arial', sans-serif;
        }
    )");
    
    QLabel *activeDetails = new QLabel("3 —É—á–∞—Å—Ç–Ω–∏–∫–∞ ‚Ä¢ Frank Sinatra - Fly Me To The Moon");
    activeDetails->setStyleSheet(R"(
        QLabel {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            font-family: 'Segoe UI', 'Arial', sans-serif;
        }
    )");
    
    infoLayout->addWidget(activeTitle);
    infoLayout->addWidget(activeDetails);
    
    QPushButton *enterBtn = new QPushButton("–í–æ–π—Ç–∏");
    enterBtn->setFixedWidth(100);
    enterBtn->setFixedHeight(40);
    enterBtn->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            font-family: 'Segoe UI', 'Arial', sans-serif;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");
    
    activeLayout->addWidget(activeIcon);
    activeLayout->addWidget(infoWidget, 1);
    activeLayout->addWidget(enterBtn);
    
    mainLayout->addWidget(activeRoomWidget);
}

void MainWindow::createPages()
{
    mainStack = new QStackedWidget();
    mainStack->setStyleSheet(R"(
        QStackedWidget {
            background: #0F0F14;
        }
    )");
    
    createMyMusicPage();
    createMusicPage();
    createRoomsPage();
    
    friendsPage = new FriendsPage(currentUserId);
    messagesPage = new MessagesPage(currentUserId);
    
    connect(friendsPage, &FriendsPage::openChatWithFriend, 
            this, [this](int friendId, const QString& friendName) {
        messagesPage->openChat(friendId, friendName);
        mainStack->setCurrentWidget(messagesPage);
    });
    
    profilePage = createSimplePage("–ü—Ä–æ—Ñ–∏–ª—å", "–ó–¥–µ—Å—å –±—É–¥–µ—Ç –ø—Ä–æ—Ñ–∏–ª—å");
    notificationsPage = createSimplePage("–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è", "–ó–¥–µ—Å—å –±—É–¥—É—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è");
    playlistPage = createSimplePage("–ü–ª–µ–π–ª–∏—Å—Ç—ã", "–ó–¥–µ—Å—å –±—É–¥—É—Ç –ø–ª–µ–π–ª–∏—Å—Ç—ã");
    
    mainStack->addWidget(myMusicPage);
    mainStack->addWidget(profilePage);
    mainStack->addWidget(messagesPage);
    mainStack->addWidget(friendsPage);
    mainStack->addWidget(notificationsPage);
    mainStack->addWidget(playlistPage);
    mainStack->addWidget(musicPage);
    mainStack->addWidget(roomsPage);
}

QWidget* MainWindow::createSimplePage(const QString& title, const QString& description)
{
    QWidget* page = new QWidget();
    QVBoxLayout* layout = new QVBoxLayout(page);
    layout->setContentsMargins(40, 40, 40, 40);
    
    QLabel* titleLabel = new QLabel(title);
    titleLabel->setStyleSheet(R"(
        QLabel {
            color: #FFFFFF;
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
        }
    )");
    
    QLabel* descLabel = new QLabel(description);
    descLabel->setStyleSheet(R"(
        QLabel {
            color: rgba(255, 255, 255, 0.5);
            font-size: 16px;
            text-align: center;
        }
    )");
    
    layout->addStretch();
    layout->addWidget(titleLabel);
    layout->addWidget(descLabel);
    layout->addStretch();
    
    return page;
}


void MainWindow::createMyMusicPage()
{
    myMusicPage = new QWidget();
    myMusicPage->setObjectName("myMusicPage");
    myMusicPage->setStyleSheet(R"(
        #myMusicPage {
            background: #0F0F14;
        }
    )");
    
    QVBoxLayout *myMusicLayout = new QVBoxLayout(myMusicPage);
    myMusicLayout->setContentsMargins(40, 40, 40, 40);
    myMusicLayout->setSpacing(25);
    
    QLabel *myMusicTitle = new QLabel("–ú–æ—è –º—É–∑—ã–∫–∞");
    myMusicTitle->setStyleSheet(R"(
        QLabel {
            color: #FFFFFF;
            font-size: 32px;
            font-weight: bold;
        }
    )");
    
    // –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    QWidget *controlsWidget = new QWidget();
    controlsWidget->setStyleSheet("background: transparent;");
    QHBoxLayout *controlsLayout = new QHBoxLayout(controlsWidget);
    controlsLayout->setContentsMargins(0, 0, 0, 0);
    
    refreshTracksBtn = new QPushButton("–û–±–Ω–æ–≤–∏—Ç—å");
    addLocalTrackBtn = new QPushButton("–î–æ–±–∞–≤–∏—Ç—å —Ç—Ä–µ–∫");
    
    QString controlButtonStyle = R"(
        QPushButton {
            background: rgba(138, 43, 226, 0.2);
            border: 1px solid #8A2BE2;
            color: #8A2BE2;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
        }
        QPushButton:hover {
            background: rgba(138, 43, 226, 0.3);
            transform: translateY(-1px);
        }
        QPushButton:pressed {
            transform: translateY(0px);
            background: rgba(138, 43, 226, 0.4);
        }
    )";
    
    refreshTracksBtn->setStyleSheet(controlButtonStyle);
    addLocalTrackBtn->setStyleSheet(controlButtonStyle);
    
    controlsLayout->addWidget(refreshTracksBtn);
    controlsLayout->addWidget(addLocalTrackBtn);
    controlsLayout->addStretch();
    
    // –°–ø–∏—Å–æ–∫ —Ç—Ä–µ–∫–æ–≤
    userTracksList = new QListWidget();
    userTracksList->setStyleSheet(R"(
        QListWidget {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            color: white;
            font-size: 14px;
            outline: none;
            padding: 5px;
        }
        QListWidget::item {
            background: transparent;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            height: 60px;
            border-radius: 8px;
            margin: 2px;
        }
        QListWidget::item:selected {
            background: rgba(138, 43, 226, 0.15);
            color: white;
            border: 1px solid rgba(138, 43, 226, 0.3);
        }
        QListWidget::item:hover {
            background: rgba(255, 255, 255, 0.05);
        }
    )");
    
    myMusicLayout->addWidget(myMusicTitle);
    myMusicLayout->addWidget(controlsWidget);
    myMusicLayout->addWidget(userTracksList, 1);
}

void MainWindow::createMusicPage()
{
    musicPage = new QWidget();
    musicPage->setObjectName("musicPage");
    musicPage->setStyleSheet(R"(
        #musicPage {
            background: #0F0F14;
        }
    )");
    
    QVBoxLayout *mainLayout = new QVBoxLayout(musicPage);
    mainLayout->setContentsMargins(40, 40, 40, 40);
    mainLayout->setSpacing(25);
    
    QLabel *titleLabel = new QLabel("–ü–æ–∏—Å–∫ –º—É–∑—ã–∫–∏");
    titleLabel->setStyleSheet(R"(
        QLabel {
            color: #FFFFFF;
            font-size: 32px;
            font-weight: bold;
        }
    )");
    mainLayout->addWidget(titleLabel);
    
    // –ü–æ–∏—Å–∫–æ–≤–∞—è —Å—Ç—Ä–æ–∫–∞
    QWidget *searchWidget = new QWidget();
    searchWidget->setStyleSheet("background: transparent;");
    QHBoxLayout *searchLayout = new QHBoxLayout(searchWidget);
    searchLayout->setContentsMargins(0, 0, 0, 0);
    searchLayout->setSpacing(15);
    
    searchInput = new QLineEdit();
    searchInput->setPlaceholderText("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞, –∞–ª—å–±–æ–º–∞ –∏–ª–∏ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è...");
    searchInput->setMinimumHeight(50);
    searchInput->setStyleSheet(R"(
        QLineEdit {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 0 20px;
            color: white;
            font-size: 14px;
            selection-background-color: #8A2BE2;
        }
        QLineEdit:focus {
            border: 2px solid #8A2BE2;
            background: rgba(255, 255, 255, 0.07);
        }
        QLineEdit::placeholder {
            color: rgba(255, 255, 255, 0.3);
        }
    )");
    
    searchButton = new QPushButton("–ù–∞–π—Ç–∏");
    searchButton->setFixedWidth(120);
    searchButton->setMinimumHeight(50);
    searchButton->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: #9B4BFF;
            transform: translateY(-1px);
        }
        QPushButton:pressed {
            transform: translateY(0px);
            background: #7B1FA2;
        }
    )");
    
    topTracksButton = new QPushButton("üî• –ü–æ–ø—É–ª—è—Ä–Ω–æ–µ");
    topTracksButton->setFixedWidth(150);
    topTracksButton->setMinimumHeight(50);
    topTracksButton->setStyleSheet(searchButton->styleSheet());
    
    searchLayout->addWidget(searchInput, 1);
    searchLayout->addWidget(searchButton);
    searchLayout->addWidget(topTracksButton);
    mainLayout->addWidget(searchWidget);
    
    // –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞
    QWidget *resultsWidget = new QWidget();
    resultsWidget->setStyleSheet("background: transparent;");
    QHBoxLayout *resultsLayout = new QHBoxLayout(resultsWidget);
    resultsLayout->setContentsMargins(0, 0, 0, 0);
    resultsLayout->setSpacing(20);
    
    // –°–ø–∏—Å–æ–∫ —Ç—Ä–µ–∫–æ–≤
    tracksList = new QListWidget();
    tracksList->setStyleSheet(R"(
        QListWidget {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            color: white;
            font-size: 14px;
            outline: none;
            padding: 10px;
        }
        QListWidget::item {
            background: transparent;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin: 2px;
        }
        QListWidget::item:selected {
            background: rgba(138, 43, 226, 0.15);
            color: white;
            border: 1px solid rgba(138, 43, 226, 0.3);
        }
        QListWidget::item:hover {
            background: rgba(255, 255, 255, 0.05);
        }
    )");
    
    // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç—Ä–µ–∫–µ
    QWidget *infoWidget = new QWidget();
    infoWidget->setStyleSheet(R"(
        QWidget {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.05);
            border-radius: 15px;
        }
    )");
    
    QVBoxLayout *infoLayout = new QVBoxLayout(infoWidget);
    infoLayout->setContentsMargins(25, 25, 25, 25);
    infoLayout->setSpacing(20);
    
    QLabel *infoTitle = new QLabel("–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç—Ä–µ–∫–µ");
    infoTitle->setStyleSheet(R"(
        QLabel {
            color: #FFFFFF;
            font-size: 18px;
            font-weight: 600;
        }
    )");
    
    trackInfo = new QTextEdit();
    trackInfo->setReadOnly(true);
    trackInfo->setStyleSheet(R"(
        QTextEdit {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            padding: 15px;
            selection-background-color: #8A2BE2;
        }
    )");
    trackInfo->setPlaceholderText("–í—ã–±–µ—Ä–∏—Ç–µ —Ç—Ä–µ–∫ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏...");
    
    QPushButton *addToLibraryBtn = new QPushButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫—É");
    addToLibraryBtn->setStyleSheet(R"(
        QPushButton {
            background: rgba(138, 43, 226, 0.2);
            border: 1px solid #8A2BE2;
            color: #8A2BE2;
            border-radius: 8px;
            padding: 12px;
            font-weight: 600;
            font-size: 14px;
        }
        QPushButton:hover {
            background: rgba(138, 43, 226, 0.3);
        }
        QPushButton:pressed {
            background: rgba(138, 43, 226, 0.4);
        }
    )");
    addToLibraryBtn->setVisible(false);
    
    infoLayout->addWidget(infoTitle);
    infoLayout->addWidget(trackInfo, 1);
    infoLayout->addWidget(addToLibraryBtn);
    
    resultsLayout->addWidget(tracksList, 2);
    resultsLayout->addWidget(infoWidget, 1);
    mainLayout->addWidget(resultsWidget, 1);
    
    // –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é
    tracksList->setContextMenuPolicy(Qt::CustomContextMenu);
    
    connect(tracksList, &QListWidget::itemClicked, this, [this, addToLibraryBtn](QListWidgetItem *item) {
        trackInfo->setPlainText(item->data(Qt::UserRole).toString());
        addToLibraryBtn->setVisible(true);
        addToLibraryBtn->setProperty("trackData", item->data(Qt::UserRole + 1));
    });
    
    connect(addToLibraryBtn, &QPushButton::clicked, this, [this, addToLibraryBtn]() {
        QVariant trackData = addToLibraryBtn->property("trackData");
        if (trackData.isValid()) {
            QVariantMap track = trackData.toMap();
            
            bool success = DatabaseManager::instance().addTrackFromAPI(
                currentUserId,
                track["title"].toString(),
                track["artist"].toString(),
                track["coverUrl"].toString()
            );
                    
            if (success) {
                QMessageBox::information(this, "–£—Å–ø–µ—Ö", "–¢—Ä–µ–∫ –¥–æ–±–∞–≤–ª–µ–Ω –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫—É!");
                addToLibraryBtn->setVisible(false);
            } else {
                QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å —Ç—Ä–µ–∫ –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫—É");
            }
        }
    });
    
    connect(tracksList, &QListWidget::customContextMenuRequested, this, [this](const QPoint &pos) {
        QListWidgetItem *item = tracksList->itemAt(pos);
        if (item) {
            QMenu contextMenu(this);
            contextMenu.setStyleSheet(R"(
                QMenu {
                    background-color: #1A1A21;
                    border: 1px solid rgba(255, 255, 255, 0.1);
                    border-radius: 8px;
                    padding: 5px;
                }
                QMenu::item {
                    background-color: transparent;
                    color: rgba(255, 255, 255, 0.8);
                    padding: 8px 20px;
                    border-radius: 4px;
                    margin: 2px;
                }
                QMenu::item:selected {
                    background-color: rgba(138, 43, 226, 0.3);
                    color: #8A2BE2;
                }
                QMenu::separator {
                    height: 1px;
                    background: rgba(255, 255, 255, 0.1);
                    margin: 5px 10px;
                }
            )");
            
            QAction *addToLibraryAction = contextMenu.addAction("‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫—É");
            QAction *viewInfoAction = contextMenu.addAction("‚ÑπÔ∏è –ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é");
            contextMenu.addSeparator();
            QAction *shareAction = contextMenu.addAction("‚ÜóÔ∏è –ü–æ–¥–µ–ª–∏—Ç—å—Å—è");
            
            QAction *selectedAction = contextMenu.exec(tracksList->mapToGlobal(pos));
            
            if (selectedAction == addToLibraryAction) {
                QVariant trackData = item->data(Qt::UserRole + 1);
                if (trackData.isValid()) {
                    QVariantMap track = trackData.toMap();
                    
                    bool success = DatabaseManager::instance().addTrackFromAPI(
                        currentUserId,
                        track["title"].toString(),
                        track["artist"].toString(),
                        track["coverUrl"].toString()
                    );
                    
                    if (success) {
                        QMessageBox::information(this, "–£—Å–ø–µ—Ö", "–¢—Ä–µ–∫ –¥–æ–±–∞–≤–ª–µ–Ω –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫—É!");
                    }
                }
            } else if (selectedAction == viewInfoAction) {
                trackInfo->setPlainText(item->data(Qt::UserRole).toString());
            }
        }
    });
}

void MainWindow::showRoomsPage()
{
    mainStack->setCurrentIndex(ROOMSPAGE);
}

void MainWindow::setupConnections()
{
    // 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—Ä—è–¥–æ–∫ —Å enum
    qDebug() << "MYMUSICPAGE –∏–Ω–¥–µ–∫—Å:" << MYMUSICPAGE;
    qDebug() << "ROOMSPAGE –∏–Ω–¥–µ–∫—Å:" << ROOMSPAGE;
    
    // 2. –ò—Å–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
    connect(myMusicBtn, &QPushButton::clicked, this, [this]() { 
        qDebug() << "–ù–∞–∂–∞—Ç–∞ –ú–æ—è –º—É–∑—ã–∫–∞, –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º –Ω–∞ –∏–Ω–¥–µ–∫—Å" << MYMUSICPAGE;
        mainStack->setCurrentIndex(MYMUSICPAGE); 
        loadUserTracks();
    });
    
    connect(profileBtn, &QPushButton::clicked, this, [this]() { 
        mainStack->setCurrentIndex(PROFILEPAGE); 
    });
    
    connect(messagesBtn, &QPushButton::clicked, this, [this]() { 
        mainStack->setCurrentIndex(MESSAGESPAGE); 
    });
    
    connect(friendsBtn, &QPushButton::clicked, this, [this]() { 
        mainStack->setCurrentIndex(FRIENDSPAGE); 
    });
    
    connect(notificationsBtn, &QPushButton::clicked, this, [this]() { 
        mainStack->setCurrentIndex(NOTIFICATIONSPAGE); 
    });
    
    connect(playlistBtn, &QPushButton::clicked, this, [this]() { 
        mainStack->setCurrentIndex(PLAYLISTPAGE); 
    });
    
    connect(musicSearchBtn, &QPushButton::clicked, this, [this]() { 
        qDebug() << "–ù–∞–∂–∞—Ç–∞ –ü–æ–∏—Å–∫ –º—É–∑—ã–∫–∏, –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º –Ω–∞ –∏–Ω–¥–µ–∫—Å" << MUSICPAGE;
        mainStack->setCurrentIndex(MUSICPAGE); 
    });
    
    connect(roomsBtn, &QPushButton::clicked, this, [this]() { 
        qDebug() << "–ù–∞–∂–∞—Ç–∞ –ö–æ–º–Ω–∞—Ç—ã, –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º –Ω–∞ –∏–Ω–¥–µ–∫—Å" << ROOMSPAGE;
        mainStack->setCurrentIndex(ROOMSPAGE); 
    });
    
    // –û—Å—Ç–∞–ª—å–Ω—ã–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –æ—Å—Ç–∞—é—Ç—Å—è –∫–∞–∫ –µ—Å—Ç—å
    connect(avatarButton, &QPushButton::clicked, this, &MainWindow::changeAvatar);
    connect(searchButton, &QPushButton::clicked, this, &MainWindow::searchMusic);
    connect(topTracksButton, &QPushButton::clicked, this, &MainWindow::showTopTracks);
    connect(searchInput, &QLineEdit::returnPressed, this, &MainWindow::searchMusic);
    connect(apiManager, &MusicAPIManager::tracksFound, this, &MainWindow::onTracksFound);
    connect(apiManager, &MusicAPIManager::errorOccurred, this, &MainWindow::onNetworkError);
    connect(refreshTracksBtn, &QPushButton::clicked, this, &MainWindow::loadUserTracks);
    connect(addLocalTrackBtn, &QPushButton::clicked, this, [this]() {
        QString filePath = QFileDialog::getOpenFileName(this, "–í—ã–±–µ—Ä–∏—Ç–µ –∞—É–¥–∏–æ—Ñ–∞–π–ª", QDir::homePath(), 
                                                       "Audio Files (*.mp3 *.wav *.flac *.ogg *.m4a)");
        if (!filePath.isEmpty()) {
            QMessageBox::information(this, "–£—Å–ø–µ—Ö", "–¢—Ä–µ–∫ –¥–æ–±–∞–≤–ª–µ–Ω –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫—É!");
            loadUserTracks();
        }
    });
    connect(userTracksList, &QListWidget::itemClicked, this, &MainWindow::onPlaylistItemClicked);
}

void MainWindow::playTrack(int trackId)
{
    for (int i = 0; i < currentTracks.size(); ++i) {
        if (currentTracks[i].id == trackId) {
            currentTrackIndex = i;
            TrackData track = currentTracks[i];
            
            audioPlayer->updateTrackInfo(track.title, track.artist);
            
            if (track.filePath.startsWith("lastfm://")) {
                QMessageBox::information(this, "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è", 
                    QString("–¢—Ä–µ–∫ '%1 - %2' –∏–∑ –æ–Ω–ª–∞–π–Ω-–±–∏–±–ª–∏–æ—Ç–µ–∫–∏ Last.fm.\n\n"
                           "–î–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –æ–Ω–ª–∞–π–Ω-—Ç—Ä–µ–∫–æ–≤ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ:\n"
                           "1. –ü–æ–ª—É—á–∏—Ç—å URL –ø–æ—Ç–æ–∫–∞ –∏–∑ Last.fm API\n"
                           "2. –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –æ–Ω–ª–∞–π–Ω-–≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ").arg(track.artist).arg(track.title));
                return;
            }
            
            if (QFile::exists(track.filePath)) {
                audioPlayer->playTrack(track.filePath);
                DatabaseManager::instance().incrementPlayCount(trackId);
            } else {
                QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: " + track.filePath);
            }
            break;
        }
    }
}

void MainWindow::onPlaylistItemClicked(QListWidgetItem *item)
{
    if (item) {
        int trackId = item->data(Qt::UserRole).toInt();
        playTrack(trackId);
    }
}

void MainWindow::onTrackDeleteRequested(int trackId)
{
    QMessageBox msgBox;
    msgBox.setWindowTitle("–£–¥–∞–ª–µ–Ω–∏–µ —Ç—Ä–µ–∫–∞");
    msgBox.setText("–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —ç—Ç–æ—Ç —Ç—Ä–µ–∫ –∏–∑ —Å–≤–æ–µ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏?");
    msgBox.setStyleSheet(R"(
        QMessageBox {
            background-color: #1A1A21;
            color: white;
        }
        QMessageBox QLabel {
            color: white;
        }
        QMessageBox QPushButton {
            background-color: #8A2BE2;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
        }
        QMessageBox QPushButton:hover {
            background-color: #9B4BFF;
        }
        QMessageBox QPushButton#NoButton {
            background-color: rgba(255, 255, 255, 0.1);
        }
    )");
    msgBox.setStandardButtons(QMessageBox::Yes | QMessageBox::No);
    msgBox.setDefaultButton(QMessageBox::No);
    
    if (msgBox.exec() == QMessageBox::Yes) {
        bool success = DatabaseManager::instance().deleteTrack(trackId);
        
        if (success) {
            QMessageBox::information(this, "–£—Å–ø–µ—Ö", "–¢—Ä–µ–∫ —É–¥–∞–ª–µ–Ω –∏–∑ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏!");
            loadUserTracks();
        } else {
            QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Ç—Ä–µ–∫");
        }
    }
}

void MainWindow::loadUserTracks()
{
    userTracksList->clear();
    QList<TrackData> tracksList = DatabaseManager::instance().getUserTracks(currentUserId);
    currentTracks = QVector<TrackData>::fromList(tracksList);
    
    for (const TrackData &track : currentTracks) {
        QString duration = track.duration > 0 ? audioPlayer->formatTime(track.duration) : "0:00";
        QString itemText = QString("%1 - %2 (%3)").arg(track.artist).arg(track.title).arg(duration);
        
        TrackListWidgetItem *item = new TrackListWidgetItem("", track.id, userTracksList);
        item->setData(Qt::UserRole, track.id);
        item->setSizeHint(QSize(item->sizeHint().width(), 60));
        
        QWidget *itemWidget = new QWidget();
        QHBoxLayout *itemLayout = new QHBoxLayout(itemWidget);
        itemLayout->setContentsMargins(15, 10, 15, 10);
        itemLayout->setSpacing(15);
        
        QLabel *trackIcon = new QLabel("üéµ");
        trackIcon->setStyleSheet("font-size: 16px;");
        
        QWidget *textWidget = new QWidget();
        QVBoxLayout *textLayout = new QVBoxLayout(textWidget);
        textLayout->setContentsMargins(0, 0, 0, 0);
        textLayout->setSpacing(3);
        
        QLabel *titleLabel = new QLabel(track.title);
        titleLabel->setStyleSheet(R"(
            QLabel {
                color: white;
                font-size: 14px;
                font-weight: 500;
                background-color: transparent;
            }
        )");
        
        QLabel *artistLabel = new QLabel(track.artist);
        artistLabel->setStyleSheet(R"(
            QLabel {
                color: rgba(255, 255, 255, 0.6);
                font-size: 12px;
                background-color: transparent;
            }
        )");
        
        textLayout->addWidget(titleLabel);
        textLayout->addWidget(artistLabel);
        
        QLabel *durationLabel = new QLabel(duration);
        durationLabel->setStyleSheet(R"(
            QLabel {
                color: rgba(255, 255, 255, 0.5);
                font-size: 12px;
                min-width: 40px;
            }
        )");
        
        QPushButton *playBtn = new QPushButton("‚ñ∂");
        playBtn->setFixedSize(35, 35);
        playBtn->setStyleSheet(R"(
            QPushButton {
                background-color: rgba(138, 43, 226, 0.2);
                color: #8A2BE2;
                border: none;
                border-radius: 17px;
                font-size: 12px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: rgba(138, 43, 226, 0.3);
                color: white;
            }
        )");
        
        QPushButton *deleteBtn = new QPushButton("√ó");
        deleteBtn->setFixedSize(25, 25);
        deleteBtn->setStyleSheet(R"(
            QPushButton {
                background-color: rgba(255, 68, 68, 0.1);
                color: rgba(255, 68, 68, 0.7);
                border: 1px solid rgba(255, 68, 68, 0.3);
                border-radius: 4px;
                font-size: 12px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: rgba(255, 68, 68, 0.2);
                color: #FF4444;
            }
        )");
        
        // –ó–ê–•–í–ê–¢–´–í–ê–ï–ú trackId –ö–ê–ö –õ–û–ö–ê–õ–¨–ù–£–Æ –ö–û–ü–ò–Æ
        int trackId = track.id;  // –°–æ–∑–¥–∞–µ–º –ª–æ–∫–∞–ª—å–Ω—É—é –∫–æ–ø–∏—é
        
        connect(playBtn, &QPushButton::clicked, [this, trackId]() {
            playTrack(trackId);
        });
        
        connect(deleteBtn, &QPushButton::clicked, this, [this, trackId]() {
            onTrackDeleteRequested(trackId);
        });
        
        itemLayout->addWidget(trackIcon);
        itemLayout->addWidget(textWidget, 1);
        itemLayout->addWidget(durationLabel);
        itemLayout->addWidget(playBtn);
        itemLayout->addWidget(deleteBtn);
        
        itemWidget->setLayout(itemLayout);
        itemWidget->setStyleSheet("QWidget { background-color: transparent; }");
        
        userTracksList->setItemWidget(item, itemWidget);
    }
}


void MainWindow::setupAvatar()
{
  setDefaultAvatar();
}

void MainWindow::setAvatarPixmap(const QPixmap& pixmap)
{
    // –£–±–µ–¥–∏—Å—å, —á—Ç–æ –∞–≤–∞—Ç–∞—Ä–∫–∞ –∫—Ä—É–≥–ª–∞—è —á–µ—Ä–µ–∑ —Å—Ç–∏–ª–∏, –∞ –Ω–µ –º–∞—Å–∫—É
    QPixmap scaledPixmap = pixmap.scaled(100, 100, Qt::KeepAspectRatioByExpanding, Qt::SmoothTransformation);
    
    // –°–æ–∑–¥–∞–µ–º –∫—Ä—É–≥–ª—É—é –∏–∫–æ–Ω–∫—É
    QPixmap circularPixmap(100, 100);
    circularPixmap.fill(Qt::transparent);
    
    QPainter painter(&circularPixmap);
    painter.setRenderHint(QPainter::Antialiasing, true);
    painter.setRenderHint(QPainter::SmoothPixmapTransform, true);
    
    QPainterPath path;
    path.addEllipse(0, 0, 100, 100);
    painter.setClipPath(path);
    
    // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º
    int x = (100 - scaledPixmap.width()) / 2;
    int y = (100 - scaledPixmap.height()) / 2;
    painter.drawPixmap(x, y, scaledPixmap);
    
    avatarButton->setIcon(QIcon(circularPixmap));
    avatarButton->setIconSize(QSize(100, 100));
    avatarButton->setText("");
}

void MainWindow::setDefaultAvatar()
{
    QPixmap defaultPixmap(100, 100);
    defaultPixmap.fill(Qt::transparent);
    
    QPainter painter(&defaultPixmap);
    painter.setRenderHint(QPainter::Antialiasing, true);
    
    // –ö—Ä—É–≥–ª—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π —Ñ–æ–Ω
    QPainterPath circlePath;
    circlePath.addEllipse(0, 0, 100, 100);
    painter.setClipPath(circlePath);
    
    QRadialGradient gradient(50, 50, 50);
    gradient.setColorAt(0, QColor("#9B4BFF"));
    gradient.setColorAt(1, QColor("#7B1FA2"));
    
    painter.setBrush(QBrush(gradient));
    painter.setPen(Qt::NoPen);
    painter.drawEllipse(0, 0, 100, 100);
    
    // –ò–Ω–∏—Ü–∏–∞–ª—ã
    painter.setPen(QPen(Qt::white, 2));
    painter.setFont(QFont("Arial", 24, QFont::Bold));
    
    QString initials = currentUsername.left(2).toUpper();
    painter.drawText(QRect(0, 0, 100, 100), Qt::AlignCenter, initials);
    
    avatarButton->setIcon(QIcon(defaultPixmap));
    avatarButton->setIconSize(QSize(100, 100));
    avatarButton->setText("");
}

void MainWindow::changeAvatar()
{
    QString filePath = QFileDialog::getOpenFileName(
        this,
        "–í—ã–±–µ—Ä–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –∞–≤–∞—Ç–∞—Ä–∫–∏",
        QDir::homePath(),
        "Images (*.png *.jpg *.jpeg *.bmp *.gif)"
    );
    
    if (!filePath.isEmpty()) {
        QPixmap newAvatar(filePath);
        if (newAvatar.isNull()) {
            QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ");
            return;
        }
        
        saveAvatar(newAvatar);
        setAvatarPixmap(newAvatar);
        
        QMessageBox::information(this, "–£—Å–ø–µ—Ö", "–ê–≤–∞—Ç–∞—Ä–∫–∞ —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω–µ–Ω–∞!");
    }
}

void MainWindow::saveAvatar(const QPixmap& avatar)
{
    // 1) –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î (–∏—Å—Ç–æ—á–Ω–∏–∫ –∏—Å—Ç–∏–Ω—ã)
    QByteArray bytes;
    QBuffer buffer(&bytes);
    buffer.open(QIODevice::WriteOnly);
    avatar.save(&buffer, "PNG", 100);

    QSqlQuery q(DatabaseManager::instance().database());
    q.prepare("UPDATE users SET avatar_data = ? WHERE id = ?");
    q.addBindValue(bytes);
    q.addBindValue(currentUserId);

    if (!q.exec()) {
        qDebug() << "saveAvatar db error:" << q.lastError().text();
    }

    // 2) –ü–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π –∫—ç—à-—Ñ–∞–π–ª (—á—Ç–æ–±—ã –ø–æ—Å–ª–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ –±—ã–ª–æ —Ç–æ –∂–µ —Å–∞–º–æ–µ)
    QDir dir("avatars");
    if (!dir.exists()) dir.mkpath(".");

    const QString filePath = QString("avatars/user%1.png").arg(currentUserId);
    if (!avatar.save(filePath, "PNG", 100)) {
        qDebug() << "saveAvatar file save failed:" << filePath;
    }
}

void MainWindow::loadUserAvatar()
{
    // 1) –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –∏–∑ –ë–î
    {
        QSqlQuery q(DatabaseManager::instance().database());
        const QString sql =
            QString("SELECT avatar_data FROM users WHERE id = %1").arg(currentUserId);

        if (q.exec(sql) && q.next()) {
            const QByteArray bytes = q.value(0).toByteArray();
            if (!bytes.isEmpty()) {
                QPixmap pm;
                if (pm.loadFromData(bytes)) {
                    setAvatarPixmap(pm);
                    return;
                }
            }
        } else {
            qDebug() << "loadUserAvatar db error:" << q.lastError().text();
        }
    }

    // 2) –§–æ–ª–±—ç–∫: —Ñ–∞–π–ª
    const QString userAvatarPath = QString("avatars/user%1.png").arg(currentUserId);
    QFile avatarFile(userAvatarPath);
    if (avatarFile.exists()) {
        QPixmap avatarPixmap(userAvatarPath);
        if (!avatarPixmap.isNull()) {
            setAvatarPixmap(avatarPixmap);
            return;
        }
    }

    // 3) –î–µ—Ñ–æ–ª—Ç
    setDefaultAvatar();
}



void MainWindow::showProfilePage() { mainStack->setCurrentIndex(PROFILEPAGE); }
void MainWindow::showMessagesPage() { mainStack->setCurrentIndex(MESSAGESPAGE); }
void MainWindow::showFriendsPage() { mainStack->setCurrentIndex(FRIENDSPAGE); }
void MainWindow::showNotificationsPage() { mainStack->setCurrentIndex(NOTIFICATIONSPAGE); }
void MainWindow::showPlaylistPage() { mainStack->setCurrentIndex(PLAYLISTPAGE); }

void MainWindow::searchMusic()
{
    qDebug() << "–ó–∞–ø—É—Å–∫ –ø–æ–∏—Å–∫–∞ –º—É–∑—ã–∫–∏...";
    
    QString query = searchInput->text().trimmed();
    if (query.isEmpty()) {
        trackInfo->setPlainText("–í–≤–µ–¥–∏—Ç–µ –ø–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å!");
        return;
    }
    
    tracksList->clear();
    trackInfo->setPlainText("–ü–æ–∏—Å–∫ —Ç—Ä–µ–∫–æ–≤...");
    
    enableSearchControls(false);
    
    QApplication::processEvents();
    
    qDebug() << "–ü–æ–∏—Å–∫ –ø–æ –∑–∞–ø—Ä–æ—Å—É:" << query;
    apiManager->searchTracks(query, currentUserId);
}

void MainWindow::showTopTracks()
{
    tracksList->clear();
    trackInfo->setPlainText("–ó–∞–≥—Ä—É–∑–∫–∞ –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö —Ç—Ä–µ–∫–æ–≤...");
    
    enableSearchControls(false);
    QApplication::processEvents();
    
    qDebug() << "Loading top tracks";
    apiManager->getTopTracks(currentUserId);
}

void MainWindow::onTracksFound(const QVariantList& tracks)
{
    enableSearchControls(true);
    
    tracksList->clear();
    
    if (tracks.isEmpty()) {
        trackInfo->setPlainText("–¢—Ä–µ–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã!");
        return;
    }
    
    for (const QVariant &trackVar : tracks) {
        QVariantMap track = trackVar.toMap();
        QString title = track["title"].toString();
        QString artist = track["artist"].toString();
        QString listeners = track.value("listeners", "N/A").toString();
        QString coverUrl = track.value("coverUrl", "").toString();
        
        QString itemText = QString("%1 - %2").arg(title).arg(artist);
        if (listeners != "N/A") {
            itemText += QString(" [%1]").arg(listeners);
        }
        
        QListWidgetItem *item = new QListWidgetItem(itemText, tracksList);
        
        QString trackInfoText = QString(
            "–¢—Ä–µ–∫: %1\n"
            "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å: %2\n"
            "–ü—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–π: %3\n"
            "–û–±–ª–æ–∂–∫–∞: %4\n\n"
            "–î–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫—É –Ω–∞–∂–º–∏—Ç–µ –ø—Ä–∞–≤–æ–π –∫–Ω–æ–ø–∫–æ–π –º—ã—à–∏"
        ).arg(title).arg(artist).arg(listeners).arg(coverUrl.isEmpty() ? "–ù–µ—Ç" : "–ï—Å—Ç—å");
        
        item->setData(Qt::UserRole, trackInfoText);
        item->setData(Qt::UserRole + 1, track);
    }
    
    trackInfo->setPlainText(QString("–ù–∞–π–¥–µ–Ω–æ —Ç—Ä–µ–∫–æ–≤: %1\n\n–í—ã–±–µ—Ä–∏—Ç–µ —Ç—Ä–µ–∫ –¥–ª—è –ø–æ–¥—Ä–æ–±–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏.").arg(tracks.size()));
}

void MainWindow::onNetworkError(const QString& error)
{
    enableSearchControls(true);
    
    QMessageBox::critical(this, "–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞", 
        QString("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –º—É–∑—ã–∫–∏:\n%1").arg(error));
}

void MainWindow::enableSearchControls(bool enable)
{
    searchButton->setEnabled(enable);
    topTracksButton->setEnabled(enable);
    searchInput->setEnabled(enable);
    
    QString style = enable ? 
        "QPushButton { background: #8A2BE2; }" :
        "QPushButton { background: rgba(138, 43, 226, 0.3); color: rgba(255, 255, 255, 0.5); }";
    
    searchButton->setStyleSheet(style);
    topTracksButton->setStyleSheet(style);
}

=== DanilKurs/src/gui/MainWindow/MainWindow.h ===
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QWidget>
#include <QLabel>
#include <QPushButton>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QStackedWidget>
#include <QLineEdit>
#include <QListWidget>
#include <QTextEdit>
#include "../Frameless/FramelessWindow.h"
#include "database/DatabaseManager.h"
#include "database/api/MusicAPIManager.h"
#include "audio/AudioPlayer.h"
#include "core/models/Track.h"
#include "pages/FriendsPage.h"
#include "pages/MessagesPage.h"

class MainWindow : public FramelessWindow
{
    Q_OBJECT

public:
    explicit MainWindow(const QString& username, int userId, QWidget *parent = nullptr);
    ~MainWindow();

protected:
    bool eventFilter(QObject *obj, QEvent *event) override;

private slots:
    void onAvatarButtonEnter();
    void onAvatarButtonLeave();
    void changeAvatar();
    void searchMusic();
    void showTopTracks();
    void onTracksFound(const QVariantList& tracks);
    void onNetworkError(const QString& error);
    void loadUserTracks();
    void onPlaylistItemClicked(QListWidgetItem* item);
    void playTrack(int trackId);
    void onTrackDeleteRequested(int trackId);
    void showProfilePage();
    void showMessagesPage();
    void showFriendsPage();
    void showNotificationsPage();
    void showPlaylistPage();
    void showRoomsPage();

private:
    void setupUI();
    void createSidebar();
    void createPages();
    void createMyMusicPage();
    void createMusicPage();
    void createRoomsPage();
    QWidget* createSimplePage(const QString& title, const QString& description);
    void setupConnections();
    void setupAvatar();
    void loadUserAvatar();
    void setAvatarPixmap(const QPixmap& pixmap);
    void setDefaultAvatar();
    void saveAvatar(const QPixmap& avatar);
    void showAvatarOverlay();
    void hideAvatarOverlay();
    void enableSearchControls(bool enable);
    void setupGreetingMessages();

    QLabel* greetingLabel;
    QTimer* greetingTimer;
    QStringList greetingMessages;
    int greetingIndex;

    QString currentUsername;
    int currentUserId;
    
    QWidget* sidebar;
    QPushButton* avatarButton;
    QLabel* avatarOverlay;
    QLabel* usernameLabel;
    QPushButton* profileBtn;
    QPushButton* messagesBtn;
    QPushButton* friendsBtn;
    QPushButton* notificationsBtn;
    QPushButton* playlistBtn;
    QPushButton* musicSearchBtn;
    QPushButton* myMusicBtn;
    QPushButton* roomsBtn;
    
    QStackedWidget* mainStack;
    QWidget* profilePage;
    FriendsPage* friendsPage;
    MessagesPage* messagesPage;
    QWidget* notificationsPage;
    QWidget* playlistPage;
    QWidget* musicPage;
    QWidget* myMusicPage;
    QWidget* roomsPage;
    
    QLineEdit* searchInput;
    QPushButton* searchButton;
    QPushButton* topTracksButton;
    QListWidget* tracksList;
    QTextEdit* trackInfo;
    
    QListWidget* userTracksList;
    QPushButton* refreshTracksBtn;
    QPushButton* addLocalTrackBtn;
    
    MusicAPIManager* apiManager;
    AudioPlayer* audioPlayer;
    
    QVector<TrackData> currentTracks;
    int currentTrackIndex;
    
    enum PageIndex {
        MYMUSICPAGE = 0,
        PROFILEPAGE = 1,
        MESSAGESPAGE = 2,
        FRIENDSPAGE = 3,
        NOTIFICATIONSPAGE = 4,
        PLAYLISTPAGE = 5,
        MUSICPAGE = 6,
        ROOMSPAGE = 7
    };
};

#endif


=== DanilKurs/src/gui/AuthWindow/widgets/LoginForm.cpp ===
#include "LoginForm.h"
#include "database/DatabaseManager.h"
#include <QVBoxLayout>
#include <QLabel>
#include <QMessageBox>

LoginForm::LoginForm(QWidget *parent)
    : QWidget(parent)
{
    setupUI();
}

void LoginForm::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setSpacing(25);
    
    QLabel* titleLabel = new QLabel("–í—Ö–æ–¥ –≤ –∞–∫–∫–∞—É–Ω—Ç");
    titleLabel->setStyleSheet("color: white; font-size: 24px; font-weight: bold; text-align: center;");
    titleLabel->setAlignment(Qt::AlignCenter);
    
    m_usernameInput = new QLineEdit();
    m_usernameInput->setPlaceholderText("–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è");
    m_usernameInput->setMinimumHeight(45);
    m_usernameInput->setStyleSheet(R"(
        QLineEdit {
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 0 15px;
            color: white;
            font-size: 14px;
        }
        QLineEdit:focus {
            border: 2px solid #8A2BE2;
        }
    )");
    
    m_passwordInput = new QLineEdit();
    m_passwordInput->setPlaceholderText("–ü–∞—Ä–æ–ª—å");
    m_passwordInput->setEchoMode(QLineEdit::Password);
    m_passwordInput->setMinimumHeight(45);
    m_passwordInput->setStyleSheet(m_usernameInput->styleSheet());
    
    m_loginButton = new QPushButton("–í–û–ô–¢–ò");
    m_loginButton->setMinimumHeight(45);
    m_loginButton->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");
    
    m_registerButton = new QPushButton("–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –∞–∫–∫–∞—É–Ω—Ç");
    m_registerButton->setStyleSheet(R"(
        QPushButton {
            background: transparent;
            color: #8A2BE2;
            border: 2px solid #8A2BE2;
            border-radius: 10px;
            font-size: 14px;
            padding: 12px;
            font-weight: 500;
        }
        QPushButton:hover {
            background: rgba(138, 43, 226, 0.1);
        }
    )");
    
    mainLayout->addWidget(titleLabel);
    mainLayout->addSpacing(10);
    mainLayout->addWidget(m_usernameInput);
    mainLayout->addWidget(m_passwordInput);
    mainLayout->addWidget(m_loginButton);
    mainLayout->addWidget(m_registerButton);
    mainLayout->addStretch();
    
    connect(m_loginButton, &QPushButton::clicked, this, &LoginForm::onLoginClicked);
    connect(m_registerButton, &QPushButton::clicked, this, &LoginForm::switchToRegister);
    connect(m_passwordInput, &QLineEdit::returnPressed, this, &LoginForm::onLoginClicked);
}

bool LoginForm::validateInput()
{
    if (m_usernameInput->text().trimmed().isEmpty()) {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–í–≤–µ–¥–∏—Ç–µ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è");
        return false;
    }
    
    if (m_passwordInput->text().isEmpty()) {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å");
        return false;
    }
    
    return true;
}

void LoginForm::onLoginClicked()
{
    if (!validateInput()) return;
    
    QString username = m_usernameInput->text().trimmed();
    QString password = m_passwordInput->text();
    
    if (DatabaseManager::instance().authenticateUser(username, password)) {
        int userId = DatabaseManager::instance().getUserId(username);
        emit loginSuccess(username, userId);
    } else {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ù–µ–≤–µ—Ä–Ω–æ–µ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–ª–∏ –ø–∞—Ä–æ–ª—å");
    }
}


=== DanilKurs/src/gui/AuthWindow/widgets/LoginForm.h ===
#ifndef LOGINFORM_H
#define LOGINFORM_H

#include <QWidget>
#include <QLineEdit>
#include <QPushButton>

class LoginForm : public QWidget
{
    Q_OBJECT

public:
    explicit LoginForm(QWidget *parent = nullptr);

signals:
    void loginSuccess(const QString& username, int userId);
    void switchToRegister();

private slots:
    void onLoginClicked();

private:
    void setupUI();
    bool validateInput();
    
    QLineEdit* m_usernameInput;
    QLineEdit* m_passwordInput;
    QPushButton* m_loginButton;
    QPushButton* m_registerButton;
};

#endif


=== DanilKurs/src/gui/AuthWindow/widgets/RegisterForm.h ===
#ifndef REGISTERFORM_H
#define REGISTERFORM_H

#include <QWidget>
#include <QLineEdit>
#include <QPushButton>

class RegisterForm : public QWidget
{
    Q_OBJECT

public:
    explicit RegisterForm(QWidget *parent = nullptr);

signals:
    void registerSuccess();
    void switchToLogin();

private slots:
    void onRegisterClicked();

private:
    void setupUI();
    bool validateInput();
    
    QLineEdit* m_emailInput;
    QLineEdit* m_usernameInput;
    QLineEdit* m_passwordInput;
    QLineEdit* m_confirmPasswordInput;
    QPushButton* m_registerButton;
    QPushButton* m_loginButton;
};

#endif


=== DanilKurs/src/gui/AuthWindow/widgets/RegisterForm.cpp ===
#include "RegisterForm.h"
#include "database/DatabaseManager.h"
#include <QVBoxLayout>
#include <QLabel>
#include <QMessageBox>
#include <QRegularExpression>

RegisterForm::RegisterForm(QWidget *parent)
    : QWidget(parent)
{
    setupUI();
}

void RegisterForm::setupUI()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setSpacing(20);
    
    QLabel* titleLabel = new QLabel("–°–æ–∑–¥–∞—Ç—å –∞–∫–∫–∞—É–Ω—Ç");
    titleLabel->setStyleSheet("color: white; font-size: 24px; font-weight: bold; text-align: center;");
    titleLabel->setAlignment(Qt::AlignCenter);
    
    QString inputStyle = R"(
        QLineEdit {
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 0 15px;
            color: white;
            font-size: 14px;
        }
        QLineEdit:focus {
            border: 2px solid #8A2BE2;
        }
    )";
    
    m_emailInput = new QLineEdit();
    m_emailInput->setPlaceholderText("Email –∞–¥—Ä–µ—Å");
    m_emailInput->setMinimumHeight(40);
    m_emailInput->setStyleSheet(inputStyle);
    
    m_usernameInput = new QLineEdit();
    m_usernameInput->setPlaceholderText("–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è");
    m_usernameInput->setMinimumHeight(40);
    m_usernameInput->setStyleSheet(inputStyle);
    
    m_passwordInput = new QLineEdit();
    m_passwordInput->setPlaceholderText("–ü–∞—Ä–æ–ª—å");
    m_passwordInput->setEchoMode(QLineEdit::Password);
    m_passwordInput->setMinimumHeight(40);
    m_passwordInput->setStyleSheet(inputStyle);
    
    m_confirmPasswordInput = new QLineEdit();
    m_confirmPasswordInput->setPlaceholderText("–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å");
    m_confirmPasswordInput->setEchoMode(QLineEdit::Password);
    m_confirmPasswordInput->setMinimumHeight(40);
    m_confirmPasswordInput->setStyleSheet(inputStyle);
    
    QLabel* rulesLabel = new QLabel(
        "‚Ä¢ –ú–∏–Ω–∏–º—É–º 6 —Å–∏–º–≤–æ–ª–æ–≤\n"
        "‚Ä¢ –ë—É–∫–≤—ã –∏ —Ü–∏—Ñ—Ä—ã\n"
        "‚Ä¢ –ë–µ–∑ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤"
    );
    rulesLabel->setStyleSheet(R"(
        color: rgba(255, 255, 255, 0.5);
        font-size: 12px;
        background: rgba(255, 255, 255, 0.05);
        padding: 10px;
        border-radius: 8px;
    )");
    
    m_registerButton = new QPushButton("–ó–ê–†–ï–ì–ò–°–¢–†–ò–†–û–í–ê–¢–¨–°–Ø");
    m_registerButton->setMinimumHeight(45);
    m_registerButton->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");
    
    m_loginButton = new QPushButton("–£–∂–µ –µ—Å—Ç—å –∞–∫–∫–∞—É–Ω—Ç? –í–æ–π—Ç–∏");
    m_loginButton->setStyleSheet(R"(
        QPushButton {
            background: transparent;
            color: #8A2BE2;
            border: 2px solid #8A2BE2;
            border-radius: 10px;
            font-size: 14px;
            padding: 12px;
            font-weight: 500;
        }
        QPushButton:hover {
            background: rgba(138, 43, 226, 0.1);
        }
    )");
    
    mainLayout->addWidget(titleLabel);
    mainLayout->addWidget(m_emailInput);
    mainLayout->addWidget(m_usernameInput);
    mainLayout->addWidget(m_passwordInput);
    mainLayout->addWidget(m_confirmPasswordInput);
    mainLayout->addWidget(rulesLabel);
    mainLayout->addWidget(m_registerButton);
    mainLayout->addWidget(m_loginButton);
    mainLayout->addStretch();
    
    connect(m_registerButton, &QPushButton::clicked, this, &RegisterForm::onRegisterClicked);
    connect(m_loginButton, &QPushButton::clicked, this, &RegisterForm::switchToLogin);
}

bool RegisterForm::validateInput()
{
    QString email = m_emailInput->text().trimmed();
    QString username = m_usernameInput->text().trimmed();
    QString password = m_passwordInput->text();
    QString confirmPassword = m_confirmPasswordInput->text();
    
    if (email.isEmpty() || username.isEmpty() || password.isEmpty() || confirmPassword.isEmpty()) {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–í—Å–µ –ø–æ–ª—è –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω—ã");
        return false;
    }
    
    QRegularExpression emailRegex("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$");
    if (!emailRegex.match(email).hasMatch()) {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç email");
        return false;
    }
    
    if (username.length() < 3) {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–æ–ª–∂–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 3 —Å–∏–º–≤–æ–ª–∞");
        return false;
    }
    
    if (password.length() < 6) {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 6 —Å–∏–º–≤–æ–ª–æ–≤");
        return false;
    }
    
    if (password != confirmPassword) {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ü–∞—Ä–æ–ª–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç");
        return false;
    }
    
    return true;
}

void RegisterForm::onRegisterClicked()
{
    if (!validateInput()) return;
    
    QString username = m_usernameInput->text().trimmed();
    QString password = m_passwordInput->text();
    
    if (DatabaseManager::instance().registerUser(username, password)) {
        QMessageBox::information(this, "–£—Å–ø–µ—Ö", "–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ!");
        emit registerSuccess();
    } else {
        QMessageBox::warning(this, "–û—à–∏–±–∫–∞", "–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —É–∂–µ –∑–∞–Ω—è—Ç–æ");
    }
}


=== DanilKurs/src/gui/AuthWindow/AuthWindow.h ===
#ifndef AUTHWINDOW_H
#define AUTHWINDOW_H

#include <QMainWindow>
#include <QStackedWidget>

class LoginForm;
class RegisterForm;

class AuthWindow : public QMainWindow
{
    Q_OBJECT

public:
    explicit AuthWindow(QWidget *parent = nullptr);
    ~AuthWindow();

protected:
    bool eventFilter(QObject *obj, QEvent *event) override;

private slots:
    void onLoginSuccess(const QString& username, int userId);
    void onRegisterSuccess();
    void switchToLogin();
    void switchToRegister();

private:
    void setupUI();
    void showMainWindow(const QString& username, int userId);
    
    QStackedWidget* m_stackedWidget;
    LoginForm* m_loginForm;
    RegisterForm* m_registerForm;
    
    QWidget* m_titleBarWidget;
    bool m_dragging;
    QPoint m_dragPosition;
};

#endif


=== DanilKurs/src/gui/AuthWindow/AuthWindow.cpp ===
#include "AuthWindow.h"
#include "gui/AuthWindow/widgets/LoginForm.h"
#include "gui/AuthWindow/widgets/RegisterForm.h"
#include "gui/MainWindow/MainWindow.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QPushButton>
#include <QMouseEvent>

AuthWindow::AuthWindow(QWidget *parent)
    : QMainWindow(parent)
    , m_stackedWidget(new QStackedWidget(this))
    , m_dragging(false)
{
    setupUI();
    
    setWindowTitle("Chorus");
    setFixedSize(500, 650);
    setWindowFlags(Qt::FramelessWindowHint);
    setAttribute(Qt::WA_TranslucentBackground);
}

AuthWindow::~AuthWindow()
{
}

void AuthWindow::setupUI()
{
    QWidget* central = new QWidget();
    central->setObjectName("centralWidget");
    central->setStyleSheet(R"(
        #centralWidget {
            background: #0F0F14;
            border-radius: 20px;
        }
    )");
    
    setCentralWidget(central);
    
    QVBoxLayout* mainLayout = new QVBoxLayout(central);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);
    
    m_titleBarWidget = new QWidget();
    m_titleBarWidget->setFixedHeight(50);
    m_titleBarWidget->setStyleSheet("background: transparent;");
    m_titleBarWidget->installEventFilter(this);
    
    QHBoxLayout* titleLayout = new QHBoxLayout(m_titleBarWidget);
    titleLayout->setContentsMargins(20, 0, 20, 0);
    
    QLabel* logo = new QLabel("Chorus");
    logo->setStyleSheet("color: #8A2BE2; font-size: 20px; font-weight: 800;");
    
    QWidget* windowButtons = new QWidget();
    QHBoxLayout* buttonsLayout = new QHBoxLayout(windowButtons);
    buttonsLayout->setContentsMargins(0, 0, 0, 0);
    buttonsLayout->setSpacing(5);
    
    QPushButton* minimizeBtn = new QPushButton("‚Äî");
    QPushButton* closeBtn = new QPushButton("√ó");
    
    QString windowBtnStyle = R"(
        QPushButton {
            background: transparent;
            color: rgba(255, 255, 255, 0.6);
            border: none;
            font-size: 20px;
            min-width: 30px;
            min-height: 30px;
            border-radius: 4px;
        }
        QPushButton:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        QPushButton#closeBtn:hover {
            background: #FF4444;
        }
    )";
    
    minimizeBtn->setStyleSheet(windowBtnStyle);
    closeBtn->setStyleSheet(windowBtnStyle);
    closeBtn->setObjectName("closeBtn");
    
    buttonsLayout->addWidget(minimizeBtn);
    buttonsLayout->addWidget(closeBtn);
    
    titleLayout->addWidget(logo);
    titleLayout->addStretch();
    titleLayout->addWidget(windowButtons);
    
    connect(minimizeBtn, &QPushButton::clicked, this, &QMainWindow::showMinimized);
    connect(closeBtn, &QPushButton::clicked, this, &QMainWindow::close);
    
    QWidget* contentWidget = new QWidget();
    QVBoxLayout* contentLayout = new QVBoxLayout(contentWidget);
    contentLayout->setContentsMargins(40, 20, 40, 40);
    
    m_loginForm = new LoginForm();
    m_registerForm = new RegisterForm();
    
    m_stackedWidget->addWidget(m_loginForm);
    m_stackedWidget->addWidget(m_registerForm);
    
    contentLayout->addWidget(m_stackedWidget);
    
    mainLayout->addWidget(m_titleBarWidget);
    mainLayout->addWidget(contentWidget, 1);
    
    connect(m_loginForm, &LoginForm::loginSuccess, this, &AuthWindow::onLoginSuccess);
    connect(m_loginForm, &LoginForm::switchToRegister, this, &AuthWindow::switchToRegister);
    connect(m_registerForm, &RegisterForm::registerSuccess, this, &AuthWindow::onRegisterSuccess);
    connect(m_registerForm, &RegisterForm::switchToLogin, this, &AuthWindow::switchToLogin);
}

bool AuthWindow::eventFilter(QObject *obj, QEvent *event)
{
    if (obj == m_titleBarWidget) {
        if (event->type() == QEvent::MouseButtonPress) {
            QMouseEvent *mouseEvent = static_cast<QMouseEvent*>(event);
            if (mouseEvent->button() == Qt::LeftButton) {
                m_dragging = true;
                m_dragPosition = mouseEvent->globalPos() - frameGeometry().topLeft();
                return true;
            }
        } else if (event->type() == QEvent::MouseMove && m_dragging) {
            QMouseEvent *mouseEvent = static_cast<QMouseEvent*>(event);
            move(mouseEvent->globalPos() - m_dragPosition);
            return true;
        } else if (event->type() == QEvent::MouseButtonRelease) {
            m_dragging = false;
            return true;
        }
    }
    return QMainWindow::eventFilter(obj, event);
}

void AuthWindow::switchToLogin()
{
    m_stackedWidget->setCurrentIndex(0);
}

void AuthWindow::switchToRegister()
{
    m_stackedWidget->setCurrentIndex(1);
}

void AuthWindow::onLoginSuccess(const QString& username, int userId)
{
    showMainWindow(username, userId);
}

void AuthWindow::onRegisterSuccess()
{
    switchToLogin();
}

void AuthWindow::showMainWindow(const QString& username, int userId)
{
    MainWindow* mainWindow = new MainWindow(username, userId);
    mainWindow->show();
    this->close();
}


=== DanilKurs/src/gui/Frameless/FramelessWindow.cpp ===
#include "FramelessWindow.h"
#include <QApplication>
#include <QDebug>

FramelessWindow::FramelessWindow(QWidget *parent)
    : QMainWindow(parent)
{
    setWindowFlags(Qt::FramelessWindowHint);
    setAttribute(Qt::WA_TranslucentBackground);
    
    // –í–∫–ª—é—á–∞–µ–º —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ
    setAttribute(Qt::WA_NoSystemBackground, false);
    setAttribute(Qt::WA_OpaquePaintEvent, true);
    
    // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–Ω—å –æ–∫–Ω—É —Å –±–æ–ª–µ–µ –º—è–≥–∫–∏–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏
    QGraphicsDropShadowEffect *shadow = new QGraphicsDropShadowEffect();
    shadow->setBlurRadius(25); // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º—ã—Ç–∏–µ
    shadow->setXOffset(0);
    shadow->setYOffset(0);
    shadow->setColor(QColor(0, 0, 0, 40)); // –ë–æ–ª–µ–µ –ø—Ä–æ–∑—Ä–∞—á–Ω–∞—è —Ç–µ–Ω—å
    
    QWidget *central = new QWidget();
    central->setObjectName("windowContent");
    central->setGraphicsEffect(shadow);
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ –¥–ª—è —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–≥–æ –≤–∏–¥–∂–µ—Ç–∞
    central->setAttribute(Qt::WA_NoSystemBackground, false);
    central->setAttribute(Qt::WA_OpaquePaintEvent, true);
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–æ–Ω–æ–≤—É—é –∫–∏—Å—Ç—å —Å —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ–º
    QPalette pal = central->palette();
    pal.setColor(QPalette::Window, QColor(15, 15, 20));
    central->setPalette(pal);
    central->setAutoFillBackground(true);
    
    setCentralWidget(central);
}

void FramelessWindow::mousePressEvent(QMouseEvent *event)
{
    if (event->button() == Qt::LeftButton) {
        m_dragging = true;
        m_dragPosition = event->globalPos() - frameGeometry().topLeft();
        event->accept();
    }
}

void FramelessWindow::mouseMoveEvent(QMouseEvent *event)
{
    if (event->buttons() & Qt::LeftButton && m_dragging) {
        move(event->globalPos() - m_dragPosition);
        event->accept();
    }
}

void FramelessWindow::mouseReleaseEvent(QMouseEvent *event)
{
    if (event->button() == Qt::LeftButton) {
        m_dragging = false;
        event->accept();
    }
}

=== DanilKurs/src/gui/Frameless/FramelessWindow.h ===
#ifndef FRAMELESSWINDOW_H
#define FRAMELESSWINDOW_H

#include <QMainWindow>
#include <QMouseEvent>
#include <QGraphicsDropShadowEffect>

class FramelessWindow : public QMainWindow
{
    Q_OBJECT

public:
    explicit FramelessWindow(QWidget *parent = nullptr);
    
protected:
    void mousePressEvent(QMouseEvent *event) override;
    void mouseMoveEvent(QMouseEvent *event) override;
    void mouseReleaseEvent(QMouseEvent *event) override;
    
private:
    bool m_dragging = false;
    QPoint m_dragPosition;
};

#endif // FRAMELESSWINDOW_H

=== DanilKurs/src/audio/AudioPlayer.cpp ===
#include "AudioPlayer.h"
#include <QSlider>
#include <QLabel>
#include <QToolButton>
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QStyle>
#include <QTime>
#include <QApplication>
#include <QGraphicsDropShadowEffect>

AudioPlayer::AudioPlayer(QObject *parent)
    : QObject(parent)
    , mediaPlayer(new QMediaPlayer(this))
    , playerControls(nullptr)
    , nowPlayingLabel(nullptr)
    , currentTimeLabel(nullptr)
    , totalTimeLabel(nullptr)
    , progressSlider(nullptr)
    , playPauseBtn(nullptr)
    , previousBtn(nullptr)
    , nextBtn(nullptr)
    , volumeSlider(nullptr)
{
    mediaPlayer->setVolume(50);
}

AudioPlayer::~AudioPlayer()
{
}

void AudioPlayer::setupPlayerControls(QWidget *parent)
{
    playerControls = new QWidget(parent);
    playerControls->setFixedHeight(100);
    playerControls->setStyleSheet(R"(
        QWidget {
            background: rgba(15, 15, 20, 0.95);
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }
    )");
    
    QHBoxLayout *layout = new QHBoxLayout(playerControls);
    layout->setContentsMargins(30, 15, 30, 15);
    layout->setSpacing(20);
    
    // –õ–µ–≤–∞—è —á–∞—Å—Ç—å: –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç—Ä–µ–∫–µ
    QWidget *trackInfoWidget = new QWidget();
    trackInfoWidget->setFixedWidth(250);
    QVBoxLayout *trackLayout = new QVBoxLayout(trackInfoWidget);
    trackLayout->setContentsMargins(0, 0, 0, 0);
    trackLayout->setSpacing(5);
    
    nowPlayingLabel = new QLabel("–ù–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—Å—è");
    nowPlayingLabel->setStyleSheet(R"(
        QLabel {
            color: #FFFFFF;
            font-size: 14px;
            font-weight: 600;
            background: transparent;
        }
    )");
    nowPlayingLabel->setWordWrap(true);
    
    QLabel *artistLabel = new QLabel("SoundSpace");
    artistLabel->setStyleSheet(R"(
        QLabel {
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            background: transparent;
        }
    )");
    
    trackLayout->addWidget(nowPlayingLabel);
    trackLayout->addWidget(artistLabel);
    layout->addWidget(trackInfoWidget);
    
    // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è —á–∞—Å—Ç—å: —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ–º
    QWidget *controlsWidget = new QWidget();
    QVBoxLayout *controlsLayout = new QVBoxLayout(controlsWidget);
    controlsLayout->setContentsMargins(0, 0, 0, 0);
    controlsLayout->setSpacing(10);
    
    QHBoxLayout *playbackLayout = new QHBoxLayout();
    playbackLayout->setAlignment(Qt::AlignCenter);
    playbackLayout->setSpacing(15);
    
    // –°—Ç–∏–ª–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫ –ø–ª–µ–µ—Ä–∞
    QString playerBtnStyle = R"(
        QToolButton {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            border-radius: 15px;
        }
        QToolButton:hover {
            color: #FFFFFF;
            background: rgba(255, 255, 255, 0.1);
        }
    )";
    
    previousBtn = new QToolButton();
    previousBtn->setIcon(QIcon::fromTheme("media-skip-backward"));
    previousBtn->setStyleSheet(playerBtnStyle);
    previousBtn->setFixedSize(40, 40);
    
    playPauseBtn = new QToolButton();
    playPauseBtn->setIcon(QIcon::fromTheme("media-playback-start"));
    playPauseBtn->setStyleSheet(R"(
        QToolButton {
            background: #8A2BE2;
            border: none;
            border-radius: 20px;
            color: white;
            padding: 10px;
        }
        QToolButton:hover {
            background: #9B4BFF;
        }
    )");
    playPauseBtn->setFixedSize(50, 50);
    
    nextBtn = new QToolButton();
    nextBtn->setIcon(QIcon::fromTheme("media-skip-forward"));
    nextBtn->setStyleSheet(playerBtnStyle);
    nextBtn->setFixedSize(40, 40);
    
    playbackLayout->addWidget(previousBtn);
    playbackLayout->addWidget(playPauseBtn);
    playbackLayout->addWidget(nextBtn);
    
    // –ü—Ä–æ–≥—Ä–µ—Å—Å –±–∞—Ä —Å –≤—Ä–µ–º–µ–Ω–µ–º
    QHBoxLayout *progressLayout = new QHBoxLayout();
    progressLayout->setSpacing(10);
    
    currentTimeLabel = new QLabel("0:00");
    currentTimeLabel->setStyleSheet(R"(
        QLabel {
            color: rgba(255, 255, 255, 0.5);
            font-size: 11px;
            min-width: 40px;
        }
    )");
    
    progressSlider = new QSlider(Qt::Horizontal);
    progressSlider->setStyleSheet(R"(
        QSlider::groove:horizontal {
            background: rgba(255, 255, 255, 0.1);
            height: 4px;
            border-radius: 2px;
        }
        QSlider::sub-page:horizontal {
            background: #8A2BE2;
            border-radius: 2px;
        }
        QSlider::handle:horizontal {
            background: #FFFFFF;
            width: 12px;
            height: 12px;
            margin: -4px 0;
            border-radius: 6px;
        }
        QSlider::handle:horizontal:hover {
            background: #8A2BE2;
            width: 14px;
            height: 14px;
            margin: -5px 0;
        }
    )");
    
    totalTimeLabel = new QLabel("0:00");
    totalTimeLabel->setStyleSheet(R"(
        QLabel {
            color: rgba(255, 255, 255, 0.5);
            font-size: 11px;
            min-width: 40px;
        }
    )");
    
    progressLayout->addWidget(currentTimeLabel);
    progressLayout->addWidget(progressSlider, 1);
    progressLayout->addWidget(totalTimeLabel);
    
    controlsLayout->addLayout(playbackLayout);
    controlsLayout->addLayout(progressLayout);
    layout->addWidget(controlsWidget, 1);
    
    // –ü—Ä–∞–≤–∞—è —á–∞—Å—Ç—å: –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
    QWidget *rightWidget = new QWidget();
    rightWidget->setFixedWidth(200);
    QHBoxLayout *rightLayout = new QHBoxLayout(rightWidget);
    rightLayout->setContentsMargins(0, 0, 0, 0);
    rightLayout->setSpacing(15);
    
    // –ö–Ω–æ–ø–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ
    QToolButton *likeBtn = new QToolButton();
    likeBtn->setText("‚ô°");
    likeBtn->setStyleSheet(R"(
        QToolButton {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 16px;
        }
        QToolButton:hover {
            color: #FF4444;
        }
        QToolButton[liked="true"] {
            color: #FF4444;
        }
    )");
    
    // –ü–æ–ª–∑—É–Ω–æ–∫ –≥—Ä–æ–º–∫–æ—Å—Ç–∏
    QWidget *volumeWidget = new QWidget();
    QHBoxLayout *volumeLayout = new QHBoxLayout(volumeWidget);
    volumeLayout->setContentsMargins(0, 0, 0, 0);
    volumeLayout->setSpacing(8);
    
    QToolButton *volumeIcon = new QToolButton();
    volumeIcon->setText("üîä");
    volumeIcon->setStyleSheet(playerBtnStyle);
    
    volumeSlider = new QSlider(Qt::Horizontal);
    volumeSlider->setRange(0, 100);
    volumeSlider->setValue(50);
    volumeSlider->setFixedWidth(80);
    volumeSlider->setStyleSheet(R"(
        QSlider::groove:horizontal {
            background: rgba(255, 255, 255, 0.1);
            height: 4px;
            border-radius: 2px;
        }
        QSlider::sub-page:horizontal {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }
        QSlider::handle:horizontal {
            background: #FFFFFF;
            width: 10px;
            height: 10px;
            margin: -3px 0;
            border-radius: 5px;
        }
        QSlider::handle:horizontal:hover {
            background: #8A2BE2;
        }
    )");
    
    volumeLayout->addWidget(volumeIcon);
    volumeLayout->addWidget(volumeSlider);
    
    rightLayout->addWidget(likeBtn);
    rightLayout->addWidget(volumeWidget);
    layout->addWidget(rightWidget);
    
    // –ü–æ–¥–∫–ª—é—á–∞–µ–º —Å–∏–≥–Ω–∞–ª—ã
    connect(playPauseBtn, &QToolButton::clicked, this, &AudioPlayer::playSelectedTrack);
    connect(previousBtn, &QToolButton::clicked, this, &AudioPlayer::trackFinished);
    connect(nextBtn, &QToolButton::clicked, this, &AudioPlayer::trackFinished);
    connect(progressSlider, &QSlider::sliderMoved, this, &AudioPlayer::seekTrack);
    
    // –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π connect –¥–ª—è volumeSlider
    connect(volumeSlider, &QSlider::valueChanged, this, [this, volumeIcon](int value) {
        mediaPlayer->setVolume(value);
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –∏–∫–æ–Ω–∫—É –≥—Ä–æ–º–∫–æ—Å—Ç–∏
        if (value == 0) {
            volumeIcon->setText("üîá");
        } else if (value < 33) {
            volumeIcon->setText("üîà");
        } else if (value < 66) {
            volumeIcon->setText("üîâ");
        } else {
            volumeIcon->setText("üîä");
        }
    });
    
    connect(mediaPlayer, &QMediaPlayer::positionChanged, this, &AudioPlayer::onPositionChanged);
    connect(mediaPlayer, &QMediaPlayer::durationChanged, this, &AudioPlayer::onDurationChanged);
    connect(mediaPlayer, &QMediaPlayer::stateChanged, this, &AudioPlayer::onPlaybackStateChanged);
    
    // –ö–Ω–æ–ø–∫–∞ –ª–∞–π–∫–∞
    connect(likeBtn, &QToolButton::clicked, likeBtn, [likeBtn]() {
        bool liked = likeBtn->property("liked").toBool();
        likeBtn->setProperty("liked", !liked);
        likeBtn->setStyleSheet(likeBtn->styleSheet());
        likeBtn->setText(!liked ? "‚ù§Ô∏è" : "‚ô°");
    });
}

void AudioPlayer::playTrack(const QString& filePath)
{
    mediaPlayer->setMedia(QUrl::fromLocalFile(filePath));
    mediaPlayer->play();
}

void AudioPlayer::pauseTrack()
{
    if (mediaPlayer->state() == QMediaPlayer::PlayingState) {
        mediaPlayer->pause();
    } else {
        mediaPlayer->play();
    }
}

void AudioPlayer::setVolume(int volume)
{
    mediaPlayer->setVolume(volume);
    volumeSlider->setValue(volume);
}

void AudioPlayer::seek(int position)
{
    mediaPlayer->setPosition(position);
}

bool AudioPlayer::isPlaying() const
{
    return mediaPlayer->state() == QMediaPlayer::PlayingState;
}

QString AudioPlayer::formatTime(qint64 milliseconds)
{
    qint64 seconds = milliseconds / 1000;
    qint64 minutes = seconds / 60;
    seconds = seconds % 60;
    return QString("%1:%2").arg(minutes).arg(seconds, 2, 10, QChar('0'));
}

void AudioPlayer::playSelectedTrack()
{
    pauseTrack();
}

void AudioPlayer::onPositionChanged(qint64 position)
{
    if (!progressSlider->isSliderDown()) {
        progressSlider->setValue(position);
    }
    currentTimeLabel->setText(formatTime(position));
}

void AudioPlayer::onDurationChanged(qint64 duration)
{
    progressSlider->setRange(0, duration);
    totalTimeLabel->setText(formatTime(duration));
}

void AudioPlayer::seekTrack(int position)
{
    mediaPlayer->setPosition(position);
}

void AudioPlayer::onPlaybackStateChanged()
{
    updatePlaybackButtons();
}

void AudioPlayer::updatePlaybackButtons()
{
    if (mediaPlayer->state() == QMediaPlayer::PlayingState) {
        playPauseBtn->setIcon(QIcon::fromTheme("media-playback-pause"));
    } else {
        playPauseBtn->setIcon(QIcon::fromTheme("media-playback-start"));
    }
}

void AudioPlayer::updateTrackInfo(const QString& title, const QString& artist)
{
    if (nowPlayingLabel) {
        nowPlayingLabel->setText(title);
        // –û–±–Ω–æ–≤–ª—è–µ–º artistLabel –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        QLabel *artistLabel = nowPlayingLabel->parentWidget()->findChild<QLabel*>();
        if (artistLabel) {
            artistLabel->setText(artist);
        }
    }
}

=== DanilKurs/src/audio/TrackWidget.cpp ===
#include "TrackWidget.h"
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QMenu>

TrackWidget::TrackWidget(const TrackData& track, QWidget *parent)
    : QWidget(parent), m_trackId(track.id)
{
    setupUI(track);
}

void TrackWidget::setupUI(const TrackData& track)
{
    setFixedHeight(60);
    
    QHBoxLayout* mainLayout = new QHBoxLayout(this);
    mainLayout->setContentsMargins(15, 10, 15, 10);
    mainLayout->setSpacing(15);
    
    QWidget* textWidget = new QWidget();
    QVBoxLayout* textLayout = new QVBoxLayout(textWidget);
    textLayout->setContentsMargins(0, 0, 0, 0);
    textLayout->setSpacing(3);
    
    m_titleLabel = new QLabel(track.title);
    m_titleLabel->setStyleSheet("color: white; font-size: 15px; font-weight: 600;");
    
    m_artistLabel = new QLabel(track.artist);
    m_artistLabel->setStyleSheet("color: rgba(255, 255, 255, 0.6); font-size: 13px;");
    
    textLayout->addWidget(m_titleLabel);
    textLayout->addWidget(m_artistLabel);
    
    m_durationLabel = new QLabel(formatDuration(track.duration));
    m_durationLabel->setStyleSheet("color: rgba(255, 255, 255, 0.5); font-size: 13px;");
    m_durationLabel->setFixedWidth(60);
    
    m_playButton = new QPushButton("‚ñ∂");
    m_playButton->setFixedSize(40, 40);
    m_playButton->setStyleSheet(R"(
        QPushButton {
            background: #8A2BE2;
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 14px;
        }
        QPushButton:hover {
            background: #9B4BFF;
        }
    )");
    
    connect(m_playButton, &QPushButton::clicked, [this]() {
        emit playRequested(m_trackId);
    });
    
    mainLayout->addWidget(textWidget, 1);
    mainLayout->addWidget(m_durationLabel);
    mainLayout->addWidget(m_playButton);
    
    setStyleSheet("TrackWidget { background: transparent; }");
}

QString TrackWidget::formatDuration(int seconds)
{
    int minutes = seconds / 60;
    int secs = seconds % 60;
    return QString("%1:%2").arg(minutes).arg(secs, 2, 10, QChar('0'));
}


=== DanilKurs/src/audio/PlaybackController.h ===
#ifndef PLAYBACKCONTROLLER_H
#define PLAYBACKCONTROLLER_H

#include <QObject>
#include <QMediaPlayer>
#include "core/models/Track.h"

class PlaybackController : public QObject
{
    Q_OBJECT

public:
    explicit PlaybackController(QMediaPlayer* player, QObject *parent = nullptr);
    
    void playTrack(const TrackData& track);
    void pause();
    void resume();
    void stop();
    void seek(qint64 position);
    void setVolume(int volume);
    
    bool isPlaying() const;
    qint64 position() const;
    qint64 duration() const;
    int volume() const;

signals:
    void trackChanged(const TrackData& track);
    void stateChanged(QMediaPlayer::State state);
    void positionChanged(qint64 position);
    void durationChanged(qint64 duration);
    void volumeChanged(int volume);

private:
    QMediaPlayer* m_player;
    TrackData m_currentTrack;
};

#endif


=== DanilKurs/src/audio/LocalFileHandler.h ===
#ifndef LOCALFILEHANDLER_H
#define LOCALFILEHANDLER_H

#include <QObject>
#include <QString>
#include <QStringList>

class LocalFileHandler : public QObject
{
    Q_OBJECT

public:
    explicit LocalFileHandler(QObject *parent = nullptr);
    
    QStringList getSupportedFormats() const;
    bool addTrackToDatabase(int userId, const QString& filePath);
    bool scanDirectory(int userId, const QString& directoryPath);

private:
    struct TrackMetadata {
        QString title;
        QString artist;
        QString album;
        int duration;
        QString genre;
        int year;
    };
    
    TrackMetadata extractMetadata(const QString& filePath);
    bool isValidAudioFile(const QString& filePath);
    
    QStringList m_supportedFormats;
};

#endif


=== DanilKurs/src/audio/LocalFileHandler.cpp ===
#include "LocalFileHandler.h"
#include "database/DatabaseManager.h"
#include <QFileInfo>
#include <QDir>
#include <QDirIterator>
#include <QCryptographicHash>
#include <QDebug>
#include <taglib/fileref.h>
#include <taglib/tag.h>
#include <taglib/audioproperties.h>


LocalFileHandler::LocalFileHandler(QObject *parent)
    : QObject(parent)
{
    m_supportedFormats << "mp3" << "wav" << "flac" << "ogg" << "m4a" << "aac";
}


QStringList LocalFileHandler::getSupportedFormats() const
{
    return m_supportedFormats;
}


bool LocalFileHandler::addTrackToDatabase(int userId, const QString& filePath)
{
    if (!isValidAudioFile(filePath)) {
        return false;
    }
    
    TrackMetadata metadata = extractMetadata(filePath);
    
    return DatabaseManager::instance().addTrack(
        filePath,
        metadata.title,
        metadata.artist,
        metadata.album,
        metadata.duration,
        userId
    );
}


bool LocalFileHandler::scanDirectory(int userId, const QString& directoryPath)
{
    QDir dir(directoryPath);
    if (!dir.exists()) {
        return false;
    }
    
    QStringList filters;
    for (const QString& format : m_supportedFormats) {
        filters << "*." + format;
    }
    
    QDirIterator it(directoryPath, filters, QDir::Files, QDirIterator::Subdirectories);
    
    int addedCount = 0;
    while (it.hasNext()) {
        QString filePath = it.next();
        if (addTrackToDatabase(userId, filePath)) {
            addedCount++;
        }
    }
    
    return addedCount > 0;
}


LocalFileHandler::TrackMetadata LocalFileHandler::extractMetadata(const QString& filePath)
{
    TrackMetadata metadata;
    QFileInfo fileInfo(filePath);
    
    metadata.title = fileInfo.completeBaseName();
    metadata.artist = "Unknown Artist";
    metadata.album = "Unknown Album";
    metadata.duration = 0;
    metadata.genre = "";
    metadata.year = 0;
    
    TagLib::FileRef file(filePath.toStdString().c_str());
    
    if (!file.isNull() && file.tag()) {
        TagLib::Tag *tag = file.tag();
        
        if (!tag->title().isEmpty()) {
            metadata.title = QString::fromStdString(tag->title().to8Bit(true));
        }
        if (!tag->artist().isEmpty()) {
            metadata.artist = QString::fromStdString(tag->artist().to8Bit(true));
        }
        if (!tag->album().isEmpty()) {
            metadata.album = QString::fromStdString(tag->album().to8Bit(true));
        }
        if (!tag->genre().isEmpty()) {
            metadata.genre = QString::fromStdString(tag->genre().to8Bit(true));
        }
        metadata.year = tag->year();
        
        if (file.audioProperties()) {
            metadata.duration = file.audioProperties()->lengthInSeconds();
        }
    }
    
    return metadata;
}


bool LocalFileHandler::isValidAudioFile(const QString& filePath)
{
    QFileInfo fileInfo(filePath);
    
    if (!fileInfo.exists()) {
        return false;
    }
    
    QString extension = fileInfo.suffix().toLower();
    return m_supportedFormats.contains(extension);
}


=== DanilKurs/src/audio/AudioPlayer.h ===
#ifndef AUDIOPLAYER_H
#define AUDIOPLAYER_H

#include <QMediaPlayer>
#include <QWidget>

class QSlider;
class QLabel;
class QToolButton;

class AudioPlayer : public QObject
{
    Q_OBJECT

public:
    explicit AudioPlayer(QObject *parent = nullptr);
    ~AudioPlayer();

    void setupPlayerControls(QWidget *parent);
    QWidget* getPlayerControls() const { return playerControls; }

    void playTrack(const QString& filePath);
    void pauseTrack();
    void setVolume(int volume);
    void seek(int position);

    bool isPlaying() const;
    QString formatTime(qint64 milliseconds);

public slots:
    void playSelectedTrack();
    void onPositionChanged(qint64 position);
    void onDurationChanged(qint64 duration);
    void seekTrack(int position);
    void onPlaybackStateChanged();
    void updatePlaybackButtons();
    void updateTrackInfo(const QString& title, const QString& artist);

signals:
    void trackFinished();

private:
    QMediaPlayer *mediaPlayer;
    QWidget *playerControls;
    QLabel *nowPlayingLabel;
    QLabel *currentTimeLabel;
    QLabel *totalTimeLabel;
    QSlider *progressSlider;
    QToolButton *playPauseBtn;
    QToolButton *previousBtn;
    QToolButton *nextBtn;
    QSlider *volumeSlider;
};

#endif

=== DanilKurs/src/audio/TrackWidget.h ===
#ifndef TRACKWIDGET_H
#define TRACKWIDGET_H

#include <QWidget>
#include <QLabel>
#include <QPushButton>
#include "core/models/Track.h"

class TrackWidget : public QWidget
{
    Q_OBJECT

public:
    explicit TrackWidget(const TrackData& track, QWidget *parent = nullptr);
    
    int trackId() const { return m_trackId; }

signals:
    void playRequested(int trackId);
    void addToPlaylistRequested(int trackId);
    void deleteRequested(int trackId);

private:
    void setupUI(const TrackData& track);
    QString formatDuration(int seconds);
    
    int m_trackId;
    QLabel* m_titleLabel;
    QLabel* m_artistLabel;
    QLabel* m_durationLabel;
    QPushButton* m_playButton;
};

#endif


=== DanilKurs/src/audio/PlaybackController.cpp ===
#include "PlaybackController.h"
#include <QUrl>

PlaybackController::PlaybackController(QMediaPlayer* player, QObject *parent)
    : QObject(parent), m_player(player)
{
    connect(m_player, &QMediaPlayer::stateChanged, this, &PlaybackController::stateChanged);
    connect(m_player, &QMediaPlayer::positionChanged, this, &PlaybackController::positionChanged);
    connect(m_player, &QMediaPlayer::durationChanged, this, &PlaybackController::durationChanged);
}

void PlaybackController::playTrack(const TrackData& track)
{
    m_currentTrack = track;
    
    if (track.filePath.startsWith("http://") || track.filePath.startsWith("https://")) {
        m_player->setMedia(QUrl(track.filePath));
    } else {
        m_player->setMedia(QUrl::fromLocalFile(track.filePath));
    }
    
    m_player->play();
    emit trackChanged(track);
}

void PlaybackController::pause()
{
    m_player->pause();
}

void PlaybackController::resume()
{
    m_player->play();
}

void PlaybackController::stop()
{
    m_player->stop();
}

void PlaybackController::seek(qint64 position)
{
    m_player->setPosition(position);
}

void PlaybackController::setVolume(int volume)
{
    m_player->setVolume(volume);
    emit volumeChanged(volume);
}

bool PlaybackController::isPlaying() const
{
    return m_player->state() == QMediaPlayer::PlayingState;
}

qint64 PlaybackController::position() const
{
    return m_player->position();
}

qint64 PlaybackController::duration() const
{
    return m_player->duration();
}

int PlaybackController::volume() const
{
    return m_player->volume();
}


=== DanilKurs/src/database/DatabaseManager.cpp ===
#include "DatabaseManager.h"
#include <QCryptographicHash>
#include <QDebug>
#include <QSqlError>
#include <QSqlQuery>
#include <QCoreApplication>
#include <QFileInfo>
#include <QDateTime>

QMutex DatabaseManager::m_mutex;

DatabaseManager& DatabaseManager::instance() {
    static DatabaseManager instance;
    return instance;
}

DatabaseManager::DatabaseManager(QObject *parent) 
    : QObject(parent), m_initialized(false) {}

DatabaseManager::~DatabaseManager() {
    if (m_db.isOpen()) {
        m_db.close();
    }
}

bool DatabaseManager::initialize() {
    QMutexLocker locker(&m_mutex);
    
    if (m_initialized && m_db.isOpen()) {
        return true;
    }
    
    return openConnection();
}

bool DatabaseManager::openConnection() {
    if (m_db.isOpen()) {
        m_db.close();
    }
    
    m_db = QSqlDatabase::addDatabase("QPSQL", "soundspace_connection");
    
    if (!m_db.isValid()) {
        qDebug() << "PostgreSQL driver unavailable";
        return false;
    }
    
    m_db.setHostName("turntable.proxy.rlwy.net");
    m_db.setPort(26533);
    m_db.setDatabaseName("railway");
    m_db.setUserName("postgres");
    m_db.setPassword("__REMOVED__");
    m_db.setConnectOptions("connect_timeout=10");
    
    if (!m_db.open()) {
        qDebug() << "Connection error:" << m_db.lastError().text();
        return false;
    }
    
    if (!createTables()) {
        qDebug() << "Table creation error";
        return false;
    }
    
    m_initialized = true;
    return true;
}

bool DatabaseManager::createTables() {
    if (!m_db.isOpen()) {
        return false;
    }
    
    bool success = true;
    
    QString createUsers = 
        "CREATE TABLE IF NOT EXISTS users ("
        "id SERIAL PRIMARY KEY, "
        "username VARCHAR(50) UNIQUE NOT NULL, "
        "password_hash VARCHAR(64) NOT NULL, "
        "email VARCHAR(100), "
        "avatar_path TEXT, "
        "status INTEGER DEFAULT 0, "
        "bio TEXT, "
        "last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP, "
        "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)";
    
    QSqlQuery query(m_db);
    if (!query.exec(createUsers)) {
        qDebug() << "users error:" << query.lastError().text();
        success = false;
    }
    
    QString createTracks = 
        "CREATE TABLE IF NOT EXISTS tracks ("
        "id SERIAL PRIMARY KEY, "
        "file_path TEXT NOT NULL, "
        "file_hash VARCHAR(64) NOT NULL, "
        "user_id INTEGER NOT NULL, "
        "title TEXT NOT NULL, "
        "artist TEXT NOT NULL, "
        "album TEXT, "
        "duration INTEGER DEFAULT 0, "
        "play_count INTEGER DEFAULT 0, "
        "added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, "
        "cover_url TEXT, "
        "genre TEXT, "
        "year INTEGER, "
        "bitrate INTEGER, "
        "sample_rate INTEGER)";
    
    if (!query.exec(createTracks)) {
        qDebug() << "tracks error:" << query.lastError().text();
        success = false;
    }
    
    QString createPlaylists = 
        "CREATE TABLE IF NOT EXISTS playlists ("
        "id SERIAL PRIMARY KEY, "
        "user_id INTEGER NOT NULL, "
        "name VARCHAR(100) NOT NULL, "
        "description TEXT, "
        "cover_url TEXT, "
        "is_public BOOLEAN DEFAULT false, "
        "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)";
    
    if (!query.exec(createPlaylists)) {
        qDebug() << "playlists error:" << query.lastError().text();
        success = false;
    }
    
    QString createPlaylistTracks = 
        "CREATE TABLE IF NOT EXISTS playlist_tracks ("
        "playlist_id INTEGER NOT NULL, "
        "track_id INTEGER NOT NULL, "
        "position INTEGER DEFAULT 0, "
        "added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, "
        "PRIMARY KEY (playlist_id, track_id))";
    
    if (!query.exec(createPlaylistTracks)) {
        qDebug() << "playlist_tracks error:" << query.lastError().text();
        success = false;
    }
    
    QString createFriendRequests = 
        "CREATE TABLE IF NOT EXISTS friend_requests ("
        "id SERIAL PRIMARY KEY, "
        "sender_id INTEGER NOT NULL, "
        "receiver_id INTEGER NOT NULL, "
        "status VARCHAR(20) DEFAULT 'pending', "
        "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, "
        "UNIQUE(sender_id, receiver_id))";
    
    if (!query.exec(createFriendRequests)) {
        qDebug() << "friend_requests error:" << query.lastError().text();
        success = false;
    }
    
    QString createFriendships = 
        "CREATE TABLE IF NOT EXISTS friendships ("
        "user_id INTEGER NOT NULL, "
        "friend_id INTEGER NOT NULL, "
        "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, "
        "PRIMARY KEY (user_id, friend_id))";
    
    if (!query.exec(createFriendships)) {
        qDebug() << "friendships error:" << query.lastError().text();
        success = false;
    }
    
    QString createMessages = 
        "CREATE TABLE IF NOT EXISTS messages ("
        "id SERIAL PRIMARY KEY, "
        "sender_id INTEGER NOT NULL, "
        "receiver_id INTEGER NOT NULL, "
        "content TEXT, "
        "type INTEGER DEFAULT 0, "
        "timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP, "
        "is_read BOOLEAN DEFAULT false, "
        "shared_track_id INTEGER)";
    
    if (!query.exec(createMessages)) {
        qDebug() << "messages error:" << query.lastError().text();
        success = false;
    }
    
    QString createRooms = 
        "CREATE TABLE IF NOT EXISTS rooms ("
        "id SERIAL PRIMARY KEY, "
        "name VARCHAR(100) NOT NULL, "
        "description TEXT, "
        "genre VARCHAR(50), "
        "host_id INTEGER NOT NULL, "
        "current_track_id INTEGER, "
        "current_position BIGINT DEFAULT 0, "
        "is_playing BOOLEAN DEFAULT false, "
        "max_members INTEGER DEFAULT 10, "
        "is_private BOOLEAN DEFAULT false, "
        "password VARCHAR(64), "
        "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)";
    
    if (!query.exec(createRooms)) {
        qDebug() << "rooms error:" << query.lastError().text();
        success = false;
    }
    
    QString createRoomMembers = 
        "CREATE TABLE IF NOT EXISTS room_members ("
        "room_id INTEGER NOT NULL, "
        "user_id INTEGER NOT NULL, "
        "is_host BOOLEAN DEFAULT false, "
        "joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, "
        "PRIMARY KEY (room_id, user_id))";
    
    if (!query.exec(createRoomMembers)) {
        qDebug() << "room_members error:" << query.lastError().text();
        success = false;
    }
    
    query.exec("CREATE INDEX IF NOT EXISTS idx_tracks_user ON tracks(user_id)");
    query.exec("CREATE INDEX IF NOT EXISTS idx_messages_receiver ON messages(receiver_id, is_read)");
    query.exec("CREATE INDEX IF NOT EXISTS idx_friendships ON friendships(user_id)");
    query.exec("CREATE INDEX IF NOT EXISTS idx_room_members ON room_members(room_id)");
    
    if (success) {
        QString testPass = hashPassword("test123");
        query.prepare("INSERT INTO users (username, password_hash) "
                     "SELECT 'testuser', ? WHERE NOT EXISTS "
                     "(SELECT 1 FROM users WHERE username = 'testuser')");
        query.addBindValue(testPass);
        query.exec();
    }
    
    return success;
}

bool DatabaseManager::isConnected() const {
    return m_db.isOpen();
}

QString DatabaseManager::hashPassword(const QString& password) {
    return QCryptographicHash::hash(password.toUtf8(), 
                                   QCryptographicHash::Sha256).toHex();
}

QString DatabaseManager::generateFileHash(const QString& filePath) {
    QString uniqueString = QString("%1_%2").arg(filePath).arg(QDateTime::currentMSecsSinceEpoch());
    return QCryptographicHash::hash(uniqueString.toUtf8(), 
                                   QCryptographicHash::Md5).toHex();
}

bool DatabaseManager::registerUser(const QString& username, const QString& password) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return false;
    }
    
    if (username.isEmpty() || password.isEmpty() || username.length() < 3 || password.length() < 6) {
        return false;
    }
    
    QSqlQuery checkQuery(m_db);
    checkQuery.prepare("SELECT id FROM users WHERE username = ?");
    checkQuery.addBindValue(username);
    
    if (checkQuery.exec() && checkQuery.next()) {
        return false;
    }
    
    QSqlQuery insertQuery(m_db);
    insertQuery.prepare("INSERT INTO users (username, password_hash) VALUES (?, ?)");
    insertQuery.addBindValue(username);
    insertQuery.addBindValue(hashPassword(password));
    
    return insertQuery.exec();
}

bool DatabaseManager::authenticateUser(const QString& username, const QString& password) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return false;
    }
    
    QSqlQuery query(m_db);
    query.prepare("SELECT id, password_hash FROM users WHERE username = ?");
    query.addBindValue(username);
    
    if (!query.exec() || !query.next()) {
        return false;
    }
    
    QString storedHash = query.value("password_hash").toString();
    QString inputHash = hashPassword(password);
    
    return (storedHash == inputHash);
}

int DatabaseManager::getUserId(const QString& username) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return -1;
    }
    
    QSqlQuery query(m_db);
    query.prepare("SELECT id FROM users WHERE username = ?");
    query.addBindValue(username);
    
    if (query.exec() && query.next()) {
        return query.value("id").toInt();
    }
    
    return -1;
}

bool DatabaseManager::addTrack(const QString& filePath, const QString& title, 
                              const QString& artist, const QString& album, 
                              int duration, int userId) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return false;
    }
    
    QString fileHash = generateFileHash(filePath);
    
    QSqlQuery query(m_db);
    query.prepare(
        "INSERT INTO tracks (file_path, file_hash, user_id, title, artist, album, duration) "
        "VALUES (?, ?, ?, ?, ?, ?, ?)"
    );
    
    query.addBindValue(filePath);
    query.addBindValue(fileHash);
    query.addBindValue(userId);
    query.addBindValue(title);
    query.addBindValue(artist);
    query.addBindValue(album);
    query.addBindValue(duration);
    
    return query.exec();
}

QList<TrackData> DatabaseManager::getUserTracks(int userId) {
    QList<TrackData> tracks;
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return tracks;
    }
    
    QSqlQuery query(m_db);
    query.prepare(
        "SELECT id, file_path, file_hash, title, artist, album, duration, "
        "play_count, added_at "
        "FROM tracks WHERE user_id = ? ORDER BY added_at DESC"
    );
    query.addBindValue(userId);
    
    if (query.exec()) {
        while (query.next()) {
            TrackData track;
            track.id = query.value("id").toInt();
            track.filePath = query.value("file_path").toString();
            track.fileHash = query.value("file_hash").toString();
            track.title = query.value("title").toString();
            track.artist = query.value("artist").toString();
            track.album = query.value("album").toString();
            track.duration = query.value("duration").toInt();
            track.playCount = query.value("play_count").toInt();
            track.addedAt = query.value("added_at").toString();
            
            tracks.append(track);
        }
    }
    
    return tracks;
}

bool DatabaseManager::incrementPlayCount(int trackId) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return false;
    }
    
    QSqlQuery query(m_db);
    query.prepare("UPDATE tracks SET play_count = play_count + 1 WHERE id = ?");
    query.addBindValue(trackId);
    
    return query.exec();
}

bool DatabaseManager::deleteTrack(int trackId) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return false;
    }
    
    QSqlQuery deleteFromPlaylists(m_db);
    deleteFromPlaylists.prepare("DELETE FROM playlist_tracks WHERE track_id = ?");
    deleteFromPlaylists.addBindValue(trackId);
    deleteFromPlaylists.exec();
    
    QSqlQuery deleteTrackQuery(m_db);
    deleteTrackQuery.prepare("DELETE FROM tracks WHERE id = ?");
    deleteTrackQuery.addBindValue(trackId);
    
    return deleteTrackQuery.exec();
}

bool DatabaseManager::addTrackFromAPI(int userId, const QString& title, 
                                     const QString& artist, const QString& coverUrl,
                                     const QString& album, int duration,
                                     const QString& genre) {
    QMutexLocker locker(&m_mutex);
    
    if (!m_db.isOpen()) {
        if (!initialize()) return false;
    }
    
    QString virtualPath = QString("lastfm://%1/%2").arg(artist).arg(title);
    QString fileHash = generateFileHash(virtualPath);
    
    QSqlQuery query(m_db);
    query.prepare(
        "INSERT INTO tracks (file_path, file_hash, user_id, title, artist, "
        "album, duration, cover_url, genre) "
        "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)"
    );
    
    query.addBindValue(virtualPath);
    query.addBindValue(fileHash);
    query.addBindValue(userId);
    query.addBindValue(title);
    query.addBindValue(artist);
    query.addBindValue(album);
    query.addBindValue(duration);
    query.addBindValue(coverUrl);
    query.addBindValue(genre);
    
    return query.exec();
}



=== DanilKurs/src/database/DatabaseManager.h ===
#ifndef DATABASEMANAGER_H
#define DATABASEMANAGER_H

#include <QSqlDatabase>
#include <QString>
#include <QList>
#include <QMutex>
#include <QObject>
#include "core/models/Track.h"
#include "core/models/Playlist.h"

class DatabaseManager : public QObject
{
    Q_OBJECT

public:
    static DatabaseManager& instance();
    
    bool initialize();
    bool isConnected() const;
    QSqlDatabase database() { return m_db; }
    
    bool registerUser(const QString& username, const QString& password);
    bool authenticateUser(const QString& username, const QString& password);
    int getUserId(const QString& username);
    
    bool addTrack(const QString& filePath, const QString& title, 
                 const QString& artist, const QString& album, 
                 int duration, int userId);
    QList<TrackData> getUserTracks(int userId);
    bool incrementPlayCount(int trackId);
    bool deleteTrack(int trackId);
    
    bool addTrackFromAPI(int userId, const QString& title, 
                        const QString& artist, const QString& coverUrl,
                        const QString& album = "", int duration = 0,
                        const QString& genre = "");

private:
    DatabaseManager(QObject *parent = nullptr);
    ~DatabaseManager();
    DatabaseManager(const DatabaseManager&) = delete;
    DatabaseManager& operator=(const DatabaseManager&) = delete;
    
    bool openConnection();
    bool createTables();
    QString hashPassword(const QString& password);
    QString generateFileHash(const QString& filePath);
    
    QSqlDatabase m_db;
    static QMutex m_mutex;
    bool m_initialized;

};

#endif


=== DanilKurs/src/database/api/MusicAPIManager.h ===
#ifndef MUSICAPIMANAGER_H
#define MUSICAPIMANAGER_H

#include <QObject>
#include <QNetworkAccessManager>
#include <QNetworkReply>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonArray>
#include <QUrlQuery>
#include <QVariant>

class MusicAPIManager : public QObject
{
    Q_OBJECT

public:
    explicit MusicAPIManager(QObject *parent = nullptr);
    
    void searchTracks(const QString& query, int userId);
    void getTopTracks(int userId);
    void getTrackDetails(const QString& artist, const QString& track);
    void getArtistInfo(const QString& artist);

signals:
    void tracksFound(const QVariantList& tracks);
    void trackDetailsFound(const QVariantMap& details);
    void artistInfoFound(const QVariantMap& info);
    void errorOccurred(const QString& error);

private slots:
    void handleNetworkResponse(QNetworkReply *reply);

private:
    void processSearchResponse(const QByteArray& responseData);
    void processTopTracksResponse(const QByteArray& responseData);
    void processTrackDetailsResponse(const QByteArray& responseData);
    void processArtistInfoResponse(const QByteArray& responseData);
    void processTracksData(const QJsonArray& tracksArray);
    
    QNetworkAccessManager* m_networkManager;
    QString m_apiKey;
    QString m_baseUrl;
    int m_currentUserId;
    QString m_currentRequestType;
};

#endif


=== DanilKurs/src/database/api/MusicAPIManager.cpp ===
#include "MusicAPIManager.h"
#include "../DatabaseManager.h"
#include <QDebug>
#include <QSslError>

MusicAPIManager::MusicAPIManager(QObject *parent) 
    : QObject(parent)
    , m_networkManager(new QNetworkAccessManager(this))
    , m_apiKey("5d63cb6ba6780da3f1306e10539e4b01")
    , m_baseUrl("https://ws.audioscrobbler.com/2.0/")
    , m_currentUserId(-1)
{
    m_networkManager->setRedirectPolicy(QNetworkRequest::NoLessSafeRedirectPolicy);
    connect(m_networkManager, &QNetworkAccessManager::finished,
            this, &MusicAPIManager::handleNetworkResponse);
}

void MusicAPIManager::searchTracks(const QString& query, int userId)
{
    m_currentUserId = userId;
    m_currentRequestType = "search";
    
    QUrl url(m_baseUrl);
    QUrlQuery params;
    params.addQueryItem("method", "track.search");
    params.addQueryItem("track", query);
    params.addQueryItem("api_key", m_apiKey);
    params.addQueryItem("format", "json");
    params.addQueryItem("limit", "20");
    
    url.setQuery(params);
    
    QNetworkRequest request(url);
    m_networkManager->get(request);
}

void MusicAPIManager::getTopTracks(int userId)
{
    m_currentUserId = userId;
    m_currentRequestType = "toptracks";
    
    QUrl url(m_baseUrl);
    QUrlQuery params;
    params.addQueryItem("method", "chart.gettoptracks");
    params.addQueryItem("api_key", m_apiKey);
    params.addQueryItem("format", "json");
    params.addQueryItem("limit", "20");
    
    url.setQuery(params);
    
    QNetworkRequest request(url);
    m_networkManager->get(request);
}

void MusicAPIManager::getTrackDetails(const QString& artist, const QString& track)
{
    m_currentRequestType = "trackinfo";
    
    QUrl url(m_baseUrl);
    QUrlQuery params;
    params.addQueryItem("method", "track.getInfo");
    params.addQueryItem("artist", artist);
    params.addQueryItem("track", track);
    params.addQueryItem("api_key", m_apiKey);
    params.addQueryItem("format", "json");
    
    url.setQuery(params);
    
    QNetworkRequest request(url);
    m_networkManager->get(request);
}

void MusicAPIManager::getArtistInfo(const QString& artist)
{
    m_currentRequestType = "artistinfo";
    
    QUrl url(m_baseUrl);
    QUrlQuery params;
    params.addQueryItem("method", "artist.getInfo");
    params.addQueryItem("artist", artist);
    params.addQueryItem("api_key", m_apiKey);
    params.addQueryItem("format", "json");
    
    url.setQuery(params);
    
    QNetworkRequest request(url);
    m_networkManager->get(request);
}

void MusicAPIManager::handleNetworkResponse(QNetworkReply *reply)
{
    if (!reply) return;
    
    QByteArray responseData = reply->readAll();
    
    if (responseData.isEmpty()) {
        emit errorOccurred("Empty response");
        reply->deleteLater();
        return;
    }
    
    if (reply->error() == QNetworkReply::NoError) {
        if (m_currentRequestType == "search") {
            processSearchResponse(responseData);
        } else if (m_currentRequestType == "toptracks") {
            processTopTracksResponse(responseData);
        } else if (m_currentRequestType == "trackinfo") {
            processTrackDetailsResponse(responseData);
        } else if (m_currentRequestType == "artistinfo") {
            processArtistInfoResponse(responseData);
        }
    } else {
        emit errorOccurred(reply->errorString());
    }
    
    reply->deleteLater();
}

void MusicAPIManager::processSearchResponse(const QByteArray& responseData)
{
    QJsonParseError parseError;
    QJsonDocument doc = QJsonDocument::fromJson(responseData, &parseError);
    
    if (parseError.error != QJsonParseError::NoError) {
        emit errorOccurred("JSON parse error");
        return;
    }
    
    QJsonObject root = doc.object();
    
    if (root.contains("error")) {
        emit errorOccurred(root["message"].toString());
        return;
    }
    
    if (root.contains("results")) {
        QJsonObject results = root["results"].toObject();
        QJsonObject trackMatches = results["trackmatches"].toObject();
        QJsonArray tracks = trackMatches["track"].toArray();
        
        processTracksData(tracks);
    }
}

void MusicAPIManager::processTopTracksResponse(const QByteArray& responseData)
{
    QJsonParseError parseError;
    QJsonDocument doc = QJsonDocument::fromJson(responseData, &parseError);
    
    if (parseError.error != QJsonParseError::NoError) {
        emit errorOccurred("JSON parse error");
        return;
    }
    
    QJsonObject root = doc.object();
    
    if (root.contains("error")) {
        emit errorOccurred(root["message"].toString());
        return;
    }
    
    if (root.contains("tracks")) {
        QJsonObject tracksObj = root["tracks"].toObject();
        QJsonArray tracks = tracksObj["track"].toArray();
        
        processTracksData(tracks);
    }
}

void MusicAPIManager::processTrackDetailsResponse(const QByteArray& responseData)
{
    QJsonParseError parseError;
    QJsonDocument doc = QJsonDocument::fromJson(responseData, &parseError);
    
    if (parseError.error != QJsonParseError::NoError) {
        emit errorOccurred("JSON parse error");
        return;
    }
    
    QJsonObject root = doc.object();
    
    if (root.contains("track")) {
        QJsonObject track = root["track"].toObject();
        
        QVariantMap details;
        details["name"] = track["name"].toString();
        details["artist"] = track["artist"].toObject()["name"].toString();
        details["album"] = track["album"].toObject()["title"].toString();
        details["duration"] = track["duration"].toInt() / 1000;
        details["listeners"] = track["listeners"].toString();
        details["playcount"] = track["playcount"].toString();
        
        emit trackDetailsFound(details);
    }
}

void MusicAPIManager::processArtistInfoResponse(const QByteArray& responseData)
{
    QJsonParseError parseError;
    QJsonDocument doc = QJsonDocument::fromJson(responseData, &parseError);
    
    if (parseError.error != QJsonParseError::NoError) {
        emit errorOccurred("JSON parse error");
        return;
    }
    
    QJsonObject root = doc.object();
    
    if (root.contains("artist")) {
        QJsonObject artist = root["artist"].toObject();
        
        QVariantMap info;
        info["name"] = artist["name"].toString();
        info["listeners"] = artist["stats"].toObject()["listeners"].toString();
        info["playcount"] = artist["stats"].toObject()["playcount"].toString();
        info["bio"] = artist["bio"].toObject()["summary"].toString();
        
        emit artistInfoFound(info);
    }
}

void MusicAPIManager::processTracksData(const QJsonArray& tracksArray)
{
    QVariantList processedTracks;
    
    for (const QJsonValue &trackValue : tracksArray) {
        QJsonObject trackObj = trackValue.toObject();
        
        QVariantMap track;
        
        if (trackObj.contains("artist") && trackObj["artist"].isObject()) {
            QJsonObject artistObj = trackObj["artist"].toObject();
            track["artist"] = artistObj["name"].toString();
        } else {
            track["artist"] = trackObj["artist"].toString();
        }
        
        track["title"] = trackObj["name"].toString();
        
        QString coverUrl;
        if (trackObj.contains("image")) {
            QJsonArray images = trackObj["image"].toArray();
            for (int i = images.size() - 1; i >= 0; --i) {
                QString imageUrl = images[i].toObject()["#text"].toString();
                if (!imageUrl.isEmpty()) {
                    coverUrl = imageUrl;
                    break;
                }
            }
        }
        
        track["coverUrl"] = coverUrl;
        track["listeners"] = trackObj["listeners"].toString();
        track["playcount"] = trackObj["playcount"].toString();
        
        processedTracks.append(track);
        
        DatabaseManager::instance().addTrackFromAPI(
            m_currentUserId,
            track["title"].toString(),
            track["artist"].toString(),
            coverUrl
        );
    }
    
    emit tracksFound(processedTracks);
}


=== DanilKurs/src/database/DatabaseManager_friends.cpp ===
#include "DatabaseManager.h"
#include <QSqlQuery>
#include <QSqlError>
#include <QDebug>

QVector<QPair<int, QString>> DatabaseManager::getFriendsSimple(int userId)
{
    QVector<QPair<int, QString>> friends;
    QSqlQuery q(database());

    q.prepare(
        "SELECT u.id, u.username "
        "FROM friendships f "
        "JOIN users u ON u.id = f.friend_id "
        "WHERE f.user_id = :me "
        "ORDER BY LOWER(u.username)"
    );
    q.bindValue(":me", userId);

    if (!q.exec()) {
        qDebug() << "getFriendsSimple failed:" << q.lastError().text();
        return friends;
    }

    while (q.next()) {
        friends.push_back(qMakePair(q.value(0).toInt(), q.value(1).toString()));
    }
    return friends;
}


=== DanilKurs/src/network/WebSocketClient.cpp ===
#include "WebSocketClient.h"
#include <QJsonDocument>
#include <QDebug>

WebSocketClient::WebSocketClient(int userId, QObject *parent)
    : QObject(parent)
    , m_webSocket(new QWebSocket())
    , m_userId(userId)
    , m_isConnected(false)
{
    connect(m_webSocket, &QWebSocket::connected, this, &WebSocketClient::onConnected);
    connect(m_webSocket, &QWebSocket::disconnected, this, &WebSocketClient::onDisconnected);
    connect(m_webSocket, &QWebSocket::textMessageReceived, this, &WebSocketClient::onTextMessageReceived);
    connect(m_webSocket, QOverload<QAbstractSocket::SocketError>::of(&QWebSocket::error), 
            this, &WebSocketClient::onError);
}

WebSocketClient::~WebSocketClient()
{
    if (m_isConnected) {
        m_webSocket->close();
    }
    delete m_webSocket;
}

void WebSocketClient::connectToServer(const QString& url)
{
    if (m_isConnected) {
        return;
    }
    
    m_webSocket->open(QUrl(url));
}

void WebSocketClient::disconnect()
{
    if (m_isConnected) {
        m_webSocket->close();
    }
}

void WebSocketClient::joinRoom(int roomId)
{
    QJsonObject json;
    json["type"] = "join_room";
    json["userId"] = m_userId;
    json["roomId"] = roomId;
    
    sendJson(json);
}

void WebSocketClient::leaveRoom(int roomId)
{
    QJsonObject json;
    json["type"] = "leave_room";
    json["userId"] = m_userId;
    json["roomId"] = roomId;
    
    sendJson(json);
}

void WebSocketClient::sendMessage(int roomId, const QString& message)
{
    QJsonObject json;
    json["type"] = "chat_message";
    json["userId"] = m_userId;
    json["roomId"] = roomId;
    json["message"] = message;
    
    sendJson(json);
}

void WebSocketClient::updatePlaybackState(int roomId, bool isPlaying, qint64 position)
{
    QJsonObject json;
    json["type"] = "playback_state";
    json["userId"] = m_userId;
    json["roomId"] = roomId;
    json["isPlaying"] = isPlaying;
    json["position"] = position;
    
    sendJson(json);
}

void WebSocketClient::onConnected()
{
    m_isConnected = true;
    
    QJsonObject authJson;
    authJson["type"] = "authenticate";
    authJson["userId"] = m_userId;
    
    sendJson(authJson);
    
    emit connected();
}

void WebSocketClient::onDisconnected()
{
    m_isConnected = false;
    emit disconnected();
}

void WebSocketClient::onTextMessageReceived(const QString& message)
{
    QJsonDocument doc = QJsonDocument::fromJson(message.toUtf8());
    
    if (!doc.isObject()) {
        return;
    }
    
    QJsonObject json = doc.object();
    QString type = json["type"].toString();
    
    if (type == "playback_state") {
        int roomId = json["roomId"].toInt();
        bool isPlaying = json["isPlaying"].toBool();
        qint64 position = json["position"].toVariant().toLongLong();
        
        emit roomStateUpdated(roomId, isPlaying, position);
    }
    else if (type == "user_joined") {
        int roomId = json["roomId"].toInt();
        int userId = json["userId"].toInt();
        QString username = json["username"].toString();
        
        emit userJoined(roomId, userId, username);
    }
    else if (type == "user_left") {
        int roomId = json["roomId"].toInt();
        int userId = json["userId"].toInt();
        
        emit userLeft(roomId, userId);
    }
    
    emit messageReceived(json);
}

void WebSocketClient::onError(QAbstractSocket::SocketError error)
{
    qDebug() << "WebSocket error:" << error << m_webSocket->errorString();
}

void WebSocketClient::sendJson(const QJsonObject& json)
{
    if (!m_isConnected) {
        return;
    }
    
    QJsonDocument doc(json);
    m_webSocket->sendTextMessage(doc.toJson(QJsonDocument::Compact));
}


=== DanilKurs/src/network/FriendManager.h ===
#ifndef FRIENDMANAGER_H
#define FRIENDMANAGER_H

#include <QObject>
#include <QVector>
#include "core/models/User.h"

class FriendManager : public QObject
{
    Q_OBJECT

public:
    explicit FriendManager(int userId, QObject *parent = nullptr);
    
    bool sendFriendRequest(int targetUserId);
    bool acceptFriendRequest(int requesterId);
    bool rejectFriendRequest(int requesterId);
    bool removeFriend(int friendId);
    QVector<User> getFriends();
    QVector<User> getPendingRequests();
    QVector<User> searchUsers(const QString& query);

signals:
    void friendRequestReceived(const User& user);
    void friendAdded(const User& user);
    void friendRemoved(int userId);
    void friendStatusChanged(int userId, UserStatus status);

private:
    int m_currentUserId;
};

#endif


=== DanilKurs/src/network/ChatManager.cpp ===
#include "ChatManager.h"
#include "database/DatabaseManager.h"
#include <QSqlQuery>
#include <QSqlError>
#include <QDebug>

ChatManager::ChatManager(int userId, QObject *parent)
    : QObject(parent), m_currentUserId(userId)
{
}

bool ChatManager::sendMessage(int receiverId, const QString& content, MessageType type)
{
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "INSERT INTO messages (sender_id, receiver_id, content, type, timestamp, is_read) "
        "VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP, false) RETURNING id"
    );
    query.addBindValue(m_currentUserId);
    query.addBindValue(receiverId);
    query.addBindValue(content);
    query.addBindValue(static_cast<int>(type));

    if (query.exec() && query.next()) {
        int messageId = query.value(0).toInt();
        emit messageSent(messageId);
        return true;
    }

    return false;
}

bool ChatManager::shareTrack(int receiverId, int trackId)
{
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "INSERT INTO messages (sender_id, receiver_id, type, shared_track_id, timestamp, is_read) "
        "VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP, false)"
    );
    query.addBindValue(m_currentUserId);
    query.addBindValue(receiverId);
    query.addBindValue(static_cast<int>(MessageType::TrackShare));
    query.addBindValue(trackId);

    return query.exec();
}

QVector<Message> ChatManager::getMessages(int otherUserId, int limit)
{
    QVector<Message> messages;

    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "SELECT m.id, m.sender_id, m.receiver_id, u.username, u.avatar_path, "
        "m.content, m.type, m.timestamp, m.is_read, m.shared_track_id, "
        "t.title, t.artist "
        "FROM messages m "
        "INNER JOIN users u ON u.id = m.sender_id "
        "LEFT JOIN tracks t ON t.id = m.shared_track_id "
        "WHERE (m.sender_id = ? AND m.receiver_id = ?) "
        "OR (m.sender_id = ? AND m.receiver_id = ?) "
        "ORDER BY m.timestamp DESC LIMIT ?"
    );
    query.addBindValue(m_currentUserId);
    query.addBindValue(otherUserId);
    query.addBindValue(otherUserId);
    query.addBindValue(m_currentUserId);
    query.addBindValue(limit);

    if (query.exec()) {
        while (query.next()) {
            Message msg;
            msg.id = query.value(0).toInt();
            msg.senderId = query.value(1).toInt();
            msg.receiverId = query.value(2).toInt();
            msg.senderUsername = query.value(3).toString();
            msg.senderAvatarPath = query.value(4).toString();
            msg.content = query.value(5).toString();
            msg.type = static_cast<MessageType>(query.value(6).toInt());
            msg.timestamp = query.value(7).toDateTime();
            msg.isRead = query.value(8).toBool();
            msg.sharedTrackId = query.value(9).toInt();
            msg.trackTitle = query.value(10).toString();
            msg.trackArtist = query.value(11).toString();

            messages.append(msg);
        }
    }

    return messages;
}

QVector<Message> ChatManager::getUnreadMessages()
{
    QVector<Message> messages;

    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "SELECT m.id, m.sender_id, m.receiver_id, u.username, u.avatar_path, "
        "m.content, m.type, m.timestamp, m.shared_track_id, t.title, t.artist "
        "FROM messages m "
        "INNER JOIN users u ON u.id = m.sender_id "
        "LEFT JOIN tracks t ON t.id = m.shared_track_id "
        "WHERE m.receiver_id = ? AND m.is_read = false "
        "ORDER BY m.timestamp DESC"
    );
    query.addBindValue(m_currentUserId);

    if (query.exec()) {
        while (query.next()) {
            Message msg;
            msg.id = query.value(0).toInt();
            msg.senderId = query.value(1).toInt();
            msg.receiverId = query.value(2).toInt();
            msg.senderUsername = query.value(3).toString();
            msg.senderAvatarPath = query.value(4).toString();
            msg.content = query.value(5).toString();
            msg.type = static_cast<MessageType>(query.value(6).toInt());
            msg.timestamp = query.value(7).toDateTime();
            msg.sharedTrackId = query.value(8).toInt();
            msg.trackTitle = query.value(9).toString();
            msg.trackArtist = query.value(10).toString();
            msg.isRead = false;

            messages.append(msg);
        }
    }

    return messages;
}

bool ChatManager::markAsRead(int messageId)
{
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare("UPDATE messages SET is_read = true WHERE id = ? AND receiver_id = ?");
    query.addBindValue(messageId);
    query.addBindValue(m_currentUserId);

    return query.exec();
}

QVector<ChatPreview> ChatManager::getChatList()
{
    QVector<ChatPreview> chats;

    const int me = m_currentUserId;
    const QString sql = QString(
        "WITH last_messages AS ( "
        "    SELECT DISTINCT ON (LEAST(sender_id, receiver_id), GREATEST(sender_id, receiver_id)) "
        "           CASE WHEN sender_id = %1 THEN receiver_id ELSE sender_id END as other_user_id, "
        "           content, timestamp, is_read "
        "    FROM messages "
        "    WHERE sender_id = %1 OR receiver_id = %1 "
        "    ORDER BY LEAST(sender_id, receiver_id), GREATEST(sender_id, receiver_id), timestamp DESC "
        ") "
        "SELECT u.id, u.username, u.avatar_path, lm.content, lm.timestamp, "
        "       COUNT(m.id) FILTER (WHERE m.receiver_id = %1 AND m.is_read = false) as unread "
        "FROM last_messages lm "
        "INNER JOIN users u ON u.id = lm.other_user_id "
        "LEFT JOIN messages m ON (m.sender_id = u.id AND m.receiver_id = %1) OR (m.receiver_id = u.id AND m.sender_id = %1) "
        "GROUP BY u.id, u.username, u.avatar_path, lm.content, lm.timestamp "
        "ORDER BY lm.timestamp DESC"
    ).arg(me);

    QSqlQuery query(DatabaseManager::instance().database());
    if (!query.exec(sql)) {
        qDebug() << "getChatList failed:" << query.lastError().text();
        return chats;
    }

    while (query.next()) {
        ChatPreview chat;
        chat.userId = query.value(0).toInt();
        chat.username = query.value(1).toString();
        chat.avatarPath = query.value(2).toString();
        chat.lastMessage = query.value(3).toString();
        chat.lastMessageTime = query.value(4).toDateTime();
        chat.unreadCount = query.value(5).toInt();
        chat.isOnline = false;
        chats.append(chat);
    }

    return chats;
}

int ChatManager::getUnreadCount()
{
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare("SELECT COUNT(*) FROM messages WHERE receiver_id = ? AND is_read = false");
    query.addBindValue(m_currentUserId);

    if (query.exec() && query.next()) {
        return query.value(0).toInt();
    }

    return 0;
}


=== DanilKurs/src/network/RoomManager.cpp ===
#include "RoomManager.h"
#include "database/DatabaseManager.h"
#include <QSqlQuery>
#include <QSqlError>
#include <QDebug>

RoomManager::RoomManager(int userId, QObject *parent)
    : QObject(parent), m_userId(userId)
{
}

int RoomManager::createRoom(const QString& name, const QString& description, 
                           const QString& genre, int maxMembers, bool isPrivate)
{
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "INSERT INTO rooms (name, description, genre, host_id, max_members, is_private, created_at) "
        "VALUES (?, ?, ?, ?, ?, ?, NOW()) RETURNING id"
    );
    query.addBindValue(name);
    query.addBindValue(description);
    query.addBindValue(genre);
    query.addBindValue(m_userId);
    query.addBindValue(maxMembers);
    query.addBindValue(isPrivate);
    
    if (query.exec() && query.next()) {
        int roomId = query.value(0).toInt();
        
        QSqlQuery memberQuery(DatabaseManager::instance().database());
        memberQuery.prepare(
            "INSERT INTO room_members (room_id, user_id, is_host, joined_at) "
            "VALUES (?, ?, true, NOW())"
        );
        memberQuery.addBindValue(roomId);
        memberQuery.addBindValue(m_userId);
        memberQuery.exec();
        
        emit roomCreated(roomId);
        return roomId;
    }
    
    return -1;
}

bool RoomManager::deleteRoom(int roomId)
{
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare("DELETE FROM rooms WHERE id = ? AND host_id = ?");
    query.addBindValue(roomId);
    query.addBindValue(m_userId);
    
    if (query.exec()) {
        emit roomDeleted(roomId);
        return true;
    }
    
    return false;
}

bool RoomManager::joinRoom(int roomId)
{
    QSqlQuery checkQuery(DatabaseManager::instance().database());
    checkQuery.prepare(
        "SELECT COUNT(*) FROM room_members WHERE room_id = ?"
    );
    checkQuery.addBindValue(roomId);
    
    if (!checkQuery.exec() || !checkQuery.next()) {
        return false;
    }
    
    int currentMembers = checkQuery.value(0).toInt();
    
    QSqlQuery roomQuery(DatabaseManager::instance().database());
    roomQuery.prepare("SELECT max_members FROM rooms WHERE id = ?");
    roomQuery.addBindValue(roomId);
    
    if (!roomQuery.exec() || !roomQuery.next()) {
        return false;
    }
    
    int maxMembers = roomQuery.value(0).toInt();
    
    if (currentMembers >= maxMembers) {
        return false;
    }
    
    QSqlQuery insertQuery(DatabaseManager::instance().database());
    insertQuery.prepare(
        "INSERT INTO room_members (room_id, user_id, is_host, joined_at) "
        "VALUES (?, ?, false, NOW()) ON CONFLICT (room_id, user_id) DO NOTHING"
    );
    insertQuery.addBindValue(roomId);
    insertQuery.addBindValue(m_userId);
    
    if (insertQuery.exec()) {
        emit roomJoined(roomId);
        return true;
    }
    
    return false;
}

bool RoomManager::leaveRoom(int roomId)
{
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare("DELETE FROM room_members WHERE room_id = ? AND user_id = ?");
    query.addBindValue(roomId);
    query.addBindValue(m_userId);
    
    if (query.exec()) {
        emit roomLeft(roomId);
        return true;
    }
    
    return false;
}

QVector<Room> RoomManager::getPublicRooms()
{
    QVector<Room> rooms;
    
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "SELECT r.id, r.name, r.description, r.genre, r.host_id, "
        "r.current_track_id, r.current_position, r.is_playing, r.max_members, "
        "r.created_at, t.title, t.artist, "
        "(SELECT COUNT(*) FROM room_members WHERE room_id = r.id) as member_count "
        "FROM rooms r "
        "LEFT JOIN tracks t ON t.id = r.current_track_id "
        "WHERE r.is_private = false "
        "ORDER BY r.created_at DESC"
    );
    
    if (query.exec()) {
        while (query.next()) {
            Room room;
            room.id = query.value(0).toInt();
            room.name = query.value(1).toString();
            room.description = query.value(2).toString();
            room.genre = query.value(3).toString();
            room.hostId = query.value(4).toInt();
            room.currentTrackId = query.value(5).toInt();
            room.currentPosition = query.value(6).toLongLong();
            room.isPlaying = query.value(7).toBool();
            room.maxMembers = query.value(8).toInt();
            room.createdAt = query.value(9).toDateTime();
            room.currentTrackTitle = query.value(10).toString();
            room.currentTrackArtist = query.value(11).toString();
            
            int memberCount = query.value(12).toInt();
            room.members.resize(memberCount);
            
            rooms.append(room);
        }
    }
    
    return rooms;
}

Room RoomManager::getRoomDetails(int roomId)
{
    Room room;
    room.id = -1;
    
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "SELECT id, name, description, genre, host_id, current_track_id, "
        "current_position, is_playing, max_members, created_at "
        "FROM rooms WHERE id = ?"
    );
    query.addBindValue(roomId);
    
    if (query.exec() && query.next()) {
        room.id = query.value(0).toInt();
        room.name = query.value(1).toString();
        room.description = query.value(2).toString();
        room.genre = query.value(3).toString();
        room.hostId = query.value(4).toInt();
        room.currentTrackId = query.value(5).toInt();
        room.currentPosition = query.value(6).toLongLong();
        room.isPlaying = query.value(7).toBool();
        room.maxMembers = query.value(8).toInt();
        room.createdAt = query.value(9).toDateTime();
    }
    
    return room;
}

QVector<RoomMember> RoomManager::getRoomMembers(int roomId)
{
    QVector<RoomMember> members;
    
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "SELECT u.id, u.username, u.avatar_path, rm.is_host, rm.joined_at "
        "FROM room_members rm "
        "INNER JOIN users u ON u.id = rm.user_id "
        "WHERE rm.room_id = ? "
        "ORDER BY rm.is_host DESC, rm.joined_at"
    );
    query.addBindValue(roomId);
    
    if (query.exec()) {
        while (query.next()) {
            RoomMember member;
            member.userId = query.value(0).toInt();
            member.username = query.value(1).toString();
            member.avatarPath = query.value(2).toString();
            member.isHost = query.value(3).toBool();
            member.joinedAt = query.value(4).toDateTime();
            
            members.append(member);
        }
    }
    
    return members;
}

bool RoomManager::updateRoomTrack(int roomId, int trackId)
{
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "UPDATE rooms SET current_track_id = ?, current_position = 0 "
        "WHERE id = ? AND host_id = ?"
    );
    query.addBindValue(trackId);
    query.addBindValue(roomId);
    query.addBindValue(m_userId);
    
    if (query.exec()) {
        emit roomUpdated(roomId);
        return true;
    }
    
    return false;
}

bool RoomManager::updatePlaybackState(int roomId, bool isPlaying, qint64 position)
{
    QSqlQuery query(DatabaseManager::instance().database());
    query.prepare(
        "UPDATE rooms SET is_playing = ?, current_position = ? "
        "WHERE id = ? AND host_id = ?"
    );
    query.addBindValue(isPlaying);
    query.addBindValue(position);
    query.addBindValue(roomId);
    query.addBindValue(m_userId);
    
    return query.exec();
}


=== DanilKurs/src/network/FriendManager.cpp ===
#include "FriendManager.h"
#include "database/DatabaseManager.h"
#include <QSqlQuery>
#include <QSqlError>
#include <QDebug>

FriendManager::FriendManager(int userId, QObject *parent)
    : QObject(parent), m_currentUserId(userId)
{
}

static QString esc(QString s) { return s.replace("'", "''"); }

bool FriendManager::sendFriendRequest(int targetUserId)
{
    QSqlQuery q(DatabaseManager::instance().database());
    QString sql = QString(
        "INSERT INTO friend_requests (sender_id, receiver_id, status, created_at) "
        "VALUES (%1, %2, 'pending', NOW()) "
        "ON CONFLICT (sender_id, receiver_id) DO UPDATE SET status = 'pending', created_at = NOW()"
    ).arg(m_currentUserId).arg(targetUserId);

    if (!q.exec(sql)) { qDebug() << q.lastError().text() << sql; return false; }
    return true;
}

bool FriendManager::acceptFriendRequest(int requesterId)
{
    QSqlDatabase db = DatabaseManager::instance().database();
    if (!db.transaction()) return false;

    QSqlQuery q(db);
    QString sql1 = QString(
        "UPDATE friend_requests SET status='accepted' "
        "WHERE sender_id=%1 AND receiver_id=%2 AND status='pending'"
    ).arg(requesterId).arg(m_currentUserId);

    if (!q.exec(sql1)) { qDebug() << q.lastError().text() << sql1; db.rollback(); return false; }

    QString sql2 = QString(
        "INSERT INTO friendships (user_id, friend_id, created_at) "
        "VALUES (%1,%2,NOW()),(%2,%1,NOW())"
    ).arg(m_currentUserId).arg(requesterId);

    if (!q.exec(sql2)) { qDebug() << q.lastError().text() << sql2; db.rollback(); return false; }

    return db.commit();
}

bool FriendManager::rejectFriendRequest(int requesterId)
{
    QSqlQuery q(DatabaseManager::instance().database());
    QString sql = QString(
        "UPDATE friend_requests SET status='rejected' "
        "WHERE sender_id=%1 AND receiver_id=%2"
    ).arg(requesterId).arg(m_currentUserId);

    if (!q.exec(sql)) { qDebug() << q.lastError().text() << sql; return false; }
    return true;
}

bool FriendManager::removeFriend(int friendId)
{
    QSqlDatabase db = DatabaseManager::instance().database();
    if (!db.transaction()) return false;

    QSqlQuery q(db);
    QString sql = QString(
        "DELETE FROM friendships "
        "WHERE (user_id=%1 AND friend_id=%2) OR (user_id=%2 AND friend_id=%1)"
    ).arg(m_currentUserId).arg(friendId);

    if (!q.exec(sql)) { qDebug() << q.lastError().text() << sql; db.rollback(); return false; }
    if (!db.commit()) return false;

    emit friendRemoved(friendId);
    return true;
}

QVector<User> FriendManager::getFriends()
{
    QVector<User> friends;
    QSqlQuery q(DatabaseManager::instance().database());

    QString sql = QString(
        "SELECT u.id, u.username, u.avatar_path, u.avatar_data "
        "FROM users u "
        "INNER JOIN friendships f ON f.friend_id=u.id "
        "WHERE f.user_id=%1 "
        "ORDER BY u.username"
    ).arg(m_currentUserId);

    if (!q.exec(sql)) { qDebug() << "getFriends:" << q.lastError().text() << sql; return friends; }

    while (q.next()) {
        User u;
        u.id = q.value(0).toInt();
        u.username = q.value(1).toString();
        u.avatarPath = q.value(2).toString();
        u.avatarData = q.value(3).toByteArray();
        u.isFriend = true;
        friends.push_back(u);
    }
    return friends;
}

QVector<User> FriendManager::getPendingRequests()
{
    QVector<User> req;
    QSqlQuery q(DatabaseManager::instance().database());

    QString sql = QString(
        "SELECT u.id, u.username, u.avatar_path, u.avatar_data "
        "FROM users u "
        "INNER JOIN friend_requests fr ON fr.sender_id=u.id "
        "WHERE fr.receiver_id=%1 AND fr.status='pending' "
        "ORDER BY fr.created_at DESC"
    ).arg(m_currentUserId);

    if (!q.exec(sql)) { qDebug() << "getPendingRequests:" << q.lastError().text() << sql; return req; }

    while (q.next()) {
        User u;
        u.id = q.value(0).toInt();
        u.username = q.value(1).toString();
        u.avatarPath = q.value(2).toString();
        u.avatarData = q.value(3).toByteArray();
        u.friendRequestReceived = true;
        req.push_back(u);
    }
    return req;
}

QVector<User> FriendManager::searchUsers(const QString& queryText)
{
    QVector<User> users;
    QSqlQuery q(DatabaseManager::instance().database());

    QString pat = "%" + esc(queryText.trimmed().toLower()) + "%";
    QString sql = QString(
        "SELECT id, username, avatar_path, avatar_data "
        "FROM users "
        "WHERE LOWER(username) LIKE '%1' AND id<>%2 "
        "ORDER BY username "
        "LIMIT 20"
    ).arg(pat).arg(m_currentUserId);

    qDebug() << "SQL(search):" << sql;

    if (!q.exec(sql)) { qDebug() << "searchUsers:" << q.lastError().text(); return users; }

    while (q.next()) {
        User u;
        u.id = q.value(0).toInt();
        u.username = q.value(1).toString();
        u.avatarPath = q.value(2).toString();
        u.avatarData = q.value(3).toByteArray();
        users.push_back(u);
    }
    return users;
}


=== DanilKurs/src/network/WebSocketClient.h ===
#ifndef WEBSOCKETCLIENT_H
#define WEBSOCKETCLIENT_H

#include <QObject>
#include <QWebSocket>
#include <QJsonDocument>
#include <QJsonObject>

class WebSocketClient : public QObject
{
    Q_OBJECT

public:
    explicit WebSocketClient(int userId, QObject *parent = nullptr);
    ~WebSocketClient();
    
    void connectToServer(const QString& url);
    void disconnect();
    
    void joinRoom(int roomId);
    void leaveRoom(int roomId);
    void sendMessage(int roomId, const QString& message);
    void updatePlaybackState(int roomId, bool isPlaying, qint64 position);

signals:
    void connected();
    void disconnected();
    void messageReceived(const QJsonObject& message);
    void roomStateUpdated(int roomId, bool isPlaying, qint64 position);
    void userJoined(int roomId, int userId, const QString& username);
    void userLeft(int roomId, int userId);

private slots:
    void onConnected();
    void onDisconnected();
    void onTextMessageReceived(const QString& message);
    void onError(QAbstractSocket::SocketError error);

private:
    void sendJson(const QJsonObject& json);
    
    QWebSocket* m_webSocket;
    int m_userId;
    bool m_isConnected;
};

#endif


=== DanilKurs/src/network/RoomManager.h ===
#ifndef ROOMMANAGER_H
#define ROOMMANAGER_H

#include <QObject>
#include <QVector>
#include "core/models/Room.h"

class RoomManager : public QObject
{
    Q_OBJECT

public:
    explicit RoomManager(int userId, QObject *parent = nullptr);
    
    int createRoom(const QString& name, const QString& description, 
                   const QString& genre, int maxMembers, bool isPrivate);
    bool deleteRoom(int roomId);
    bool joinRoom(int roomId);
    bool leaveRoom(int roomId);
    
    QVector<Room> getPublicRooms();
    Room getRoomDetails(int roomId);
    QVector<RoomMember> getRoomMembers(int roomId);
    
    bool updateRoomTrack(int roomId, int trackId);
    bool updatePlaybackState(int roomId, bool isPlaying, qint64 position);

signals:
    void roomCreated(int roomId);
    void roomDeleted(int roomId);
    void roomJoined(int roomId);
    void roomLeft(int roomId);
    void roomUpdated(int roomId);
    void memberJoined(int roomId, const RoomMember& member);
    void memberLeft(int roomId, int userId);

private:
    int m_userId;
};

#endif


=== DanilKurs/src/network/ChatManager.h ===
#ifndef CHATMANAGER_H
#define CHATMANAGER_H

#include <QObject>
#include <QVector>
#include "core/models/Message.h"

class ChatManager : public QObject
{
    Q_OBJECT

public:
    explicit ChatManager(int userId, QObject *parent = nullptr);
    
    bool sendMessage(int receiverId, const QString& content, MessageType type = MessageType::Text);
    bool shareTrack(int receiverId, int trackId);
    QVector<Message> getMessages(int otherUserId, int limit = 50);
    QVector<Message> getUnreadMessages();
    bool markAsRead(int messageId);
    QVector<ChatPreview> getChatList();
    int getUnreadCount();

signals:
    void messageReceived(const Message& message);
    void messageSent(int messageId);

private:
    int m_currentUserId;
};

#endif


=== DanilKurs/src/main.cpp ===
#include <QApplication>
#include <QFile>
#include "gui/AuthWindow/AuthWindow.h"
#include "database/DatabaseManager.h"
#include "utils/Config.h"
#include <QDebug>

void loadStyleSheet(QApplication& app)
{
    QString styleSheet = R"(
        * {
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        
        QMainWindow {
            background: qlineargradient(x1:0, y1:0, x2:1, y2:1,
                stop:0 #0F0F14, stop:1 #1A1A21);
        }
        
        QScrollBar:vertical {
            background: rgba(255, 255, 255, 0.05);
            width: 10px;
            border-radius: 5px;
            margin: 0px;
        }
        
        QScrollBar::handle:vertical {
            background: rgba(138, 43, 226, 0.5);
            border-radius: 5px;
            min-height: 30px;
        }
        
        QScrollBar::handle:vertical:hover {
            background: rgba(138, 43, 226, 0.7);
        }
        
        QScrollBar::add-line:vertical,
        QScrollBar::sub-line:vertical {
            height: 0px;
        }
        
        QToolTip {
            background: #1A1A21;
            color: white;
            border: 1px solid rgba(138, 43, 226, 0.5);
            border-radius: 4px;
            padding: 5px;
        }
    )";
    
    app.setStyleSheet(styleSheet);
}

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    
    app.setApplicationName("Chorus");
    app.setApplicationVersion("1.0.0");
    app.setOrganizationName("Chorus");
    
    loadStyleSheet(app);
    
    if (!DatabaseManager::instance().initialize()) {
        qCritical() << "Failed to initialize database";
        return 1;
    }
    
    AuthWindow authWindow;
    authWindow.show();
    
    return app.exec();
}


